El cálculo lambda es un sistema formal originalmente creado con la finalidad de
expresar, manipular y estudiar funciones para el desarrollo de los fundamentos
de la lógica y las matemáticas; a lo largo de la historia, este sistema se ha
adaptado para el estudio de los fundamentos de la computación y como sustento
teórico para el desarrollo de lenguajes de programación. \\

Tres características fundamentales del cálculo lambda son el lenguaje utilizado
para describir expresiones; la interpretación, representación y manejo de
funciones; las nociones de transformación y equivalencia de expresiones. \\

Este capítulo consiste de dos secciones: primero se introduce informalmente el
cálculo lambda, en donde se enfatiza las diferencias conceptuales, operacionales
y de notación entre este sistema, la matemática clásica y la lógica de primer
orden; en la segunda sección se presenta la formalización del cálculo lambda. \\

\section{Noción informal del cálculo lambda}

En el estudio del cálculo lambda existen dos lenguajes, el de las expresiones
del sistema y el que se utiliza para describir y analizar estas expresiones,
llamado metalenguaje. \\

El lenguaje de las expresiones es un \emph{lenguaje formal} que especifica las
secuencias de símbolos que representan expresiones válidas del cálculo lambda,
se relaciona con las clases de objetos del sistema que son válidos manipular,
comparar y representar. Por otro lado, el metalenguaje permite describir
\emph{cómo} es que estas expresiones son manipuladas y comparadas, así como los
mecanismos para representar conceptos y objetos matemáticos como expresiones. \\

\subsection{Expresiones}

Existen tres clases de expresiones en el cálculo lambda: \emph{átomos},
\emph{abstracciones} y \emph{aplicaciones}. \\

Las expresiones mas simples son los átomos, representados con un símbolo como
\(x\), \(y\) o \(z\). Éstas expresiones también son llamadas variables y al
igual que en la matemática clásica y la lógica de primer orden, no tienen mucha
importancia por sí solas, pero al estar asociadas a cuantificadores (\(\forall
x\) y \(\exists x\)) o a funciones (\(f(x)\)) pueden representar valores
complejos. \\

Las abstracciones y aplicaciones son expresiones con estructura, es posible
identificar y referirse a sus partes. Estos son complementarias: las
abstracciones representan la generalización de una expresión y se asocian al
concepto de \emph{función}, mientras que las aplicaciones representan el acto de
concretar una expresión y se asocian al concepto de \emph{aplicación de
  funciones}. \\

La definición de función en la matemática clásica es el de una relación entre un
conjunto de entradas, llamado \emph{dominio} y un conjunto de salidas, llamado
\emph{codominio}. Esta relación tiene además la propiedad de que cada elemento
del dominio se asocia exactamente con un elemento del codominio, formalmente: \\

Sean \(A\) y \(B\) dos conjuntos, una función \(f\) con dominio \(A\) y
codominio \(B\) es un subconjunto del producto cartesiano \(A\times B\), tal que
para toda \(a\in A\), existe \(b\in B\) tal que \((a,\ b)\in f\) y si \((a,\
b^\prime)\in f\) con \(b^\prime \in B\), entonces \(b=b^\prime\). \\

Las funciones tienen varias maneras de ser representadas. En la definición
anterior la representación es la de pares ordenados, en donde la primer
componente del par es un elemento en el dominio y la segunda es un elemento en
el codominio. Dependiendo del uso que se le dá a las funciones,
puede ser conveniente representarlas simbólicamente con expresiones,
gráficamente con dibujos, numéricamente con tablas o incluso verbalmente con
palabras. \\

Las abstracciones en el cálculo lambda son representadas simbólicamente con un
átomo y con otra expresión, se escriben de la forma \(\lc{\x.M}\) donde
\(\lc{x}\) es algún átomo llamado variable enlazada o argumento y \(\lc{M}\)
es alguna expresión ya sea otra abstracción, una aplicación o un átomo a la cual
llamamos cuerpo de la abstracción. \\

Debido a la notación utilizada puede parecer que las abstracciones se relacionan
directamente con las funciones \(f(x)=M\) o con fórmulas lógicas \(\forall x\
M\). Sin embargo, tanto las expresiones de funciones como las fórmulas lógicas
están basadas en conjuntos y en operaciones sobre estos conjuntos, en contraste
con el cálculo lambda, no existe la noción de conjunto, ni de número, ni de
valor de verdad ni de cuantificador lógico en el lenguaje. \\

Es posible utilizar la definición de función para \emph{describir} operaciones y
transformaciones de expresiones en el cálculo lambda, o utilizar lógica de
primer orden para aseverar verdades en el sistema, o cuantificar propiedades de
las expresiones utilizando números, sin embargo estos objetos matemáticos  no
están incrustados en el lenguaje de las expresiones y conforman lo que es el
metalenguaje. \\

Las aplicaciones son expresiones conformadas a partir de otras dos expresiones,
se escriben de la forma \(\lc{M N}\) donde \(\lc{M}\) y \(\lc{N}\) son cualquier
átomo, abstracción o aplicación. El concepto relacionado con las aplicaciones en
la matemática clásica es el del acto de obtener un elemento del codominio de una
función a partir de un elemento en su dominio, por ejemplo, considerando la
función \(f(x)=x^{2}\), la aplicación de \(f\) en 4 es \(f(4)\). La notación del
cálculo lambda es similar a la notación tradicional \(f(x)\), solo que con el
paréntesis abierto antes de la función, es decir, \((f\ x)\). De manera similar
a la aplicación de funciones, existe una operación la cual permite transformar
expresiones de la forma \(\lc{M N}\) donde \(\lc{N}\) es cualquier expresión y
\(\lc{M}\) es una abstracción, a otra expresión \(\lc{Z}\) similar al cuerpo de
\(\lc{M}\) pero con el argumento de \(\lc{M}\) intercambiado por \(\lc{N}\). \\

Las abstracciones y aplicaciones del cálculo lambda son en algunos aspectos mas
restrictivos que las funciones y la aplicación de funciones. La función
considera dos conjuntos cualquiera y no importa que propiedades tengan sus
elementos o que operaciones se pueden realizar sobre ellos. Por otro lado, las
abstracciones y aplicaciones sólo pueden ser descritas a partir de otras
expresiones del cálculo lambda. \\

Cuando se desea representar alguna función en el cálculo lambda, se deben
\emph{codificar} como expresiones del lenguaje los elementos del dominio y el
codominio de la función, así como las operaciones entre elementos de ambos
conjuntos. Por ejemplo, para representar la función \(f : \mathbb{N} \to
\mathbb{N}, f(x)=x^{2}\) primero se deben codificar los números naturales con
expresiones del cálculo lambda, esta codificación debe ser acompañada de la
codificación de las operaciones aritméticas elementales como la suma y resta así
como de los predicados sobre números naturales como discriminar entre el mayor
de dos números o si un número es cero; posteriormente se debe expresar la
operación de exponenciación de cualquier número natural como base y el número 2
como exponente. \\

El hecho de tener un lenguaje tan reducido y minimalista para las expresiones
del cálculo lambda nos permite entender con detalle y precisión todos los
procesos de manipulación y transformación de expresiones y siendo que todo lo
que se representa con el cálculo lambda debe ser codificado como expresiones,
los objetos representados pueden ser entendidos de la misma manera. \\

Con solo átomos, aplicaciones y abstracciones se pueden formular expresiones
complejas. A continuación se presentan seis ejemplos de expresiones y se
describen diferentes maneras en las cuales estas se pueden componer para formar
otras expresiones mas complejas. \\

\begin{itemize}
\item[a)] \(\lc{x}\)
\item[b)] \(\lc{\x.x}\)
\item[c)] \(\lc{y\x.x}\)
\item[d)] \(\lc{(\y.y\x.x)\w.w}\)
\item[e)] \(\lc{\x.x x}\)
\item[f)] \(\lc{\f x.f(f x)}\)
\end{itemize}

Los átomos por si solos son expresiones válidas, en el inciso \emph{a} aparece
el átomo \(\lc{x}\), como tal no tiene mucha utilidad, no podemos decir que toma
valores en algún conjunto o que representa algún valor en particular como falso
o verdadero, es tan sólo un símbolo. Al ser parte de otra expresión, un átomo
puede tener mas relevancia, en el inciso \emph{b} el átomo \(\lc{x}\) el el
cuerpo de la abstracción \(\lc{\x.x}\) y ahora tiene el potencial de ser
cambiado por cualquier otra expresión debido a que también es el argumento. \\

En el inciso \emph{c} se tiene la aplicación del átomo \(\lc{y}\) en la
abstracción del inciso \emph{b}. A pesar de ser contraintuitivo, las expresiones
de aplicación se componen de dos expresiones cualesquiera, por lo tanto, a pesar
de estar asociada conceptualmente con la aplicación con aplicación de funciones,
la expresión \(\lc{y\x.x}\) es válida. La expresión del inciso \emph{d} contiene
la expresión anterior en una abstracción en la primer parte de la aplicación y
nos permite observar dos ideas importantes: primero, las abstracciones pueden ser
aplicadas a abstracciones; segundo, al realizar la operación de aplicar
\(\lc{\y.y\x.x}\) a \(\lc{\w.w}\), el átomo \(\lc{y}\) es intercambiado por la
expresión \(\lc{\w.w}\) la cual a su vez puede ser aplicada a la expresión
\(\lc{\x.x}\). \\

A continuación se muestra la evolución de estas transformaciones mecánicas:

\begin{align*} 
  \text{1. } &\lc{(\y.y(\x.x))(\w.w)} & &\text{ expresión del inciso \emph{d}}\\ 
  \text{2. } &\lc{(\w.w)(\x.x)} & &\text{ al aplicar } \lc{\y.y(\x.x)} \text{ a } \lc{\w.w}\\ 
  \text{3. } &\lc{\x.x} & &\text{ al aplicar } \lc{\w.w} \text{ a } \lc{\x.x}
\end{align*}

En el inciso \emph{e} se presenta una abstracción cuyo cuerpo es la aplicación
de su argumento sobre sí mismo. Lo interesante de esta expresión es que
es que encapsula la idea de replicar a partir de la aplicación cualquier
expresión a la que sea aplicada. Por ejemplo, si aplicamos \(\lc{\x.x x}\) al
átomo \(\lc{y}\) y se realiza la operación de aplicación como en el ejemplo
anterior, se obtiene \(\lc{y y}\) y en general al realizar la operación de
aplicación sobre \(\lc{(\x.x x)M}\) donde \(\lc{M}\) es cualquier expresión, se
obtiene \(\lc{M M}\). Con ésta expresión se puede formular una expresión
auto-replicante en el cálculo lambda: \\

\begin{align*} 
  \text{1. } &\lc{(\x.x x)(\x.x x)} & &\text{ expresión del inciso \emph{e} aplicada a si misma}\\
  \text{2. } &\lc{x} \leftarrow \lc{\x.x x} & &\text{ expresión asociada a } \lc{x} \text{ en el cuerpo de } \lc{\x.x x}\\ 
  \text{3. } &\lc{x x} & &\text{ expresión en donde se intercambia } \lc{x}\\
  \text{4. } &\lc{(\x.x x)(\x.x x)} & &\text{ al completar la operación}
\end{align*}

A este tipo de expresiones se les llaman ``\emph{quines}'' \cite{Hofstadter:GEB}
término originalmente asociado a una paradoja sobre sistemas lógicos
\cite{Quine:Paradox}. \\

En el inciso \emph{f} se tiene una abstracción cuyo cuerpo es otra abstracción.
El concepto interesante que ilustra esta expresión es el de la representación de
funciones de varias variables. Al realizar la operación de abstracción de
\(\lc{\f x.f(f x)}\) a una expresión cualquiera \(\lc{M}\) se obtiene
\(\lc{\x.M(M x)}\); si posteriormente se realiza la aplicación de este resultado
a una expresión cualquiera \(\lc{N}\) se obtiene \(\lc{M(M N)}\), esto sería
similar al resultado que se obtendría de aplicar una función con argumentos
\(f\) y \(x\), con cuerpo \(f(f(x))\) a dos valores de su dominio \(M\) y \(N\).
\\

Otra manera de representar funciones de varias variables como abstracciones del
cálculo lambda es codificando \emph{tuplas} o \emph{secuencias} y poder hacer
referencia a sus elementos de manera individual en el sistema, sin embargo,
representar secuencias es un mecanismo mas complejo que se aborda en el
siguiente capítulo. \\

\subsection{Operaciones}

En el cálculo lambda se pueden realizar algunas operaciones para transformar
expresiones, estas operaciones son parte del metalenguaje y consisten de una
serie de cambios mecánicos a la estructura de las expresiones de acuerdo a un
criterio particular. \\

En la subsección anterior se mencionan dos operaciones que se abordaron
tangencialmente: el intercambio en una expresión de un átomo por otra expresión
y la operación de aplicación de abstracciones. \\

La \emph{sustitución} es la operación que nos permite transformar una expresión
cualquiera \(\lc{M}\) intercambiando las apariciones de un átomo \(\lc{x}\) por alguna
otra expresión \(\lc{M}\), este procedimiento se denota
\(\lc{q[subst[M,x,N]]}\). \\

En muchos casos la operación de sustitución se puede realizar de manera trivial,
por ejemplo:

\begin{align*}
  &\lc{q[subst[x, x, y]]} & \lc{subst[x, x, y]} \\
  &\lc{q[subst[x x \y.y, x, z]]} & \lc{subst[x x \y.y, x, z]} \\
  &\lc{q[subst[subst[w x y z,x,a],y,b]]} & \lc{subst[subst[w x y z,x,a],y,b]} \\
  &\lc{q[subst[x x, x, \w.w]]} & \lc{subst[x x, x, \w.w]} \\
\end{align*}

Existen algunos detalles de la sustitución que se deben tomar en cuenta para
evitar obtener expresiones erróneas, en particular cuando se sustituye en
expresiones que contienen abstracciones. Para ilustrar estos casos especiales,
consideremos la abstracción lambda análoga a la función constante \(\lc{\x.y}\),
la cual al ser aplicada a cualquier otra expresión, resultará siempre en el
átomo \(\lc{y}\). Si se realiza la operación \(\lc{q[subst[\x.y,y,z]]}\) se
obtiene la expresión \(\lc{subst[\x.y,y,z]}\) la cual también es análoga a la
función constante pero con el átomo \(\lc{z}\). Si no se tiene cuidado,
sustituir un átomo por otro en esta abstracción puede resultar en una expresión
con diferente interpretación, en este ejemplo, el caso patológico de la
sustitución ingenua es

\[\lc{q[subst[\x.y,y,x]]}\]

Se puede pensar que el resultado es \(\lc{\x.x}\) la cuál es análoga a la
función identidad, sin embargo, la sustitución no permite cambiar las
expresiones de esta manera. \\

Para entender la operación de sustitución se tiene que pensar que lo que le da
sentido a un átomo \(\lc{x}\) es una \(\lambda x\): Consideremos la expresión
\(\lc{\x y.x y z}\), el átomo \(\lc{x}\) que aparece en el cuerpo de la
expresión se dice ser una variable \emph{ligada} a la \(\lambda x\), la cual se
puede pensar como una especie de ``referencia'' a la expresión a la que la
abstracción es aplicada; esto limita a la operación de sustitución a no romper
la referencia de una variable ligada; de igual manera, el átomo \(\lc{y}\) es
una variable ligada a la \(\lambda y\) y debe mantener su referencia bajo la
operación de sustitución. Sin embargo, el átomo \(\lc{z}\) es lo que se llama
variable \emph{libre}: No está en el \emph{alcance} de alguna
\(\lambda z\) y puede ser libremente sustituida por alguna otra expresión. \\

En el caso patológico de \(\lc{q[subst[\x.y,y,x]]}\) se pretende sustituir la
variable libre \(\lc{y}\) por una expresión \(\lc{x}\), lo cual no debería
presentar problemas, sin embargo, una sustitución tal cual de \(\lc{y}\) por
\(\lc{x}\) introduciría una referencia a la \(\lambda x\) de la expresión, la
cuál no existía previamente. Con esto identificamos las dos limitaciones
fundamentales de la operación de sustitución: la operación
\(\lc{q[subst[M,x,y]]}\) no puede introducir o eliminar referencias a alguna
\(\lambda\) en \(M\). \\

Para resolver el problema de \(\lc{q[subst[\x.y,y,x]]}\) se debe considerar otra
operación llamada \emph{cambio de variable ligada}. Se parte de la observación
que en una expresión del cálculo lambda, las referencias entre \(\lambda x\) y
los átomos \(\lc{x}\) (para cualquier átomo \(\lc{x}\)) es mas importante que el
símbolo con el que se representa el átomo. En las expresiones simbólicas de
funciones sucede lo mismo, al expresar \(f(x)=x^{2}\) y \(f(y)=y^{2}\) hacemos
referencia a la misma regla de correspondencia y por lo tanto a la misma función
(sin considerar el dominio y el codominio de \(f\)). En el cálculo lambda,
cambiar el símbolo que representa el átomo \(\lc{x}\) en la expresión
\(\lc{\x.y}\) por otro símbolo no utilizado como \(\lc{z}\) nos permite realizar
la sustitución sin problemas, de tal manera que:

\begin{align*}
  &\lc{q[subst[\x.y,y,x]]} &\text{después de realizar un cambio de variable ligada, se obtiene} \\
  &\lc{q[subst[\z.y,y,x]]} &\text{se realiza la operación de sustitución} \\
  &\lc{\z.x}               &\text{resultado de la operación}
\end{align*}

Cuando se realiza un cambio de variable ligada sobre una abstracción
\(\lc{\x.M}\) se cambia tanto el átomo \(\lc{x}\) acompañado por la \(\lambda\),
llamada variable \emph{enlazada} como todas las apariciones del átomo
en el cuerpo de la abstracción, también llamado \emph{alcance de} \(\lambda x\).
En el ejemplo anterior el cambio de variable ligada únicamente cambió la
variable enlazada, en otras expresiones el cambio de variable ligada
puede realizarse múltiples veces para transformar varias abstracciones: \\

\begin{align*}
  &\lc{\f x.f(f(f x))} &\text{Cambiando \(f\) por \(g\)} \\
  &\lc{\g x.g(g(g x))} &\text{Cambiando \(x\) por \(y\)} \\
  &\lc{\g y.g(g(g y))} & \\
\end{align*}

El cambio de variable ligada en una abstracción \(\lc{\x.M}\) de \(\lc{x}\) a
\(\lc{y}\) resulta en la abstracción \(\lc{\y.q[subst[M,x,y]]}\). \\

La definición de la operación de sustitución es recursiva y hace uso de la
operación de cambio de variable ligada, considerando a \(\lc{x}\), \(\lc{y}\),
\(\lc{z}\) como átomos diferentes y \(\lc{M}\), \(\lc{N}\) y \(\lc{P}\) como
expresiones cualquiera diferentes:

\begin{itemize}
\item \(\lc{q[subst[x,x,M]]}\) resulta en \(\lc{M}\)
\item \(\lc{q[subst[y,x,M]]}\) resulta en \(\lc{y}\)
\item \(\lc{q[subst[M N, x, P]]}\) resulta en \(\lc{q[subst[M, x, P]] q[subst[N,
    x, P]]}\)
\item \(\lc{q[subst[\x.M, x, N]]}\) resulta en \(\lc{\x.M}\) debido a que las
  referencias a \(\lc{x}\) no deben eliminarse
\item \(\lc{q[subst[\y.M, x, N]]}\) resulta en:
  \begin{itemize}
  \item \(\lc{\y.M}\) cuando \(\lc{x}\) no es una variable libre en \(\lc{M}\)
  \item \(\lc{\y.q[subst[M, x, N]]}\) cuando \(\lc{x}\) es una variable libre en
    \(\lc{M}\) pero \(\lc{y}\) no es una variable libre en \(\lc{N}\) debido a que
    eso introduciría una referencia a \(\lambda y\)
  \item \(\lc{\z.q[subst[subst[M,y,z],x,N]]}\) cuando \(\lc{x}\) es una variable
    libre en \(\lc{M}\) y \(\lc{y}\) es una variable libre en \(\lc{N}\)
  \end{itemize}
\end{itemize}

La operación de \emph{aplicación de abstracciones} es el mecanismo mediante el cual
se puede ``concretar'' una abstracción haciendo uso de otra expresión como valor
de la variable  enlazada. De la misma manera en como se efectúa la
aplicación de funciones en la matemática clásica, el concretar una función
consiste en sustituir todas las apariciones del argumento por el valor en el que
la función es aplicada. \\

La definición de la aplicación de una abstracción \(\lc{\x.M}\) en una expresión
\(\lc{N}\) es \(\lc{q[subst[M,x,N]]}\). A continuación se presentan ejemplos de
aplicación de abstracciones con los pasos de la transformación: \\

\begin{itemize}
\item \(\lc{(\x.x)y}\)
  \begin{enumerate}
  \item \(\lc{q[subst[x,x,y]]}\)
  \item \(\lc{subst[x,x,y]}\)
  \end{enumerate}
\item \(\lc{(\x.(\w.w)x)}\)
  \begin{enumerate}
  \item \(\lc{\x.q[subst[w,w,x]]}\)
  \item \(\lc{\x.subst[w,w,x]}\)
  \end{enumerate}
\item \(\lc{(\f x.f(f(f x)))g y}\)
  \begin{enumerate}
  \item \(\lc{(\x.q[subst[f(f(f x)), f, g]]) y}\)
  \item \(\lc{(\x.subst[f(f(f x)), f, g]) y}\)
  \item \(\lc{q[subst[g(g(g x)), x, y]]}\)
  \item \(\lc{subst[g(g(g x)), x, y]}\)
  \end{enumerate}
\end{itemize}

El cálculo lambda es un sistema maleable y se permite definir operaciones
arbitrarias sobre expresiones para estudiar como el sistema se comporta en
diferentes contextos, por ejemplo, se puede considerar una operación similar a
la sustitución que permite introducir referencias a una o mas \(\lambda\) en una
expresión, sin embargo, el presente trabajo está constituido para entender
plenamente las ideas centrales del cálculo lambda haciendo solamente uso de las
operaciones de \emph{sustitución}, \emph{cambio de variable ligada} y
\emph{aplicación de abstracciones}. \\

\subsection{Equivalencias}

El cálculo lambda se considera formalmente como una \emph{teoría ecuacional},
esto significa que los axiomas del sistema formal son ecuaciones que relacionan
expresiones del lenguaje. Esto hace que el concepto de \emph{equivalencia} de
expresiones sea de suma importancia. \\

Es tan relevante la formalización de las nociones de equivalencia que considerar
alguna equivalencia entre dos expresiones que se escriben diferente puede cambiar
por completo el sistema formal que se estudia. En el desarrollo histórico del
cálculo lambda, el estudio de los criterios que permiten establecer que dos
expresiones son equivalentes ha dado pié a una gran diversidad de variantes de la
teoría original; es por ello que en la literatura se suele hablar de \emph{los
cálculos lambda} y no únicamente de un cálculo lambda. \\

Como se aborda en la subsección anterior, con la operación de sustitución se
puede transformar expresiones del cálculo lambda y definir otras operaciones
como el cambio de variable ligada y la aplicación de abstracciones. Usualmente,
las transformaciones de expresiones se pueden asociar a nociones de
equivalencia. En terminología del cálculo lambda, las nociones de equivalencia
entre expresiones son asociadas a la propiedad de \emph{convertibilidad}, la
cual significa que si dos expresiones \(\lc{M}\) y \(\lc{N}\) son equivalentes en
el sistema, es posible transformar \(\lc{M}\) a \(\lc{N}\) y viceversa por medio
de operaciones. \\

La \emph{equivalencia sintáctica} es una relación entre expresiones que no está
asociada a una transformación, se considera como una equivalencia trivial, ya
que asevera la igualdad entre dos expresiones que son escritas exactamente
igual, símbolo por símbolo a excepción de abusos de notación. Por ejemplo, la
expresión \(\sin^{2}\left( x \right)\) es un abuso de notación de \(\left(
  \sin\left( x \right) \right)^{2}\) y ambas son sintácticamente iguales. En el
cálculo lambda, la equivalencia sintáctica es denotada como \(\lc{M} \synteq
\lc{N}\) cuando \(\lc{M}\) es sintácticamente la misma expresión que \(\lc{N}\).
\\

Todos los cálculos lambda, al igual que la mayoría de los sistemas formales,
comprenden la noción de equivalencia sintáctica. Sin embargo las equivalencias
mas interesantes son las que involucran transformaciones entre expresiones. \\

La operación de cambio de variable ligada se relaciona con una equivalencia
estructural entre dos expresiones. Cuando se realiza esta operación no se
modifica la estructura de la expresión, únicamente se modifica el símbolo usado
para representar un átomo. Considerando la expresión que representa a la función
identidad \(\lc{\x.x}\) se observa que tiene la misma estructura que la
abstracción \(\lc{\y.y}\) y que \(\lc{\z.z}\), estas tres representan el mismo
concepto. De igual manera otras expresiones como \(\lc{x y z}\) o \(\lc{\w.x}\)
son estructuralmente equivalentes a \(\lc{a b c}\) y \(\lc{\f.h}\)
respectivamente. A pesar de que no se escriben sintácticamente igual, la
correspondencia que hay entre las posiciones de los átomos en una y otra
expresión nos permite considerarlas como equivalentes. Sin embargo, la operación
de cambio de variable ligada no considera cambios de nombres a átomos que sean
variables libres. Esta relación de equivalencia es llamada
\(\alpha\)-convertibilidad y se denota como \(\lc{M} \convertible{\alpha}
\lc{N}\) para dos expresiones del cálculo lambda \(\lc{M}\) y \(\lc{N}\) en
donde a partir de una serie de cambios de variables ligadas en \(\lc{M}\) o
parte de \(\lc{M}\) y en \(\lc{N}\) o parte de \(\lc{N}\) se puedan obtener
expresiones sintácticamente equivalentes. \\

Una técnica utilizada por algoritmos que verifican si dos expresiones
\(\lc{M}\) y \(\lc{N}\) son \(\alpha\)-convertibles es la de \emph{índices de De
Bruijn}, esta transformación cambia la aparición de átomos por números naturales
que representan la ``distancia'' de los átomos a las \(\lambda\) que hacen
referencia. Por ejemplo, la expresión

\begin{equation}
  \lc{\z.(\y.y (\x.x))(\x. z x)}
\end{equation}

se escribe usando índices de De Bruijn como

\begin{equation}
  \lambda\ (\lambda\ 1\ (\lambda\ 1))\ (\lambda\ 2\ 1)
\end{equation}

En la figura 1.1 se puede observar de manera gráfica la transformación de una
notación a otra para este ejemplo, visualizando las expresiones del cálculo
lambda como árboles. \\

\begin{figure}[h!]
  \centering
  \begin{tikzpicture}[level/.style={sibling distance=60mm/#1}] 
    \node (term) {
      \(\lc{\z.(\y.y (\x.x))(\x. z x)}\)
    }; 
    \node [below of=term] (arrow1) {
      \(\Downarrow\)
    }; 
    \node [circle,draw,below of= arrow1] (z) {
      \(\lambda z\)
    } child {
      node [circle,draw] (a) {
        \(\lambda y\)
      } child {
        node [circle,draw] (c) {
          \(y\)
        }
      }
      child {
        node [circle,draw] (d) {
          \(\lambda x\)
        }
        child {
          node [circle,draw] (g) {
            \(x\)
          }
        } 
      } 
    } 
    child {
      node [circle,draw] (b) {
        \(\lambda x\)
      } 
      child {node [circle,draw] (e) {
          \(z\)
        }
      } 
      child {
        node [circle,draw] (f) {
          \(x\)
        }
      } 
    };
    \node [below=4cm of z] (arrow2) {
      \(\Downarrow\)
    };
    \node [circle,draw,below of= arrow2] (z2) {
      \(\lambda\)
    }
    child {
      node [circle,draw] (a2) {
        \(\lambda\)
      } 
      child {
        node [circle,draw] (c2) {
          \(1\)
        }
      } 
      child {
        node [circle,draw] (d2) {
          \(\lambda\)
        } 
        child {
          node [circle,draw] (g2) {
            \(1\)
          }
        } 
      } 
    } 
    child {
      node [circle,draw] (b2) {
        \(\lambda\)
      } 
      child {
        node [circle,draw] (e2) {
          \(2\)
        }
      } 
      child {
        node [circle,draw] (f2) {
          \(1\)
        }
      }
    };
    \node [below=4cm of z2] (arrow3) {
      \(\Downarrow\)
    };
    \node [below of=arrow3](bruijn) {
      \(\lambda\ (\lambda\ 1\ (\lambda\ 1))\ (\lambda\ 2\ 1)\)
    };
  \end{tikzpicture}
  \caption{Transformación de la expresión 1.1 a 1.2.}
\end{figure}

Una desventaja de utilizar la notación de De Bruijn es que ciertas expresiones
del cálculo lambda no pueden ser escritas, en particular, los átomos no pueden
ser variables libres para que esta transformación pueda ser realizada. \\

Al igual que el cambio de variable ligada, la operación de aplicación de
abstracciones es utilizada para describir una equivalencia entre expresiones. La
noción básica de esta equivalencia consiste en observar que al aplicar una
abstracción \(\lc{\x.M}\) a una expresión \(\lc{N}\), el resultado de dicha
operación siempre es el mismo. De manera similar a la aplicación de funciones,
cuando se define una función \(f(x)=x^{2}\), la aplicación \(f(3)\) se suele
igualar al resultado de la aplicación: \(f(3) = 8\). \\

Esta relación de equivalencia es llama \(\beta\)-convertibilidad y se denota
como \(\lc{M} \convertible{\beta} \lc{N}\) para dos expresiones \(\lc{M}\) y
\(\lc{N}\) en donde a partir de una serie de aplicaciones de abstracciones,
cambios de variable ligada o el proceso inverso de aplicación de abstracciones en
\(\lc{M}\) o parte de \(\lc{M}\) y \(\lc{N}\) o parte de \(\lc{N}\) se puedan
obtener expresiones sintácticamente equivalentes. \\

Es importante enfatizar que la \(\beta\)-convertibilidad considera el proceso
inverso de la aplicación de abstracciones, por ejemplo, \(\lc{f(f(f x))}
\convertible{\beta} \lc{(\g y.g(g(g y)))f x}\). Todas las relaciones de
equivalencia \textbf{deben} cumplir con tres propiedades:

\begin{itemize}
\item[a)] Toda expresión \(\lc{M}\) es equivalente a sí misma.
\item[b)] Si una expresión \(\lc{M}\) es relacionada con una equivalencia a otra
  expresión \(\lc{N}\), entonces \(\lc{N}\) también es relacionada a \(\lc{M}\).
\item[c)] Si una expresión \(\lc{M}\) se relaciona con una equivalencia a otra
  expresión \(\lc{N}\) y \(\lc{N}\) se relaciona con la misma equivalencia a
  \(\lc{P}\), entonces, \(\lc{M}\) y \(\lc{P}\) se relacionan con esta equivalencia.
\end{itemize}

La equivalencia sintáctica corresponde al inciso \emph{a)} de las propiedades de
equivalencias mencionadas y es llamada propiedad de \emph{reflexividad}; al
igual que la \(\alpha\)-conversión y la \(\beta\)-conversión, la equivalencia
sintáctica no está asociada a una regla de inferencia. En los incisos \emph{b)}
y \emph{c)} se tienen propiedades que parten de expresiones equivalentes y
basado en si estas expresiones son equivalentes o no, ciertas propiedades se
deben cumplir. En el inciso \emph{b)} la propiedad es llamada \emph{simetría},
mientras que en el inciso \emph{c)} la propiedad es llamada
\emph{transitividad}. \\

La \(\alpha\)-conversión y la \(\beta\)-conversión fueron definidas como
equivalencias independientes y su definición cumple con las tres propiedades
mencionadas a pesar de ser definidas en base a un procedimiento y no en una
regla declarativa, sin embargo, es deseable referirse a una sola equivalencia de
expresiones que tenga las propiedades de \emph{reflexividad}, \emph{simetría} y
\emph{transitividad} y posteriormente considerar otras reglas que la equivalencia
deba de cumplir. \\

En \cite{Curry:CombinatoryLogicI} se utilizan las letras griegas \(\alpha\) y
\(\beta\) para referirse a las ecuaciones relacionadas con la
\(\alpha\)-conversión y \(\beta\)-conversión respectivamente y las letras
\(\rho\), \(\sigma\) y \(\tau\) para referirse a las propiedades de
reflexividad, simetría y transitividad respectivamente, se retoma esta convención
para elaborar la siguiente definición de una relación de equivalencia \(\sim\): \\

\begin{align*}
  &(\alpha) &\lc{\x.M} &\sim \lc{\y.q[subst[M,x,y]]} \\
  &(\beta)  &\lc{(\x.M)N} &\sim \lc{q[subst[M,x,N]]} \\
  &(\rho)   &\lc{M} &\sim \lc{M} \\
  &(\sigma) &\lc{M} \sim \lc{N} &\implies \lc{N} \sim \lc{M}\\
  &(\tau)   &\lc{M} \sim \lc{N},\ \lc{N} \sim \lc{P} &\implies \lc{M} \sim \lc{P}
\end{align*}

Las ecuaciones en la definición de \(\sim\) son muy parecidas a las propiedades
de la \(\beta\)-conversión, con la excepción de que la \(\beta\)-conversión
admite transformar partes de las expresiones y \(\sim\) no, por ejemplo

\[\lc{\f.(\x.f x)y} \convertible{\beta} \lc{\f.f y}\]

pero

\[\lc{\f.(\x.f x)y} \not\sim \lc{\f.f y}\]

Para capturar la definición de \(\beta\)-convertibilidad con ecuaciones, es
necesario definir a \(\sim\) en partes de una expresión. Las siguientes reglas,
nombradas por Curry \cite{Curry:CombinatoryLogicI} como \(\nu\), \(\mu\) y
\(\xi\), junto con las reglas de \(\sim\) completan la definición declarativa de
\(\beta\)-convertibilidad:

\begin{align*}
  &(\nu)  &\lc{M} \sim \lc{N} &\implies \lc{M Z} \sim \lc{N Z} \\
  &(\mu)  &\lc{M} \sim \lc{N} &\implies \lc{Z M} \sim \lc{Z N} \\
  &(\xi)  &\lc{M} \sim \lc{N} &\implies \lc{\x.M} \sim \lc{\x.N}
\end{align*}

Con estas reglas, las inferencias lógicas nos permiten abordar la equivalencia
sobre partes de una expresión, por ejemplo, para concluir que \(\lc{\f.(\x.f
  x)y} \sim \lc{\f.f y}\) se sigue el siguiente razonamiento:

\begin{align*}
  (1)& &\lc{(\x.f x)y} &\sim \lc{f y} & &\text{ por \(\beta\)} \\
  (2)& &\lc{\f.(\x.f x)y} &\sim \lc{\f.f y} & &\text{ por \(\xi\)}
\end{align*}

Es posible incluir aún más reglas de equivalencia cuando se estudia el cálculo
lambda, a pesar de poder trabajar con expresiones en este sistema a partir de
equivalencias arbitrarias, usualmente cada regla de equivalencia se asocia
con alguna argumentación basada en la noción de función. \\

Por ejemplo, se puede considerar una expresión de la forma \(\lc{\x.M x}\) y
observar que la abstracción al ser aplicada a alguna expresión \(\lc{N}\) es
\(\beta\)-convertible a \(\lc{M N}\), por lo tanto, desde una perspectiva
funcional, \(\lc{\x.M x}\) y \(\lc{M}\) se considerarían equivalentes. Esta
equivalencia se considera cierta al tratarse de funciones, ya que si para toda \(x\),
la igualdad \(f(x) = g(x)\) es cierta, entonces \(f = g\) también es cierta. \\

En el estudio de algoritmos, esta última equivalencia no es aplicable, ya que el
enfoque no es estudiar relaciones de entradas y salidas, si no el comportamiento
de un procedimiento. Por ejemplo, un algoritmo \(A_{1}\) puede computar los
mismos resultados que otro algoritmo \(A_{2}\) para todas las entradas posibles,
sin embargo, al realizar diferentes operaciones se pueden describir diferentes
procedimientos y por lo tanto no se pueden considerar como equivalentes. \\

Otras maneras de expresar esta última regla son:

\[\infer{\lc{M} \sim \lc{N}}{\lc{M P} \sim \lc{N P}\ \text{ para toda expresión
      \(\lc{P}\)}}\]
\[\infer{\lc{M} \sim \lc{N}}{\lc{M x} \sim \lc{N x}\ \text{ con \(\lc{x}\) no en las variables
      libres de \(\lc{M}\) y \(\lc{N}\)}}\]

Con esto se termina la introducción informal al cálculo lambda, las ideas que se
han manejado en esta sección serán ahora formalizadas y definidas de manera
rigurosa. \\

\section{Formalización del cálculo lambda}

La teoría del cálculo lambda se puede formalizar de diferentes perspectivas, en
este trabajo se abordan dos: a partir de la \emph{reducibilidad} y
\emph{convertibilidad} de expresiones y a partir de \emph{sistemas formales}. La
primera consiste en definir transformaciones de expresiones mediante
procedimientos, mientras que la segunda define axiomas y reglas de inferencia.
\\

Independientemente de la perspectiva de la formalización, los conceptos son los
mismos y las definiciones equivalentes. En ambos casos se formaliza la teoría
\(\boldsymbol{\lambda}\), también llamado cálculo-\(\lambda K \beta\). \\

De acuerdo a Barendregt \cite{Barendregt:Bible}, el objeto de estudio principal
de la teoría \(\boldsymbol{\lambda}\) es el conjunto de términos lambda módulo
convertibilidad, estas nociones serán presentadas en las siguientes
subsecciones. \\

\subsection{Términos lambda}

Esta subsección está basada principalmente en el capítulo 2 de
\cite{Barendregt:Bible}. \\

Los \emph{términos lambda} son las \emph{fórmulas bien formadas} del cálculo
lambda, es decir, las expresiones válidas del sistema. El conjunto de todos los
términos lambda es un lenguaje formal, denotado como \(\Lambda\). \\

El conjunto \(\Lambda\) tiene elementos que son cadenas conformadas por símbolos
en el alfabeto \(\Sigma = \{\texttt{(},\ \texttt{)},\ \texttt{.},\ \lambda\}
\cup V\), donde \(V\) es el conjunto conformado por todas las variables
\(v_{i}\) con \(i\in \mathbb{N}\). \\

El lenguaje \(\Lambda\) se puede definir de diferentes maneras,
tradicionalmente la definición del conjunto de términos lambda se define como el
conjunto mas pequeño en donde: \\

\begin{align}
  \lc{x} \in V &\implies \lc{x} \in \Lambda \\
  \lc{M} \in \Lambda,\ \lc{x} \in V &\implies \lc{\x.M} \in \Lambda \\
  \lc{M},\ \lc{N} \in \Lambda &\implies \lc{M N} \in \Lambda \\
\end{align}

Cada una de estas tres reglas corresponde a las tres clases de términos lambda:
la regla 1.3 define a todos los elementos de \(V\) como términos lambda, a estas
variables se les llama \emph{átomos}; la regla 1.4 define a las cadenas de la
forma \(\lc{\x.M}\) (donde \(\lc{x}\) es un átomo y \(\lc{M}\) es un término
lambda) como términos lambda, a estos términos se les llama
\emph{abstracciones}; la regla 1.5 define a las cadenas de la forma \(\lc{M N}\)
(donde \(\lc{M}\) y \(\lc{N}\) son términos lambda) como términos lambda, a
estos términos se les llama \emph{aplicaciones}. \\

Una definición alternativa de \(\Lambda\) es haciendo uso de gramáticas libres
de contexto: El conjunto de términos lambda es el lenguaje generado por la
gramática libre de contexto \(G\) con categorías sintácticas \(T\) (términos
lambda), \(E\) (aplicaciones), \(F\) (abstracciones) y \(A\) (átomos); símbolos
terminales \(\{\texttt{(},\ \texttt{)},\ \texttt{.},\ \lambda,\ v,\
{}^{\prime}\}\); símbolo inicial \(T\) y con las siguientes reglas de
producción:

\begin{align*}
  \text{1. }\ T &\rightarrow E\ \mid\ F\ \mid\ A \\ 
  \text{2. }\ A &\rightarrow \texttt{v}\ \mid\ A\ {}^{\prime} \\
  \text{3. }\ F &\rightarrow \texttt{(}\ \lambda\ A\ \texttt{.}\ T\ \texttt{)} \\
  \text{4. }\ E &\rightarrow \texttt{(}\ T\ T\ \texttt{)}
\end{align*}

Para facilitar la escritura y lectura de los términos lambda, en este trabajo se
hacen las siguientes consideraciones sobre la notación: \\

\begin{itemize}
\item Cuando se hace referencia a cualquier término lambda se utilizan las
  letras mayúsculas \(\lc{M}\), \(\lc{N}\), \(\lc{P}\), etc. Es importante
  establecer que si en un ejemplo, explicación, teorema o demostración se hace
  referencia a un término lambda con una letra mayúscula, cualquier otra
  aparición de esta letra hace referencia a este mismo término dentro de ese
  contexto.
\item Cuando se hace referencia a cualquier átomo se utilizan las letras
  minúsculas \(\lc{x}\), \(\lc{y}\), \(\lc{z}\), etc. Al igual que en el punto
  anterior, la aparición de una letra minúscula en un ejemplo, explicación,
  teorema o demostración hace referencia al mismo átomo.
\item Los paréntesis son omitidos de acuerdo a las siguientes equivalencias
  sintácticas:
  \begin{itemize}
  \item \(\lc{M N P} \synteq \lc*{M N P}\), en general, se considera la
    aplicación de términos lambda con asociación a la izquierda. Se tiene que
    tener cuidado con respetar esta regla, por ejemplo \(\lc{M(N(O
      P))} \synteq \lc*{M(N(O P))} \not\synteq \lc*{M N O P}\).
  \item \(\lc{\x.M N} \synteq \lc*{\x.M N}\), en general, se puede escribir una
    abstracción omitiendo los paréntesis externos. Es importante escribir de
    manera explícita los paréntesis en algunos casos, por ejemplo \(\lc{(\x.M N) O} \synteq
    \lc*{(\x.M N) O} \not\synteq \lc*{\x.M N O}\) ya que el lado derecho de la
    equivalencia es sintácticamente equivalente a \(\lc{\x.M N O}\).
  \item \(\lc{\x y z.M} \synteq \lc*{\x y z.M}\), en general, si el cuerpo de
    una abstracción es también una abstracción, se pueden agrupar las variables
    ligadas y enlazadas. Éste abuso de notación es consistente con la reducción
    de funciones de varias variables usada por Schönfinkel \cite{Schonfinkel:Varargs}.
  \end{itemize}
\item El símbolo \(\synteq\) denota la equivalencia sintáctica entre dos
  términos lambda.
\end{itemize}

A continuación se muestran ejemplos de términos lambda asociados a términos
sintácticamente equivalentes pero escritos con abuso de notación:

\begin{align*}
  \lc{x y z (y x)} & \synteq \lc*{x y z (y x)}\\
  \lc{\x.u x y} & \synteq \lc*{\x.u x y}\\
  \lc{\u.u(\x.y)} & \synteq \lc*{\u.u(\x.y)}\\
  \lc{(\u.v u u)z y} & \synteq \lc*{(\u.v u u)z y}\\
  \lc{u x(y z)(\v.v y)} & \synteq \lc*{u x(y z)(\v.v y)}\\
  \lc{(\x y z.x z(y z))u v w} & \synteq \lc*{(\x y z.x z(y z))u v w}
\end{align*}

Para hacer referencia a una secuencia con una cantidad arbitraria de términos
lambda se usa la notación
\(\lc{q[seq[x]]}=\lc{q[dots[1,subscript[x,1],subscript[x,n]]]}\) cuando es
secuencia de átomos y
\(\lc{q[seq[M]]}=\lc{q[dots[1,subscript[M,1],subscript[M,n]]]}\) cuando es
secuencia de términos lambda en general. Con esta notación se puede abreviar

\[\lc*{\q[seq[x]].M} \synteq 
\lc*{\q[dots[2,subscript[x,1],subscript[x,2],subscript[x,n]]].M}\]

y


\[\lc*{M q[seq[N]]} \synteq
  \lc*{q[dots[3,M,subscript[N,1],subscript[N,2],subscript[N,n]]]}\]

En algunas demostraciones realizadas por inducción, se usa la expresión
``\emph{inducción sobre} \(\lc{M}\)'' para referirse a la inducción sobre la
\emph{longitud} de \(\lc{M}\). La longitud de un término lambda, denotada como
\(\lc{q[length[M]]}\), es la cantidad de apariciones de átomos en el término
lambda y se define como:

\begin{itemize}
\item \(\lc{q[length[x]]}\ =\ 1\)
\item \(\lc*{q[length[M N]]}\ =\ \lc{q[length[M]]} + \lc{q[length[N]]}\)
\item \(\lc*{q[length[\x.M]]}\ =\ 1 + \lc{q[length[M]]}\)
\end{itemize}

Por ejemplo, la longitud del término lambda \(\lc*{x(\y.y u x)}\) es
\(\lc*{q[length[x(\y.y u x)]]}=\lc{length[x(\y.y u x)]}\). \\

Una cuestión importante al momento de demostrar un teorema o definir un concepto
por inducción sobre un término lambda es que usualmente la inducción matemática
relaciona proposiciones con números naturales. Sin embargo es posible tener dos
términos diferentes \(\lc{M}\) y \(\lc{N}\) tal que
\(\lc{q[length[M]]}=\lc{q[length[N]]}\), por ejemplo \(\lc{\x.x}\) y \(\lc{y
  y}\) tienen longitud 2. La inducción sobre la longitud de un término lambda
considera la estructura del término, de tal manera que para una proposición
\(P\) sobre un término lambda \(\lc{M}\), los casos base de la inducción son
aquellos en donde la estructura no es compuesta (en átomos cuya longitud siempre
es 1) y la hipótesis de inducción considera que la proposición \(P\) se cumple
para los subtérminos de \(\lc{M}\) los cuales estrictamente menor longitud que
\(\lc{M}\). \\

El concepto de aparición de un término lambda en otro se formaliza a partir del
concepto de subtérmino: \(\lc{M}\) es un subtérmino de \(\lc{N}\), denotado
\(\lc{q[subterm[M,N]]}\) si \(\lc{M} \in \lc{q[subterms[N]]}\), donde
\(\lc{q[subterms[N]]}\) es la colección de subtérminos de \(\lc{N}\) definida de
manera inductiva como:

\begin{align*}
  \lc*{q[subterms[x]]} &= \{\lc*{x}\} \\
  \lc*{q[subterms[\x.M]]} &= \lc*{q[subterms[M]]} \cup \{\lc*{\x.M}\} \\
  \lc*{q[subterms[M N]]} &= \lc*{q[subterms[M]]} \cup \lc*{q[subterms[N]]} \cup \{\lc*{M N}\}
\end{align*}

Un subtérmino \(\lc{N}\) de \(\lc{M}\) puede aparecer varias veces en
\(\lc{M}\), cuando dos subtérminos \(\lc{q[subscript[N,1]]}\) y
\(\lc{q[subscript[N,2]]}\) de \(\lc{M}\) no tienen apariciones de átomos en
común, se dice que son \emph{disjuntas}. Cuando \(\lc{N}\) es subtérmino de
\(\lc{M}\) se le llama \emph{activo} si aparece en una aplicación de la forma
\(\lc{N Z}\), de lo contrario, se le llama \emph{pasivo}. \\

La aparición de \(\lc{M}\) en \(\lc{N}\) implica que \(\lc{q[subterm[M,N]]}\) o
que \(\lc{M}\) es el átomo del argumento de una abstracción en \(\lc{N}\). \\

Cuando \(\lc{\x.M}\) es un subtérmino de \(\lc{P}\), se dice que la aparición
\(\lc{M}\) es el \emph{alcance} de la aparición del átomo \(\lc{x}\) que
acompaña a la \(\lambda\). \\

Sea \(\lc{M}\synteq \lc*{\x.x y(\z.y)}\):

\begin{itemize}
\item el término \(\lc*{q[subterm[x y, M]]}\);
\item el átomo \(\lc{z}\) no es subtérmino de \(\lc{M}\) pero si aparece en
  \(\lc{M}\), debido a que \(\lc{z}\) es el argumento de \(\lc*{\z.y}\);
\item el término \(\lc*{y(\z.y)}\) a pesar de parecer ser un subtérmino de
  \(\lc{M}\) no lo es, esto se puede corroborar escribiendo los términos sin el
  abuso de notación: \(\lc*{y(\z.y)} \synteq \lc{y(\z.y)}\) y \(\lc{M} \synteq
  \lc*{\x.x y(\z.y)} \synteq \lc{\x.x y(\z.y)}\), en este caso, la clave está en
  observar la estructura de la aplicación \(\lc*{x y(\z.y)}\).
\item Las apariciones de \(\lc{x}\) y \(\lc*{\z.y}\) en \(\lc{M}\) son
  disjuntas.
\item Los términos \(\lc{x}\) y \(\lc{x y}\) son subtérminos activos de
  \(\lc{M}\), mientras que \(\lc{y}\) y \(\lc*{\z.y}\) son subtérminos pasivos.
\end{itemize}


La aparición de un átomo \(\lc{x}\) en un término \(\lc{P}\) es llamada:

\begin{itemize}
\item \emph{variable ligada} si es un subtérmino de \(\lc{M}\) en una abstracción
  \(\lc{\x.M}\) en \(\lc{P}\)
\item \emph{variable enlazada} si y sólo si es la \(\lc{x}\) que
  acompaña la \(\lambda\) de \(\lc{\x.M}\) en \(\lc{P}\)
\item \emph{variable libre} en otro caso
\end{itemize}

Es importante aclarar la diferencia entre un átomo \(\lc{x}\) como subtérmino de un término
lambda \(\lc{M}\) y una aparición de \(\lc{x}\) en \(\lc{M}\): la aparición hace
referencia a la posición de \(\lc{x}\) en \(\lc{M}\). Por ejemplo, en el término
lambda \(\lc{(\x.x)x}\) la primera aparición del átomo \(\lc{x}\) es una
variable enlazada, la segunda aparición es una variable ligada y la
tercera aparición es una variable libre. \\

Sea \(\lc{M} \synteq \lc*{x(\y.x y)}\):

\begin{itemize}
\item El átomo \(\lc{x}\) aparece como variable libre dos veces en
  \(\lc{M}\).
\item El átomo \(\lc{y}\) aparece como variable ligada en \(\lc{M}\).
\end{itemize}

Un átomo puede aparecer como variable libre y ligada en un mismo término, por
ejemplo \(\lc{y(\y.y)}\). \\

El conjunto de variables libres de un término lambda \(\lc{M}\) se denota
\(\lc{q[fv[M]]}\) y cuando \(\lc{q[fv[M]]}=\emptyset\) se dice que \(\lc{M}\) es
un término \emph{cerrado} o un \emph{combinador}. Por ejemplo, \(\lc*{q[fv[x
  \x.x y z]]} = \left\{ x,\ y,\ z \right\}\); \(\lc*{q[fv[\x y z.y]]} =
\emptyset\) y es un combinador; \(\lc*{q[fv[(\y.x)(\x.y)]]}=\left\{ x,\ y
\right\}\). \\

En ocasiones es importante distinguir los términos lambda cerrados de aquellos
que contienen variables libres, se denota como \(\Lambda^{0}\) al conjunto \(\{\lc{M}
\in \Lambda \mid \lc{M} \text{ es un término cerrado}\}\). La generalización de
esta notación es \(\Lambda^{0}(\lc{q[seq[x]]})=\{M\in\Lambda \mid
\lc{q[fv[M]]}\subseteq \{\lc{q[seq[x]]}\}\}\). \\

Cuando se tiene un término lambda \(\lc{M}\) con \(\lc{q[fv[M]]} \not=
\emptyset\) se le llama \emph{clausura} de \(\lc{M}\) al término lambda
\(\lc{\q[seq[x]].M}\) con \(\lc{q[seq[x]]}=\lc{q[fv[M]]}\). Por ejemplo,
\(\lc{\x y z.x y z}\) es la clausura de \(\lc{\z.x y z}\). \\

Una manera de acortar la notación para repetición de aplicaciones es escribiendo
\(\lc*{q[left-apply[n,F,M]]}\) cuando se aplica \(n\) veces \(\lc{F}\) por la
izquierda

\begin{align*}
  \lc{q[left-apply[n+1,F,M]]} &\synteq \lc{F q[left-apply[n,F,M]]}\\
  \lc{q[left-apply[0,F,M]]}   &\synteq \lc{M}
\end{align*}

y \(\lc*{q[right-apply[n,F,M]]}\) cuando se aplica \(n\) veces \(\lc{M}\) por la
derecha

\begin{align*}
  \lc{q[right-apply[n+1,F,M]]} &\synteq \lc{q[right-apply[n,F,M]] M}\\
  \lc{q[right-apply[0,F,M]]}   &\synteq \lc{F}
\end{align*}

Esta notación es útil para describir familias de términos que siguen un patrón
con la asociación de aplicaciones repetidas, por ejemplo, el término \(\lc{\f
  x.f(f(f(f x)))}\) se escribe \(\lc*{\f x.q[left-apply[4,f,x]]}\). \\

Para cualquier \(\lc{M}\), \(\lc{N}\) y \(\lc{x}\), se define
\(\lc{q[subst[M,x,N]]}\) como el resultado de sustituir cada aparición libre de
\(\lc{x}\) por \(\lc{N}\) en \(\lc{M}\) de acuerdo a las siguientes reglas:

\begin{align*}
  &\lc{q[subst[x,x,N]]} & &\synteq & &\lc{N}; \\
  &\lc{q[subst[a,x,N]]} & &\synteq & &\lc{a} & &\lc{a} \not\synteq \lc{x}; \\
  &\lc{q[subst[P Q,x,N]]} & &\synteq & &\lc{q[subst[P,x,N]] q[subst[Q,x,N]]}; \\
  &\lc{q[subst[\x.P,x,N]]} & &\synteq & &\lc{\x.P}; \\
  &\lc{q[subst[\y.P,x,N]]} & &\synteq & &\lc{\y.P} & &\lc{x}\not\synteq \lc{y},\ \lc{x} \not\in \lc{q[fv[P]]}; \\
  &\lc{q[subst[\y.P,x,N]]} & &\synteq & &\lc{\y.q[subst[P,x,N]]} & &\lc{x}\not\synteq \lc{y},\ \lc{x}\in\lc{q[fv[P]]},\ \lc{y}\not\in \lc{q[fv[N]]}; \\
  &\lc{q[subst[\y.P,x,N]]} & &\synteq & &\lc{\z.q[subst[subst[P,y,z],x,N]]} & &\lc{x}\not\synteq \lc{y},\ \lc{x}\in\lc{q[fv[P]]},\ \lc{y}\in \lc{q[fv[N]]}, \\
  & & & & & & & \lc{z}\not\in \lc{q[fv[N P]]}.
\end{align*}

Los siguientes son ejemplos de sustituciones para cada uno de los casos de la
definición:

\begin{itemize}
\item \(\lc*{q[subst[y,y,\x.x]]}\)
  \begin{itemize}
  \item \(\synteq \lc*{\x.x}\)
  \end{itemize}
\item \(\lc*{q[subst[z,w,x x]]}\)
  \begin{itemize}
  \item \(\synteq \lc*{z}\)
  \end{itemize}
\item \(\lc*{q[subst[y x x, x, y]]}\)
  \begin{itemize}
  \item \(\synteq \lc*{q[subst[y x, x, y]] q[subst[x, x, y]]}\)
  \item \(\synteq \lc*{q[subst[y, x, y]] q[subst[x, x, y]] y}\)
  \item \(\synteq \lc*{y y y}\)
  \end{itemize}
\item \(\lc*{q[subst[\f x.f f x, f, g]]}\)
  \begin{itemize}
  \item \(\synteq \lc*{\f x.f f x}\)
  \end{itemize}
\item \(\lc*{q[subst[\f x.f f x, x, y]]}\)
  \begin{itemize}
  \item \(\synteq \lc*{\f x.f f x}\) ya que \(\lc*{x} \not\in \lc*{q[fv[\x.f f x]]}\)
  \end{itemize}
\item \(\lc*{q[subst[\f.x\x.f f x, x, y]]}\)
  \begin{itemize}
  \item \(\synteq \lc*{\f.q[subst[x\x.f f x, x, y]]}\) ya que
    \(\lc*{x}\in\lc*{q[fv[x\x.f f x]]}\) y \(\lc*{f}\not\in \lc*{q[fv[y]]}\)
  \item \(\synteq \lc*{\f.q[subst[x,x,y]] q[subst[\x.f f x, x, y]]}\)
  \item \(\synteq \lc*{\f.y\x.f f x}\)
  \end{itemize}
\item \(\lc*{q[subst[\f.x\x.f f x, x, f]]}\)
  \begin{itemize}
  \item \(\synteq \lc*{\g.q[subst[subst[x\x.f f x, f, g], x, f]]}\) ya que
    \(x\in \lc*{q[fv[x\x.f f x]]}\), \(f\in \lc*{q[fv[f]]}\) y \(\lc{g}\not\in
    \lc*{q[fv[f (x\x.f f x)]]}\)
  \item \(\synteq \lc*{\g.q[subst[x\x.g g x, x, f]]}\)
  \item \(\synteq \lc*{\g.f\x.g g x}\)
  \end{itemize}
\end{itemize}

En el último ejemplo es importante observar que las apariciones ligadas de
\(\lc{x}\) no se sustituyen. \\

\begin{lema}
Si \(\lc{x} \not\synteq \lc{y}\) y \(\lc{x}\not\in \lc*{q[fv[L]]}\), entonces
\[\lc*{q[subst[subst[M,x,N],y,L]]} \synteq \lc*{q[subst[subst[M,y,L],x,subst[N,y,L]]]}\]
\end{lema}

En contraste a la operación de \emph{sustitución} en donde no se permite
introducir o quitar referencias a variables enlazadas, el \emph{contexto}
\(\lc{q[context[C]]}\) es un término con ``hoyos'', formalmente:\\

\begin{itemize}
\item \(\lc{x}\) es un contexto;
\item \(\lc{q[hole[]]}\) es un contexto;
\item Si \(\lc{q[context[subscript[C,1]]]}\) y
  \(\lc{q[context[subscript[C,2]]]}\) son contextos, entonces
  \(\lc{q[context[subscript[C,1]]] q[context[subscript[C,2]]]}\) y
  \(\lc{\x.q[context[subscript[C,1]]]}\) también lo son.
\end{itemize}

Si \(\lc{q[context[C]]}\) es un contexto y \(\lc{M} \in \Lambda\), entonces
\(\lc{q[fill[C,M]]}\) denota el resultado de reemplazar por \(\lc{M}\) los hoyos
de \(\lc{q[context[C]]}\). Al realizar esto, las variables libres de \(\lc{M}\)
pueden convertirse en variables ligadas de \(\lc{q[fill[C,M]]}\). \\

Por ejemplo, considerando un contexto \(\lc{q[context[C]]} \synteq
\lc*{\x.x(\y.q[hole[]])}\), si \(\lc{M} \synteq \lc*{x y}\), entonces
\(\lc{q[fill[C,M]]} \synteq \lc*{q[fill[\x.x(\y.hole[]), x y]]} \synteq
\lc*{fill[\x.x(\y.q[hole[]]), x y]}\). El ejemplo análogo con la sustitución es
si \(\lc{C} \synteq \lc*{\x.x(\y.w)}\) y \(\lc{M} \synteq \lc*{x y}\), entonces
\(\lc*{q[subst[C,w,M]]} \synteq \lc*{q[subst[\x.x(\y.w),w,x y]]}\) la cual es
sintácticamente equivalente a \(\lc*{\z.z(\y.x y)}\), contrastando ambos
resultados:

\[\lc*{\x.x(\y.x y)} \not\synteq \lc*{\z.z(\y.x y)}\]


\subsection{Teoría \texorpdfstring{\(\boldsymbol{\lambda K \beta}\)}{\lambda K
    \beta}}

Esta subsección está basada principalmente en el capítulo 6 de
\cite{HindleySeldin:LambdaCalculusAndCombinators}. \\

Una \emph{teoría formal} \(\mathcal{T}\) consiste de tres conjuntos:
\emph{fórmulas}, \emph{axiomas} y \emph{reglas de inferencia}. Cada regla
tiene una o mas \emph{premisas} y una \emph{conclusión}. \\

Si \(\Gamma\) es el conjunto de fórmulas, una \emph{deducción} de una fórmula
\(B\) a partir de \(\Gamma\) es un árbol de fórmulas, siendo aquellas que están
en la parte superior de las ramas axiomas o elementos de \(\Gamma\); las
fórmulas intermedias siendo deducidas a partir de las fórmulas inmediatamente
arriba de ellas usando reglas de inferencia; y \(B\) estando en la parte
inferior del árbol. \\

Si y sólo si existe tal deducción, se escribe:
\[\mathcal{T},\Gamma \vdash B\]

Sí y sólo si \(\Gamma\) es el conjunto vacío se escribe:
\[\mathcal{T} \vdash B\]

A continuación se presenta la definición de la teoría \(\boldsymbol{\lambda K
  \beta}\), debido a que esta teoría será la que se describe principalmente en
este trabajo, se acorta el nombre \(\boldsymbol{\lambda K \beta}\) a
\(\boldsymbol{\lambda}\). \\

Las \emph{fórmulas} de \(\boldsymbol{\lambda}\) son ecuaciones de la
forma \(\lc{M}=_{\boldsymbol{\lambda}}\lc{N}\), para tódo término lambda
\(\lc{M}\) y \(\lc{N}\). Los \emph{axiomas} son (\(\alpha\)), (\(\beta\)) y
(\(\rho\)). Las \emph{reglas de inferencia} son (\(\mu\)), (\(\nu\)), (\(\xi\)),
(\(\tau\)) y (\(\sigma\)):

\emph{Axiomas:}
\begin{align*}
  &(\alpha) & & \lc*{\x.M}=_{\boldsymbol{\lambda}}\lc{\y.q[subst[M,x,y]]} & &\text{ si } y \not\in \lc{q[fv[M]]}; \\
  &(\beta)  & & \lc*{(\x.M)N}=_{\boldsymbol{\lambda}}\lc{q[subst[M,x,N]]}; \\
  &(\rho)   & & \lc{M}=_{\boldsymbol{\lambda}}\lc{M}.
\end{align*}

\emph{Reglas de inferencia:}
\begin{align*}
  &(\mu)    & & \infer{\lc*{Z M}=_{\boldsymbol{\lambda}}\lc*{Z N}}{\lc{M}=_{\boldsymbol{\lambda}}\lc{N}}; \\
  &(\nu)    & & \infer{\lc*{M Z}=_{\boldsymbol{\lambda}}\lc*{N Z}}{\lc{M}=_{\boldsymbol{\lambda}}\lc{N}}; \\
  &(\xi)    & & \infer{\lc*{\x.M}=_{\boldsymbol{\lambda}}\lc*{\x.N}}{\lc{M}=_{\boldsymbol{\lambda}}\lc{N}}; \\
  &(\tau)   & & \infer{\lc{M}=_{\boldsymbol{\lambda}}\lc{P}}{\lc{M}=_{\boldsymbol{\lambda}}\lc{N},\ \lc{N}=_{\boldsymbol{\lambda}}\lc{P}}; \\
  &(\sigma) & & \infer{\lc{N}=_{\boldsymbol{\lambda}}\lc{M}}{\lc{M}=_{\boldsymbol{\lambda}}\lc{N}}.
\end{align*}

La \emph{demostrabilidad} en \(\boldsymbol{\lambda}\) de una ecuación
\(\lc{M}=_{\boldsymbol{\lambda}}\lc{N}\) es denotada \(\boldsymbol{\lambda}
\vdash \lc{M}=_{\boldsymbol{\lambda}}\lc{N}\); si se establece que la teoría
formal a la que se hace referencia es \(\boldsymbol{\lambda}\), se puede
escribir simplemente \(\lc{M}=\lc{N}\). \\

Si \(\boldsymbol{\lambda} \vdash \lc{M}=\lc{N}\), entonces \(\lc{M}\) y \(\lc{N}\)
son llamados términos \emph{convertibles}. \\

Al inicio de esta sección, se menciona que el objeto de estudio de la teoría
\(\boldsymbol{\lambda}\) es el conjunto de términos lambda módulo
convertibilidad. La \emph{convertibilidad} es la noción básica de equivalencia
de términos lambda y las ecuaciones de la teoría \(\boldsymbol{\lambda}\)
formalizan esta noción. \\

La relación \(=_{\boldsymbol{\lambda}}\) en las ecuaciones de la teoría, es una
relación de equivalencia y al igual que toda relación de equivalencia es
\emph{reflexiva}, \emph{simétrica} y \emph{transitiva}, en
\(=_{\boldsymbol{\lambda}}\) estas propiedades son descritas en las reglas
\((\rho)\), \((\sigma)\) y \((\tau)\). La \emph{clase de equivalencia} de un
término lambda \(\lc{M}\) con respecto a esta relación de equivalencia es el
conjunto de todos los términos lambda \(\lc{N}\) tal que
\(\lc{M}=_{\boldsymbol{\lambda}}\lc{N}\), denotado:

\[\left[ \lc{M} \right]_{=_{\boldsymbol{\lambda}}} = \left\{ \lc{N} \in \Lambda
    \mid \lc{M}=_{\boldsymbol{\lambda}}\lc{N} \right\}\]

La frase ``\emph{módulo convertibilidad}'' se refiere al conjunto de todas las
clases de equivalencia de \(\Lambda\) considerando la relación de equivalencia
de la teoría formal con la que se esté trabajando. Que este conjunto sea el
objeto de estudio de la teoría \(\boldsymbol{\lambda}\) significa que cada
elemento de \(\Lambda\) módulo convertibilidad (denotado \(\Lambda /
=_{\boldsymbol{\lambda}}\)) es distinto y representa a una clase de
términos lambda considerados en \(\boldsymbol{\lambda}\) como equivalentes. \\

Para demostrar que \(\boldsymbol{\lambda} \vdash \lc{M}=\lc{N}\) se puede
escribir el árbol de deducción correspondiente. Por ejemplo:

\[\boldsymbol{\lambda} \vdash \lc*{(\f.x((\y.y f) \z.z))w} = \lc*{x w}\]

\begin{figure}[h!]
  \centering
  \begin{tikzpicture}[
    equat/.style={rectangle, draw},
    grow=up,
    edge from parent/.style={draw,latex-},
    level 1/.style={sibling distance=20em, level distance=5em},
    level 2/.style={sibling distance=40em},
    level 3/.style={sibling distance=20em},
    level 4/.style={sibling distance=10em}
    ]
    \node [equat] (foo1) {\(\lc*{(\f.x((\y.y f) \z.z))w} = \lc*{x w}\)}
    child {
      node [equat] (foo3) {\(\lc*{(\f.x f)w} = \lc*{x w}\)}
    }
    child {
      node [equat] (foo5) {\(\lc*{(\f.x((\y.(y f)) \z.z))w}=\lc*{(\f.x f)w}\)}
      child {
        node [equat] (foo7) {\(\lc*{\f.x((\y.y f)\z.z)}=\lc*{\f.x f}\)}
        child {
          node [equat] (foo9) {\(\lc*{x((\y.y f)\z.z)}=\lc*{x f}\)}
          child {
            node [equat] (foo11) {\(\lc*{(\y.y f)\z.z} = f\)}
            child {
              node [equat] (foo13) {\(\lc*{(\z.z)f} = \lc*{f}\)}
            }
            child {
              node [equat] (foo14) {\(\lc*{(\y.y f)\z.z} = \lc*{(\z.z)f}\)}
            }
            edge from parent [] node [right] {\((\mu)\)}
          }
          edge from parent [] node [right] {\((\xi)\)}
        }
        edge from parent [] node [right] {\((\nu)\)}
      }
    };
    \node [above=0em of foo13] (bar1) {\((\beta)\)};
    \node [above=0em of foo14] (bar2) {\((\beta)\)};
    \node [above=0em of foo11] (bar3) {\((\tau)\)};
    \node [above=0em of foo1] (bar4) {\((\tau)\)};
    \node [above=0em of foo3] (bar5) {\((\beta)\)};
  \end{tikzpicture}
\end{figure}

Tres términos lambda de suma importancia son:

\begin{itemize}
\item \(\lc{q[bold[I]]} \synteq \lc*{\x.x}\);
\item \(\lc{q[bold[K]]} \synteq \lc*{\x y.x}\);
\item \(\lc{q[bold[S]]} \synteq \lc*{\x y z.x z(y z)}\).
\end{itemize}

\begin{cor}
  Para todo término \(\lc{M},\ \lc{N},\ \lc{L} \in \Lambda\)
  \begin{itemize}
  \item[(i)] \(\lc*{q[bold[I]] M} =_{\boldsymbol{\lambda}} M\)
  \item[(ii)] \(\lc*{q[bold[K]] M N} =_{\boldsymbol{\lambda}} M\)
  \item[(iii)] \(\lc*{q[bold[S]] M N L} =_{\boldsymbol{\lambda}} \lc*{M L(N L)}\)
  \end{itemize}
\end{cor}

Estos tres combinadores generan en la teoría \(\boldsymbol{\lambda}\) al
conjunto \(\Lambda^{0}\) utilizando únicamente aplicación de términos lambda.
Debido a que \(\lc*{q[bold[S K K]]}=_{\boldsymbol{\lambda}} \lc*{q[bold[I]]}\),
sólo es necesario considerar a \(\lc{q[bold[K]]}\) y a \(\lc{q[bold[S]]}\) para
generar a \(\Lambda^{0}\). \\

\subsubsection{Otras teorías}

En el artículo \cite{Church:LambdaConversion}, Alonzo Church presenta una
definición del cálculo lambda con un conjunto restringido de términos lambda. A
la teoría que considera a este conjunto restringido de términos lambda (denotado
\(\Lambda_{I}\)) y los axiomas  y reglas de inferencia de la teoría
\(\boldsymbol{\lambda}\) cambiando \(\Lambda\) por \(\Lambda_{I}\) se le conoce
como teoría \(\boldsymbol{\lambda I \beta}\) (o el cálculo \(\lambda I\)). \\

El conjunto \(\Lambda_{I}\) se define de manera inductiva como
\begin{itemize}
\item \(\lc{x} \in \Lambda_{I}\);
\item \(\lc{M}\in \Lambda_{I},\ \lc{x} \in \lc{q[fv[M]]} \implies \lc{\x.M} \in
  \Lambda_{I}\);
\item \(\lc{M},\ \lc{N} \in \Lambda_{I} \implies \lc{M N} \in \Lambda_{I}\).
\end{itemize}

La diferencia fundamental entre las teorías \(\boldsymbol{\lambda K \beta}\) y
\(\boldsymbol{\lambda I \beta}\) es el término lambda \(\lc{q[bold[K]]}\), ya que
\(\lc{q[bold[K]]} \in \Lambda \setminus \Lambda_{I}\) pero \(\lc{q[bold[K]]}
\not\in \Lambda_{I}\). Esto es debido a que el subtérmino \(\lc{\y.x}\) en
\(\lc{q[bold[K]]}\synteq \lc{\x y.x}\) no puede existir en \(\Lambda_{I}\)
debido a que \(\lc{y} \not\in \lc{q[fv[x]]}\). \\




\subsubsection{Extensionalidad}

Equivalencia de procedimientos como cajas negras y no como algoritmos.

\subsubsection{Equivalencia de teorías}

Comparación entre teorías formales, énfasis en \(\eta\) contra \(\zeta\) contra \(ext\).

\subsubsection{Lemas y Corolarios sobre términos lambda en \(\lambda K \beta\)}

Resultados sobre términos lambda en la teoría \(\boldsymbol{\lambda K \beta}\).

\subsection{Teoría de reducción}

\subsubsection{Contracciones}

Transformaciones de términos con un paso.

\subsubsection{Reducciones}

Reducciones basadas en contracciones

\subsubsection{Convertibilidad}

Ecuaciones desde una perspectiva de reducción

\subsubsection{Teorema de Church-Rosser}

Confluencia en términos lambda.

\subsection{Böhm trees}

Estructura con perspectiva conjuntivista, no se formaliza el modelo pero se
describe.

%%% Local Variables: 
%%% coding: utf-8 
%%% mode: latex
%%% TeX-master: "main"
%%% End: