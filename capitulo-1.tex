El cálculo lambda es un sistema formal originalmente creado por Alonzo Church en 1932 con la finalidad de expresar, manipular y estudiar funciones para el desarrollo de los fundamentos de la lógica y las matemáticas \cite[p.~248]{Church:FoundationsLogic}. A lo largo de la historia, este sistema se ha adaptado para el estudio de los fundamentos de la computación y como sustento teórico para el desarrollo de lenguajes de programación.

Tres características fundamentales del cálculo lambda son

\begin{itemize}
\item El lenguaje e interpretación de las expresiones
\item La manipulación y transformación de expresiones
\item Las nociones de equivalencia entre expresiones
\end{itemize}

En este capítulo se describen estas tres características del cálculo lambda de manera informal, enfatizando las diferencias sintácticas, conceptuales y operacionales entre este sistema, la matemática clásica y la lógica de primer orden.

El contenido de este capítulo está basado en los primeros dos capítulos del libro \emph{The Lambda Calculus, Its Syntax and Semantics} por H.P. Barendregt \cite{Barendregt:Bible}; los capítulos 1 y 3 del libro \emph{Lambda Calculus and Combinators, an Introduction} por J.R. Hindley y J.P. Seldin \cite{HindleySeldin:LambdaCalculusAndCombinators}; y la monografía titulada \emph{The Calculi of Lambda-Conversion} por Alonzo Church \cite{Church:LambdaConversion}.

En el estudio del cálculo lambda existen dos \emph{lenguajes}

\begin{itemize}
\item El lenguaje de las expresiones del sistema
\item El \emph{metalenguaje} que describe al cálculo lambda
\end{itemize}

El lenguaje de las expresiones es un \emph{lenguaje formal} que especifica las secuencias de símbolos que representan expresiones válidas del cálculo lambda, se relaciona con las clases de objetos del sistema que son válidos manipular, comparar y representar. Por otro lado, el metalenguaje es un lenguaje informal que permite describir \emph{cómo} es que estas expresiones son manipuladas y analizadas, así como los mecanismos para representar conceptos y objetos matemáticos como expresiones.

\section{Expresiones}
\label{sec:expresiones}

Existen tres clases de expresiones en el cálculo lambda: los \emph{átomos}, las \emph{abstracciones} y las \emph{aplicaciones}.

\subsection{Átomos}
\label{sec:atomos}

Las expresiones más simples son los \emph{átomos}, estos son objetos sintácticos usualmente representados con un símbolo como \( x \), \( y \) o \( z \). Los átomos son la representación simbólica de las variables \cite[p.~577]{Barendregt:Bible}.

Cuando se tiene una expresión que se conforma de varias \( x \) se refiere al símbolo como ``el átomo \( x \)'', sin embargo es posible tener diferentes variables representadas con el mismo símbolo en la expresión y para referirse a una de ellas en particular se debe especificar en que parte de la expresión se encuentra la variable \( x \) a la que se hace referencia.

Al igual que en la matemática clásica y en la lógica de primer orden, las variables más relevantes son las que se \emph{cuantifican}, por ejemplo en el estudio de funciones, la \( x \) en \( f(x) = M \) y en el estudio de enunciados lógicos, la \( y \) en \( \forall y\ M \) o \( \exists y\ M \).

En matemáticas y en computación es usual \emph{nombrar} valores, por ejemplo, declarar que \( x = 8 \) y expresar a \( x \) en diferentes contextos que no necesariamente son expresiones lógicas y funciones. En el cálculo lambda, los nombres son parte del metalenguaje y no del lenguaje de las expresiones.

\subsection{Abstracciones}
\label{sec:abstracciones}

Las abstracciones son expresiones con \emph{estructura}, es decir, se conforman de \emph{partes} identificables. Las expresiones que son abstracciones representan la generalización de una expresión y son usualmente asociadas al concepto de \emph{función}.

La definición de función en la matemática clásica es el de una relación entre un conjunto de entradas, llamado \emph{dominio} y un conjunto de salidas, llamado \emph{codominio}. Esta relación tiene además la propiedad de que cada elemento del dominio se asocia exactamente con un elemento del codominio, formalmente, sean \( A \) y \( B \) dos conjuntos, una función \( f \) con dominio \( A \) y codominio \( B \) es un subconjunto del producto cartesiano \( A \times B \), tal que para toda \( a \in A \), existe \( b \in B \) tal que \( (a,\ b) \in f \) y si \( (a,\ b^{\prime}) \in f \) con \( b^{\prime} \in B \), entonces \( b=b^{\prime} \).

Las funciones tienen varias maneras de ser representadas. En la definición anterior la representación es la de pares ordenados, en donde la primer componente del par es un elemento en el dominio y la segunda es un elemento en el codominio. Dependiendo del uso que se le dá a las funciones, puede ser conveniente representarlas simbólicamente con expresiones, gráficamente con dibujos, numéricamente con tablas o incluso verbalmente con palabras.

Las abstracciones en el cálculo lambda son representadas simbólicamente con un átomo y con otra expresión, se escriben de la forma \( (λx.M) \) donde \( x \) es algún átomo llamado variable enlazada o argumento y \( M \) es alguna expresión ya sea otra abstracción, una aplicación o un átomo a la cual llamamos cuerpo de la abstracción. Un ejemplo de abstracción es \( (λy.y) \) en donde el argumento y cuerpo de la abstracción son el átomo \( y \).

Además de la semejanza sintáctica con las funciones y las expresiones lógicas cuantificadas, las abstracciones proveen el mecanismo para asociarle un valor a una variable. Sin embargo, tanto las expresiones de funciones como las fórmulas lógicas están basadas en conjuntos y en operaciones sobre conjuntos: \( f(x)=M \) asocia a \( x \) un valor en el dominio de \( f \) en \( M \) y \( \exists x\ M \) asocia a \( x \) valores en el dominio del discurso en el enunciado \( M \). En contraste con el cálculo lambda, por definición no existen conjuntos, números, valores de verdad, ni cuantificadores lógicos en el lenguaje.

Es posible utilizar la definición de función para \emph{describir} operaciones y transformaciones de expresiones en el cálculo lambda, o utilizar lógica de primer orden para aseverar verdades en el sistema, o utilizar aritmética para cuantificar propiedades de las expresiones del cálculo lambda, sin embargo estos objetos matemáticos no están incrustados en el lenguaje de las expresiones y conforman lo que es el \emph{metalenguaje}.


\subsection{Aplicaciones}
\label{sec:aplicaciones}

Las aplicaciones, al igual que las abstracciones, son expresiones con estructura. Se conforman por otras dos expresiones y se escriben de la forma \( (M\, N) \) donde \( M \) y \( N \) son cualesquiera átomos, abstracciones o aplicaciones. Este tipo de expresiones son de cierta manera complementarias a las abstracciones ya que representan un potencial acto de concretar una expresión.

El concepto relacionado con las aplicaciones en la matemática clásica es el de \emph{aplicación de funciones}, sin embargo, en el cálculo lambda se hace una distinción entre la expresión sintáctica de una aplicación y el acto de ``evaluar'' una aplicación.

En el estudio de funciones, la aplicación de una función \( f \) en \( x \) se denota \( f(x) \) y es considerada igual al resultado de obtener el elemento del codominio de \( f \) a partir del valor de \( x \). Por ejemplo, considerando la función \( f(x)=x^{2} \), la expresión sintáctica de la aplicación de esta función a 8 es \( f(8) \), mientras que el valor de la evaluación de esta aplicación es 64. La notación de una abstracción del cálculo lambda es similar a la notación de aplicación de funciones, pero con el paréntesis abierto antes del nombre de la función, es decir, \( (f\, x) \) en lugar de \( f(x) \).

En el cálculo lambda, el concepto relacionado con la evaluación de funciones es el de \emph{reducción} de expresiones. En particular cuando se tiene la aplicación de una abstracción \( (λx.M) \) en algúna expresión \( N \), se dice que \( ((λx.M) N) \) se \emph{reduce} a una expresión \( Z \) la cual es similar a \( M \) solo que con \( x \) cambiada por \( N \). En la evaluación de funciones, el procedimiento es parecido, por ejemplo \( f(3) \) donde \( f = 2x^{2}+x-8 \), se evalúa sustituyendo las \( x \) de \( 2x^{2}+x-8 \) por 3, obteniendo así la expresión aritmética \( 2(3)^{2}+3-8 \), la cual puede ser operada para obtener el resultado 13.

Las abstracciones y aplicaciones del cálculo lambda son en algunos aspectos más restrictivos que las funciones y la aplicación de funciones. La función considera dos conjuntos cualquiera y no importa que propiedades tengan sus elementos o que operaciones se pueden realizar sobre ellos. Por otro lado, las abstracciones y aplicaciones sólo pueden ser descritas a partir de otras expresiones del cálculo lambda.

\subsection{Extensiones}
\label{sec:extensiones}

Cuando se desea representar en el cálculo lambda alguna función, se deben \emph{codificar} como expresiones del lenguaje los elementos del dominio y el codominio de la función, así como las operaciones entre elementos de ambos conjuntos. Por ejemplo, para representar la función \( f \colon \mathbb{N} \to \mathbb{N} \) dada por \( f(x)=x^{2} \) primero se deben codificar los números naturales con expresiones del cálculo lambda, esta codificación debe ser acompañada de la codificación de las operaciones aritméticas elementales como la suma y resta así como de los predicados sobre números naturales como discriminar entre el mayor de dos números o si un número es cero; posteriormente se debe expresar la operación de exponenciación de cualquier número natural como base y el número \( 2 \) como exponente. La codificación es similar a la implementación de algoritmos y estructuras de datos en lenguajes de programación.

El hecho de tener un lenguaje tan reducido y minimalista para las expresiones del cálculo lambda nos obliga a entender con detalle y precisión todos los procesos de manipulación y transformación de expresiones y siendo que todo lo que se representa con el cálculo lambda debe ser codificado como expresiones, los objetos representados pueden ser entendidos de la misma manera.

\subsection{Ejemplos}
\label{sec:ejemplos}

Con solo átomos, aplicaciones y abstracciones se pueden formular expresiones complejas. A continuación se presentan seis ejemplos de expresiones del cálculo lambda y se describen diferentes maneras en las cuales estas se pueden componer para formar otras expresiones más complejas.

\begin{exmp}
  Algunas expresiones del cálculo lambda
  \label{exmp:expresiones}
  \begin{subequations}
    \begin{gather}
      \label{eq:expresiones:a} \tag{a}
      x \\
      \label{eq:expresiones:b} \tag{b}
      (λx.x) \\
      \label{eq:expresiones:c} \tag{c}
      (y(λx.x)) \\
      \label{eq:expresiones:d} \tag{d}
      ((λy.(y(λx.x)))(λw.w)) \\
      \label{eq:expresiones:e} \tag{e}
      (λx.(x x)) \\
      \label{eq:expresiones:f} \tag{f}
      (λf.(λx.(f(f x))))
    \end{gather}
  \end{subequations}
\end{exmp}


Los átomos por si solos son expresiones válidas, en el inciso \eqref{eq:expresiones:a} aparece el átomo \( x \), como tal no tiene mucha utilidad, no podemos decir que toma valores en algún conjunto o que representa algún valor en particular como falso o verdadero, es tan sólo un símbolo. Al ser parte de otra expresión, un átomo puede tener más relevancia, en el inciso \eqref{eq:expresiones:b} el átomo \( x \) es el cuerpo de la abstracción \( (λx.x) \) y ahora tiene el potencial de ser cambiado por cualquier otra expresión debido a que también es el argumento.

En el inciso \eqref{eq:expresiones:c} se tiene la aplicación del átomo \( y \) en la abstracción del inciso \eqref{eq:expresiones:b}. A pesar de ser contraintuitivo, las expresiones de aplicación se componen de dos expresiones cualesquiera, por lo tanto, a pesar de estar asociada conceptualmente con la aplicación de funciones, la expresión \( (y (λx.x)) \) es válida. La expresión del inciso \eqref{eq:expresiones:d} contiene la expresión anterior en una abstracción en la primer parte de la aplicación y nos permite observar dos ideas importantes: primero, las abstracciones pueden ser aplicadas a abstracciones; segundo, al reducir la aplicación de \( (λy.(y(λx.x))) \) a \( (λw.w) \), el átomo \( y \) es cambiado por la expresión \( (λw.w) \), el resultado puede ser reducido nuevamente para obtener la expresión \( (λx.x) \).

\begin{exmp}
  Procedimiento de reducir la aplicación de \( (λy.(y (λx.x))) \) en \( (λw.w) \)
  \label{exmp:aplicacion}
  \begin{align*}
    \text{1. } & ((λy.(y (λx.x)))(λw.w)) & \text{expresión del inciso \eqref{eq:expresiones:d}} \\
    \text{2. } & ((λw.w)(λx.x)) & \text{al aplicar \( (λy.(y (λx.x))) \) a \( (λw.w) \)} \\
    \text{3. } & (λx.x) & \text{al aplicar \( (λw.w) \) a \( (λx.x) \)}
  \end{align*}
\end{exmp}

En el inciso \eqref{eq:expresiones:e} se presenta una abstracción cuyo cuerpo es la aplicación de su argumento sobre sí mismo. Lo interesante de esta expresión es que es que encapsula la idea de replicar cualquier expresión a la que sea aplicada. Por ejemplo, si aplicamos \( (λx.(x\, x)) \) al átomo \( y \) y se realiza el procedimiento de reducción como en el ejemplo \ref{exmp:aplicacion}, se obtiene \( (y\, y) \) y en general al realizar la reducción de \( ((λx.(x\, x))M) \) donde \( M \) es cualquier expresión, se obtiene \( (M\, M) \). Con esta expresión se puede formular una expresión auto-replicante en el cálculo lambda:

\begin{exmp}
  Procedimiento de reducir la aplicación de \( (λx.(x\, x)) \) en \( (λx.(x\, x)) \)
  \label{exmp:aplicacion2}
  \begin{align*}
    \text{1. } & ((λx.(x\, x))(λx.(x\, x))) & \text{expresión del inciso \eqref{eq:expresiones:e} aplicada a sí misma} \\
    \intertext{En \( (x\, x) \) de la expresión izquierda se cambia cada \( x \) por \( (λx.(x\, x)) \)}
    \text{2. } & ((λx.(x\, x))(λx.(x\, x))) & \text{resultado de la reducción.}
  \end{align*}
\end{exmp}

A este tipo de expresiones se les llaman ``quines'' \cite[pp.~431--437]{Hofstadter:GEB} término originalmente asociado a una paradoja sobre sistemas lógicos \cite{Quine:Paradox}. En la actualidad, el término ``quine'' hace referencia a un programa cuya \emph{salida} es el programa mismo.

En el inciso \eqref{eq:expresiones:f} se tiene una abstracción cuyo cuerpo es otra abstracción. El concepto interesante que ilustra esta expresión es el de representación de abstracciones de varias variables. Al reducir la aplicación de \( (λf.(λx.(f(f\, x)))) \) en una expresión cualquiera \( M \), se obtiene \( (λx.(M(M\, x))) \). Si posteriormente se reduce la aplicación de este resultado a una expresión cualquiera \( N \) se obtiene \( (M(M\, N)) \). El resultado final es similar al resultado que se obtendría al evaluar en \( M \) y \( N \) una función \( g(f,x) = f(f(x)) \), es decir, \( g(M,N) = M(M(N)) \).

Una manera de codificar funciones de varias variables como abstracciones del cálculo lambda es codificar a \emph{tuplas} o \emph{secuencias} y poder hacer referencia a sus elementos de manera individual, sin embargo, representar secuencias es un procedimiento más complejo que se aborda en la sección \ref{sec:estructura-listas}.

\section{Operaciones}
\label{sec:operaciones}

En el cálculo lambda se pueden realizar algunas operaciones para transformar expresiones, estas operaciones son parte del metalenguaje y consisten de una serie de cambios mecánicos a la estructura de las expresiones de acuerdo a un criterio particular.

En la sección \ref{sec:expresiones} se describió de manera tangencial el acto de \emph{reducir} una aplicación basándonos en la noción de \emph{cambiar} una expresión por otra, en esta sección se describen operaciones basadas en esta misma noción.

\subsection{Sustitución}
\label{sec:op-sustitucion}

La \emph{sustitución} es la operación que nos permite transformar una expresión cualquiera \( M \) cambiando las apariciones de un átomo \( x \) por alguna otra expresión \( M \), este procedimiento se denota

\[ \subst{M}{x}{N} \]

En muchos casos la operación de sustitución se puede realizar de fácilmente:

\begin{exmp}
  Sustituciones sencillas
  \label{exmp:sustituciones}
  \begin{align}
    \label{eq:sustituciones:a} \tag{a}
    \subst{x}{x}{y} & = y \\
    \label{eq:sustituciones:b} \tag{b}
    \subst{(x(x(λy.y)))}{x}{z} & = (z(z(λy.y))) \\
    \label{eq:sustituciones:c} \tag{c}
    \subst{\subst{(((w\, x)y)z)}{x}{a}}{y}{b} & = (((w\, a)b)z) \\
    \label{eq:sustituciones:d} \tag{d}
    \subst{(x\, x)}{x}{(λw.w)} & = ((λw.w)(λw.w))
  \end{align}
\end{exmp}

Existen algunos detalles sutiles de la sustitución que se deben tomar en cuenta para evitar obtener expresiones erróneas, en particular cuando se sustituye en expresiones que contienen abstracciones. Para ilustrar estos casos especiales, consideremos la abstracción lambda análoga a una función constante \( (λx.y) \), en donde reducir la aplicación de ésta en cualquier otra expresión, resulta siempre en el átomo \( y \). Si se realiza la sustitución \( \subst{(λx.y)}{y}{z} \) se obtiene la expresión \( (λx.z) \) la cual también es análoga a una función constante pero con el átomo \( z \). Si no se tiene cuidado, sustituir un átomo por otro en esta abstracción puede resultar en una expresión con diferente \emph{interpretación}.

\begin{exmp}
  Caso patológico de la sustitución ingenua
  \label{exmp:sustitucion3}

  \[ \subst{(λx.y)}{y}{x} \]

  Se puede pensar que el resultado es \( (λx.x) \) la cuál es análoga a la función identidad, sin embargo, la sustitución no permite cambiar las expresiones de esta manera.
\end{exmp}

Para entender la operación de sustitución se tiene que pensar que lo que le da sentido a una variable \( x \) es una \( λ x \). Consideremos la expresión

\[ (λx.(λy.((x\, y)z))) \]

el átomo \( x \) que aparece en el cuerpo de la expresión se dice ser una variable \emph{ligada} a la \( λ x \), la cual se puede pensar como una especie de ``referencia'' a la expresión a la que la abstracción es aplicada, esto limita a la operación de sustitución a no \emph{romper} la referencia de una variable ligada. De igual manera, el átomo \( y \) es una variable ligada a la \( λ y \) y debe mantener su referencia bajo la operación de sustitución. Sin embargo, el átomo \( z \) es lo que se llama variable \emph{libre}: No está en el \emph{alcance} de alguna \( λ z \) y puede ser libremente sustituida por alguna otra expresión.

En el ejemplo \ref{exmp:sustitucion3} se pretende sustituir la variable libre \( y \) por una expresión \( x \), lo cual no debería presentar problemas, sin embargo, una sustitución tal cual de \( y \) por \( x \) \emph{introduciría} una referencia a la \( λ x \) de la expresión, la cuál no existía previamente. Con esto se identifica que la operación de sustitución \( \subst{M}{x}{N} \) no debe introducir o eliminar referencias a alguna \( λ \) en \( M \).

\subsection{Cambio de variable ligada}
\label{sec:op-cambio-var-ligada}

Para resolver el problema presentado en el ejemplo \ref{exmp:sustitucion3} se debe considerar otra operación llamada \emph{cambio de variable ligada}. Se parte de la observación que en una expresión del cálculo lambda, las referencias entre \( λ x \) y las variables \( x \) son más importantes que el símbolo con el que se representa el átomo. En las expresiones simbólicas de funciones sucede lo mismo, al expresar \( f(x)=x^{2} \) y \( f(y)=y^{2} \) hacemos referencia a la misma regla de correspondencia y por lo tanto a la misma función (sin considerar el dominio y el codominio de \( f \)). En el cálculo lambda, cambiar el símbolo que representa el átomo \( x \) en la expresión \( (λx.y) \) por otro símbolo no utilizado como \( z \) nos permite realizar la sustitución sin problemas.

\begin{exmp}
  Procedimiento de sustitución para el ejemplo \ref{exmp:sustitucion3}
  \label{exmp:sustitucion4}
  \begin{align*}
    \text{1. } & \subst{(λx.y)}{y}{x} & \\
    \text{2. } & \subst{(λz.y)}{y}{x} & \text{después de realizar un cambio de variable ligada} \\
    \text{3. } & (λz.x) & \text{resultado del procedimiento de sustitución}
  \end{align*}
\end{exmp}

Cuando se realiza un cambio de variable ligada sobre una abstracción \( (λx.M) \) se cambia tanto el átomo \( x \) acompañado por la \( λ \), llamada variable \emph{enlazada} como todas las apariciones del átomo en el cuerpo de la abstracción, también llamado \emph{alcance de} \( λ x \) a menos que en \( M \) se encuentre una expresión de la forma \( (λx.N) \), ya que las \( x \) en \( N \) hacen referencia a la \( λx \) de \( (λx.N) \) no de \( (λx.M) \).

En el ejemplo \ref{exmp:sustitucion4} el cambio de variable ligada únicamente cambió la variable enlazada, en otras expresiones el cambio de variable ligada puede realizarse múltiples veces para transformar varias abstracciones.

\begin{exmp}
  Múltiples cambios de variable ligada
  \label{exmp:variableligada}
  \begin{align*}
    \text{1. } & (λf.(λx.(f(f(f\, x))))) & \\
    \text{2. } & (λg.(λx.(g(g(g\, x))))) & \text{Cambiando \( f \) por \( g \)} \\
    \text{3. } & (λg.(λy.(g(g(g\, y))))) & \text{Cambiando \( x \) por \( y \)}
  \end{align*}
\end{exmp}

El cambio de variable ligada en una abstracción \( (λx.M) \) de \( x \) a \( y \) resulta en la abstracción

\[ (λy.\subst{M}{x}{y}) \]

La definición de la operación de sustitución es recursiva y hace uso de la operación de cambio de variable ligada, considerando a \( x \), \( y \), \( z \) como átomos diferentes y \( M \), \( N \) y \( P \) como expresiones cualquiera:

\begin{itemize}
\item \( \subst{x}{x}{M} \) resulta en \( M \);
\item \( \subst{y}{x}{M} \) resulta en \( y \);
\item \( \subst{(M\, N)}{x}{P} \) resulta en \( (\subst{M}{x}{P} \subst{N}{x}{P}) \);
\item \( \subst{(λx.M)}{x}{N} \) resulta en \( (λx.M) \) debido a que las referencias a \( x \) no deben eliminarse;
\item \( \subst{(λy.M)}{x}{N} \) resulta en:
  \begin{itemize}
  \item \( (λy.M) \) cuando \( x \) no es una variable libre en \( M \),
  \item \( (λy.\subst{M}{x}{N}) \) cuando \( x \) es una variable libre en \( M \) pero \( y \) no es una variable libre en \( N \) debido a que esto introduciría una referencia a \( λ y \),
  \item \( (λz.\subst{\subst{M}{y}{z}}{x}{N}) \) cuando \( x \) es una variable libre en \( M \) y \( y \) es una variable libre en \( N \).
  \end{itemize}
\end{itemize}

\subsection{Reducción de aplicaciones}
\label{sec:op-reduccion}

La operación de \emph{reducción de aplicaciones} es el mecanismo mediante el cual se puede ``concretar'' una abstracción haciendo uso de otra expresión como valor de la variable enlazada. De la misma manera en como se efectúa la evaluación de funciones en la matemática clásica, el concretar una función consiste en sustituir todas las apariciones del argumento por el valor en el que la función es aplicada.

La definición de la reducción de la aplicación de \( (λx.M) \) en una expresión cualquiera \( N \) es

\[ \subst{M}{x}{N} \]

A continuación se presentan ejemplos de reducciones con los pasos de la transformación

\begin{exmp}
  Procedimiento de reducir la aplicación de \( (λx.x) \) en \( y \)
  \label{exmp:aplicacion6}
  \begin{align*}
    \text{1. } & ((λx.x) y) \\
    \text{2. } & \subst{x}{x}{y} \\
    \text{3. } & y
  \end{align*}
\end{exmp}

\begin{exmp}
  Procedimiento de reducir la aplicación de \( (λw.w) \) en \( x \) dentro de otra expresión
  \label{exmp:aplicacion7}
  \begin{align*}
    \text{1. } & (λx.((λw.w)x)) \\
    \text{2. } & (λx.\subst{w}{w}{x}) \\
    \text{3. } & (λx.x)
  \end{align*}
\end{exmp}

\begin{exmp}
  Procedimiento de múltiples reducciones
   \label{exmp:aplicacion8}
  \begin{align*}
    \text{1. } & (((λf.(λx.(f(f(f\, x))))) g) y) \\
    \text{2. } & ((λx.\subst{(f(f(f\, x)))}{f}{g}) y) \\
    \text{3. } & ((λx.(g(g(g\, x)))) y) \\
    \text{4. } & \subst{(g(g(g\, x)))}{x}{y} \\
    \text{5. } & (g(g(g\, y)))
  \end{align*}
\end{exmp}

El cálculo lambda es un sistema maleable y se permite definir operaciones arbitrarias sobre expresiones para estudiar como el sistema se comporta en diferentes contextos, por ejemplo, se puede considerar una operación similar a la sustitución que permite introducir referencias a una o más \( λ \) en una expresión, sin embargo, el presente trabajo está constituido para entender plenamente las ideas centrales del cálculo lambda haciendo solamente uso de las operaciones de \emph{sustitución}, \emph{cambio de variable ligada} y \emph{aplicación de abstracciones}.

\section{Equivalencias}
\label{sec:equivalencias}

El cálculo lambda se considera formalmente como una \emph{teoría ecuacional}, esto significa que los axiomas del sistema formal son ecuaciones que relacionan expresiones del lenguaje. Esto hace que el concepto de \emph{equivalencia} de expresiones sea de suma importancia.

Es tan relevante la formalización de las nociones de equivalencia que considerar alguna equivalencia entre dos expresiones que se escriben diferente puede cambiar por completo el sistema formal que se estudia. En el desarrollo histórico del cálculo lambda, el estudio de los criterios que permiten establecer que dos expresiones son equivalentes ha dado pie a una gran diversidad de variantes de la teoría original; es por ello que en la literatura se suele hablar de \emph{los cálculos lambda} y no únicamente de un cálculo lambda.

Como se aborda en la sección \ref{sec:operaciones}, con la operación de sustitución se puede transformar expresiones del cálculo lambda y definir otras operaciones como el cambio de variable ligada y la reducción de aplicaciones. Usualmente, las transformaciones de expresiones se pueden asociar a nociones de equivalencia. En terminología del cálculo lambda, las nociones de equivalencia entre expresiones son asociadas a la propiedad de \emph{convertibilidad}, la cual significa que si dos expresiones \( M \) y \( N \) son equivalentes en el sistema, es posible transformar \( M \) a \( N \) y viceversa por medio de un número finito de operaciones.

En esta sección se describen algunos criterios de equivalencia entre expresiones del cálculo lambda y las maneras en las que las equivalencias se relacionan entre sí.

\subsection{Equivalencia sintáctica}
\label{sec:equivalencia-sintactica}

La \emph{equivalencia sintáctica} es una relación binaria entre expresiones que no está asociada a una transformación. Se considera como una equivalencia trivial, ya que asevera la igualdad entre dos expresiones que son escritas exactamente igual, símbolo por símbolo a excepción de abusos de notación. Por ejemplo, la expresión \( \sin^{2}(x) \) es un abuso de notación de \( \left( \sin(x) \right)^{2} \) y ambas se consideran exactamente iguales. En el cálculo lambda, la equivalencia sintáctica es denotada como

\[ M \synteq N \]

cuando \( M \) es sintácticamente la misma expresión que \( N \).

Todos los cálculos lambda, al igual que la mayoría de los sistemas formales, comprenden la noción de equivalencia sintáctica. Sin embargo las equivalencias más interesantes son las que involucran transformaciones entre expresiones.

\subsection{\( α \)-convertibilidad}
\label{sec:alfa-convertibilidad}

La operación de cambio de variable ligada se relaciona con una equivalencia estructural entre dos expresiones. Cuando se realiza esta operación no se modifica la estructura de la expresión, únicamente se modifica el símbolo usado para representar un átomo.

Considerando la expresión análoga a la función identidad \( (λx.x) \) se observa que tiene la misma estructura que la abstracción \( (λy.y) \) y que \( (λz.z) \), estas tres representan el mismo concepto. De igual manera otras expresiones como \( ((x\, y)z) \) o \( (λw.x) \) son estructuralmente equivalentes a \( ((a\, b)c) \) y \( (λf.h) \) respectivamente. A pesar de que no se escriben sintácticamente igual, la correspondencia que hay entre las posiciones de los átomos en una y otra expresión nos permite considerarlas como equivalentes. Sin embargo, la operación de cambio de variable ligada no considera cambios de nombres a átomos que sean variables libres.

Esta relación de equivalencia es llamada \( α \)-convertibilidad y se denota como

\[ M \convertible{α} N \]

para dos expresiones del cálculo lambda \( M \) y \( N \) en donde a partir de un número finito de cambios de variables ligadas en \( M \) o parte de \( M \) y en \( N \) o parte de \( N \) se puedan obtener expresiones sintácticamente equivalentes.

\subsubsection{Índices de De Bruijn}

Una técnica utilizada por algoritmos que verifican si dos expresiones \( M \) y \( N \) son \( α \)-convertibles es la de \emph{índices de De Bruijn}, esta transformación cambia la aparición de átomos por números naturales que representan la ``distancia'' de los átomos a las \( λ \) que hacen referencia.

\begin{exmp}[índices de De Bruijn]
  \label{exmp:debrujn}
  \[ (λz.((λy.(y(λx.x)))(λx.(z\, x)))) \]
  
  Se escribe usando índices de De Bruijn como

  \[ λ (λ 1 (λ 1)) (λ 2\, 1) \]

  En la figura \ref{fig:debrujn} se puede observar de manera gráfica la transformación de una notación a otra para este ejemplo, visualizando las expresiones del cálculo lambda como árboles.
\end{exmp}

\begin{figure}
  \centering

  \begin{tikzpicture}[level/.style={sibling distance=60mm/#1}]
    \node [draw] (term) {\( (λz.((λy.(y (λx.x))) (λx.(z\, x)))) \)};
    \node [below of=term] (arrow1) {\( \Downarrow \)};
    \node [circle,draw,below of= arrow1] (z) {\( λ z \)}
      child {
        node [circle,draw] (a) {\( λ y \)}
        child {
          node [circle,draw] (c) {\( y \)}
        }
        child {
          node [circle,draw] (d) {\( λ x \)}
          child {
            node [circle,draw] (g) {\( x \)}
          }
        }
      }
      child {
        node [circle,draw] (b) {\( λ x \)} 
        child {
          node [circle,draw] (e) {\( z \)}
        } 
        child {
          node [circle,draw] (f) {\( x \)}
        }
      };
      \node [below=130pt of z] (arrow2) {\( \Downarrow \)};
      \node [circle,draw,below of= arrow2] (z2) {\( λ \)}
      child {
        node [circle,draw] (a2) {\( λ \)} 
        child {
          node [circle,draw] (c2) {\( 1 \)}
        }
        child {
          node [circle,draw] (d2) {\( λ \)} 
          child {
            node [circle,draw] (g2) {\( 1 \)}
          }
        }
      }
      child {
        node [circle,draw] (b2) {\( λ \)} 
        child {
          node [circle,draw] (e2) {\( 2 \)}
        }
        child {
          node [circle,draw] (f2) {\( 1 \)}
        }
      };
      \node [below=130pt of z2] (arrow3) {\( \Downarrow \)};
      \node [draw,below of=arrow3](bruijn) {\( λ (λ 1 (λ 1)) (λ 2\, 1) \)};
  \end{tikzpicture}
  
  \caption{Transformación gráfica del ejemplo \ref{exmp:debrujn}}
  \label{fig:debrujn}
\end{figure}

Una desventaja de utilizar la notación de De Bruijn es que ciertas expresiones del cálculo lambda no pueden ser escritas, en particular, los átomos no pueden ser variables libres para que esta notación pueda ser utilizada.

\subsection{\( β \)-convertibilidad}
\label{sec:beta-convertibildad}

Al igual que el cambio de variable ligada, la operación de reducción de aplicaciones es utilizada para describir una equivalencia entre expresiones. La idea básica de esta equivalencia consiste en observar que al aplicar una abstracción \( (λx.M) \) a una expresión \( N \), el resultado de su reducción siempre es el mismo. De manera similar a la aplicación de funciones, cuando se define una función \( f(x)=x^{2} \), la aplicación \( f(3) \) se suele igualar al resultado de la aplicación: \( f(3)=8 \).

Esta relación de equivalencia es llama \( β \)-convertibilidad y se denota como

\[ M \convertible{β} N \]

para dos expresiones \( M \) y \( N \) en donde a partir de un número finito de reducciones a aplicaciones, reducciones inversas y cambios de variable ligada en \( M \) o parte de \( M \) y \( N \) o parte de \( N \) se puedan obtener expresiones sintácticamente equivalentes.

El proceso inverso a la reducción de aplicaciones se puede ilustrar considerando la reducción de \( (((λg.(λy.(g (g (g\, y))))) f) x) \) a \( (f(f(f\, x))) \). No es posible reducir la segunda expresión a la primera, pero ya la segunda expresión es una reducción de la primera, ambas son \( β \)-convertibles:

\[ (f(f(f\, x))) \convertible{β} (((λg.(λy.(g (g (g\, y))))) f) x) \]

\subsection{Relaciones de equivalencia}
\label{sec:relaciones-de-equivalencia}

Todas las nociones de convertibilidad son relaciones de equivalencia, las cuales por definición cumplen con tres propiedades.

Sea \( \sim \) una relación de equivalencia

\begin{enumerate}[a.]
\item Toda expresión \( M \) es equivalente a sí misma, es decir, \( M \sim M \). \label{enum:rela:a}
\item Si una expresión \( M \) es relacionada con una equivalencia a otra expresión \( N \), entonces \( N \) también es relacionada a \( M \), es decir \( M \sim N \implies N \sim M \). \label{enum:rela:b}
\item Si una expresión \( M \) se relaciona con una equivalencia a otra expresión \( N \) y \( N \) se relaciona con la misma equivalencia a \( P \), entonces, \( M \) y \( P \) se relacionan con esta equivalencia, es decir, \( M \sim N,\ N \sim P \implies M \sim P \). \label{enum:rela:c}
\end{enumerate}

La equivalencia sintáctica corresponde al inciso \ref{enum:rela:a} de las propiedades de equivalencias mencionadas y es llamada propiedad de \emph{reflexividad}; al igual que la \( α \)-conversión y la \( β \)-conversión, la equivalencia sintáctica no está asociada a una regla de inferencia. En los incisos \ref{enum:rela:b} y \ref{enum:rela:c} se tienen inferencias que parten de expresiones equivalentes y basado en si estas expresiones son equivalentes o no, ciertas propiedades se deben cumplir. En el inciso \ref{enum:rela:b} la propiedad es llamada \emph{simetría}, mientras que en el inciso \ref{enum:rela:c} la propiedad es llamada \emph{transitividad}.

La \( α \)-conversión y la \( β \)-conversión fueron definidas como equivalencias independientes y su definición cumple con las tres propiedades mencionadas a pesar de ser definidas en base a un procedimiento y no en una regla declarativa, sin embargo, es deseable referirse a una sola equivalencia de expresiones que tenga las propiedades de \emph{reflexividad}, \emph{simetría} y \emph{transitividad} y posteriormente considerar otras reglas que la equivalencia deba de cumplir.

Al igual que Haskell Curry en \cite[p.~59]{Curry:CombinatoryLogicI} se utilizan las letras griegas \( α \) y \( β \) para referirse a las ecuaciones relacionadas con la \( α \)-conversión y \( β \)-conversión respectivamente y las letras \( ρ \), \( σ \) y \( τ \) para referirse a las propiedades de reflexividad, simetría y transitividad respectivamente, se retoma esta convención para elaborar la siguiente definición de una relación de equivalencia \( \sim \):

\begin{defn}[Ecuaciones de \( \sim \)]
  Las ecuaciones con \( \sim \) que se satisfacen para expresiones del cálculo lambda son
  \label{defn:sim}
  \begin{subequations}
    \begin{align}
      \label{sim:alpha} \tag{\( α \)}
      (λx.M) & \sim (λy.\subst{M}{x}{y}) \\
      \label{sim:beta} \tag{\( β \)}
      ((λx.M)N) & \sim \subst{M}{x}{N} \\
      \label{sim:rho} \tag{\( ρ \)}
      M & \sim M \\
      \label{sim:sigma} \tag{\( σ \)}
      M \sim N & \implies N \sim M \\
      \label{sim:tau} \tag{\( τ \)}
      M \sim N,\ N \sim P & \implies M \sim P
    \end{align}
  \end{subequations}
\end{defn}

Las ecuaciones en la definición \ref{defn:sim} son muy parecidas a las propiedades de la \( β \)-conversión, con la excepción de que la \( β \)-conversión relaciona expresiones en donde sus partes fueron transformadas y \( \sim \) no, por ejemplo

\[ (λf.((λx.(f\, x)) y)) \convertible{β} (λf.(f\, y)) \]

pero

\[ (λf.((λx.(f\, x)) y)) \nsim (λf.(f\, y)) \]

Para capturar la definición de \( β \)-convertibilidad con ecuaciones, es necesario definir a \( \sim \) en partes de una expresión. Las siguientes reglas, nombradas por Curry \cite[p.~59]{Curry:CombinatoryLogicI} como \( ν \), \( μ \) y \( ξ \), junto con las reglas de \(\sim\) completan la definición declarativa de \( β \)-convertibilidad:

\begin{defn}
  Reglas que debe cumplir \( \sim \) para ser \( \convertible{β} \)
  \label{defn:simbeta}
  \begin{subequations}
    \begin{align}
      \label{simbeta:nu} \tag{\( ν \)}
      M \sim N & \implies (M\, Z) \sim (N\, Z) \\
      \label{simbeta:mu} \tag{\( μ \)}
      M \sim N & \implies (Z\, M) \sim (Z\, N) \\
      \label{simbeta:xi} \tag{\( ξ \)}
      M \sim N & \implies (λx.M) \sim (λx.N)
    \end{align}
  \end{subequations}
\end{defn}

Con estas reglas y a partir de un razonamiento lógico, podemos demostrar la \( β \)-equivalencia entre dos expresiones.

\begin{exmp}
  Razonamiento para concluir que \( (λf.((λx.(f\, x)) y)) \convertible{β} (λf.(f\, y)) \)
  \label{exmp:razonamiento-sim}
  \begin{align*}
    \text{1. } & ((λx.(f\, x)) y) \convertible{β} (f\, y) & & \text{por \( β \)} \\
    \text{2. } & (λf.((λx.(f\, x)) y)) \convertible{β} (λf.(f\, y)) & & \text{por \( ξ \)}
  \end{align*}
\end{exmp}

Es posible incluir aún más reglas de equivalencia cuando se estudia el cálculo lambda, a pesar de poder trabajar con expresiones en este sistema a partir de equivalencias arbitrarias, usualmente cada regla de equivalencia se asocia con alguna argumentación basada en la noción de función.

Por ejemplo, se pueden considerar dos abstracciones diferentes \( (λx.M) \) y \( (λy.N) \) que al ser aplicadas a cualquier expresión \( Z \) sean \( β \)-convertibles a una misma expresión \( W \). Si se relacionan las abstracciones del cálculo lambda con funciones, es natural pensar que \( M \) y \( N \) sean equivalentes, ya que por definición, dos funciones \( f \) y \( g \) son equivalentes si para toda \( x \) en su dominio \( f(x)=g(x) \). Por ejemplo, las funciones \( f(n)=\sum_{i=0}^{n}i \) y \( g(n)=\frac{n(n+1)}{2} \) a pesar de describir dos procedimientos diferentes para el cálculo de la suma de los primeros \( n \) números naturales son ``funcionalmente'' equivalentes ya que para todo natural \( f(n)=g(n) \). Por otro lado, si se relacionan las abstracciones del cálculo lambda con algoritmos, \( M \) y \( N \) no pudieran ser consideradas equivalentes ya que en el estudio de la complejidad algorítmica, el énfasis en la comparación entre dos procedimientos no es las entradas y salidas, si no el proceso que describen. Por ejemplo, el algoritmo de ordenamiento \emph{merge sort} logra ordenar una secuencia de \( n \) números de menor a mayor en \( \mathcal{O}(n \log n) \) mientras que el algoritmo \emph{bubble sort} computa el mismo resultado pero en \( \mathcal{O}(n^2) \).  La equivalencia ``funcional'' se pudiera incluír en la definición de \( \sim \) añadiendo la siguiente regla:

\[ (M\, P) \sim (N\, P) \implies M \sim N \]

Con esto se termina la introducción informal al cálculo lambda, las ideas que se han manejado en esta sección son formalizadas y definidas de manera rigurosa en el capítulo \ref{ch:formalizacion}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
