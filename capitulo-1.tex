El cálculo lambda es un sistema formal creado con la finalidad de expresar,
manipular y estudiar funciones. La manera en la que se trabaja con funciones en
este sistema es diferente a como es usual en la matemática clásica. Por este
motivo, se presenta una introducción informal que tiene como objetivo esclarecer
estas diferencias.\\

La estructura de este capítulo se conforma de tres secciones: en la primera se
aborda la introducción informal al cálculo lambda, en donde se presenta la
terminología utilizada en las explicaciones y ejemplos, se describen algunas de
las diferencias tanto conceptuales como de notación entre las funciones en este
sistema y las funciones en la matemática clásica; en la segunda sección
se presenta la formalización del cálculo lambda y en base a ésta se definen con
precisión los conceptos abordados en la primer sección; en la tercer sección se
exploran diferentes maneras de representar en el cálculo lambda algunos objetos
y operaciones matemáticas utilizadas en el estudio de la computación.\\

\section{Introducción} \label{sec:1.1}

La definición de función en la matemática clásica es el de una relación entre un
conjunto de entradas, llamado \emph{dominio} y un conjunto de salidas, llamado
\emph{codominio}. Esta relación tiene además la propiedad de que cada elemento
del dominio se relaciona exactamente con un elemento del codominio, formalmente:\\

Sean \(A\) y \(B\) dos conjuntos, una función \(f\) con dominio \(A\) y
codominio \(B\) es un subconjunto del producto cartesiano \(A\times B\), tal que
para toda \(a\in A\), existe \(b\in B\) tal que \((a,\ b)\in f\) y si \((a,\
b^\prime)\in f\) con \(b^\prime \in B\), entonces \(b=b^\prime\).\\

Las funciones tienen varias maneras de ser representadas. En la definición
anterior la representación es la de pares ordenados, en donde la primer componente
del par es un elemento en el dominio y la segunda es un elemento en el codominio.
Dependiendo del contexto en el que se trabaja con las funciones, puede ser
conveniente representarlas simbolicamente con expresiones, graficamente con
dibujos, numéricamente con tablas o incluso verbalmente con palabras.\\

Es posible utilizar esta definición para \emph{describir} las funciones en el
cálculo lambda, para esto se tiene que establecer cuál es el dominio y codominio de
cada función; después presentar una representación conveniente para las reglas
de correspondencia en el sistema. Sin embargo, hay algunas propiedades del
cálculo lambda que hacen que esta definición no pueda ser directamente aplicada.
En particular, el cálculo lambda como sistema formal es una \emph{teoría
  ecuacional}, esto significa que la teoría formal del cálculo lambda solo se
conforma de reglas de igualdad entre expresiones, estas reglas consideran
únicamente la estructura de las expresiones y en el caso del cálculo lambda, las
expresiones no se componen de conjuntos, conectivos o cuantificadores lógicos.\\

En el cálculo lambda existen expresiones para representar \emph{variables},
\emph{funciones} y \emph{aplicaciones}. El concepto de aplicación hace alusión a
la \emph{aplicación de funciones}, es decir, el acto de obtener un elemento del
codominio de una función, a partir de un elemento en su dominio, por ejemplo,
considerando la función \(f(x)=x^2\), aplicar \(f\) a 4 es \(f(4)=16\).\\

Las expresiones de funciones y aplicaciones en el cálculo lambda son en algúnos
aspectos mas restrictivas que en la matemática clásica, ya que en las
expresiones no se pueden escribir directamente números como el 2, ni operaciones
como la exponenciación, por lo tanto, no es posible escribir directamente la
función \(f(x)=x^2\) como una expresión válida del cálculo lambda. Por otro
lado, la aplicación en el cálculo lambda es menos restrictiva que la aplicación
de funciones de la matemática clásica, ya que el cálculo lambda permite aplicar
cualquier expresión válida a otra, no únicamente funciones a valores.\\

En general, las expresiones en el cálculo lambda asociadas a los conceptos de
función y de aplicación de funciones se pueden escribir únicamente en términos
de otras expresiones, las cuales a su vez pueden ser solo variables, funciones o
aplicaciones. Esto no significa que al trabajar con este sistema no podamos
trabajar también con teoría de conjuntos, aritmética, lógica o algúna otra rama
de las matemáticas, esto solo significa que las expresiones en el
\emph{lenguaje} del sistema formal son restrictivas en la manera en la que se
escriben. Sin embargo, al igual que las palabras en el español, en el lenguaje
utilizado para examinar y describir el cálculo lambda es válido hacer uso de
cualquier herramienta, ya sea matemática o computacional, a este otro lenguaje
se le llama \emph{metalenguaje}.\\

Al tratar con funciones en el cálculo lambda, se omite hablar de su dominio y
codominio, esto es debido a que todas las funciones válidas tienen como dominio 
y codominio al conjunto de todas las expresiones válidas del cálculo lambda. 
Este detalle debe ser tratado con cuidado cuando se representan objetos y 
operaciones matemáticas en el cálculo lambda, ya que el dominio y codominio de 
estas operaciones segue siendo el del conjunto de todas las expresiones 
válidas del cálculo lambda, sin importar la operación que se represente. Por 
ejemplo, es posible representar cualquier número natural con expresiones válidas 
del cálculo lambda y también es posible tener una representación de la operación 
de exponenciación; se puede \emph{emular} la función \(f : \mathbb{N} \to
\mathbb{N}\), \(f(x,y)=x^y\), mas sin embargo la función del cálculo lambda que
representa esta operación segue teniendo como dominio y codominio el conjunto
de todas las expresiones válidas del cálculo lambda, esto significa que será
valido aplicar esta representación de exponenciación a expresiones que no sean
representaciones de números naturales y el resultado de dicha aplicación no
necesariamente es una expresión que represente a un número natural.\\

El hecho de tener un lenguaje tan reducido y minimalista para las expresiones
nos permite poder entender de manera clara y precisa todos los procesos de
manipulación y transformación de la estructura de una expresión, a tal grado que
todas las operaciones que se realizan sobre las expresiones pueden reproducirse
paso a paso de manera mecánica, manipulando los símbolos que las conforman.\\

\subsection{Notación} \label{sec:1.1.1}

La notación utilizada en la matemática clásica para escribir la definición y
aplicación de funciones suele ser la de expresar una regla de correspondencia
como una expresión simbólica. En el cálculo lambda, también se utiliza ésta
representación, pero los símbolos empleados para escribir las expresiones son
definidos con precisión de antemano, en contraste con las expresiones
matemáticas, en donde la notación de las reglas de correspondencia puede ser
extendida de manera arbitraria ya sea para incluír operaciones sobre distintos
objetos matemáticos, compactar repeticiones de operaciones como
\(\sum_{i=0}^n\) o incluso incrustar en la notación procesos no finitos como 
límites al infinito \(\lim_{x\to \infty}\).\\

Para introducir la notación del cálculo lambda, consideramos la función
identidad \(I : \mathbb{N} \to \mathbb{N}\) definida como \(I(x)=x\).\\

En la notación clásica, \(I\) se compone de la especificación de su dominio y
codominio, en este caso \(\mathbb{N}\), después se establece la regla de
correspondencia la cual indica que, al aplicar \(I\) a un argumento \(x\in
\mathbb{N}\), el resultado es equivalente a la expresión del lado derecho de
la ecuación, en donde toda aparición de la variable \(x\) hace referencia al
argumento particular al que le fué aplicado \(I\).\\

En el cálculo lambda, no se considera el dominio ni el codominio de las
funciones, e incluso, no se considera el nombre con el que nos referimos a
ellas. La manera en como \(I\) es escrita en este sistema es \[\lc{\x.x}\] el
símbolo ``\(\lambda\)'' nos indica que la expresión es una función, y el símbolo
``\(.\)'' separa la variable que hace referencia al argumento al que la función
es aplicada y la expresión del lado derecho de la igualdad.\\

La aplicación de expresiones se denota de manera diferente también, mientras que
en la notación clásica se escribe \(I(y)\) considerando que \(y\in \mathbb{N}\),
en el cálculo lambda, debido a que no se nombran las funciones, se escribe
explícitamente la función a la que hacemos referencia \[\lc{(\x.x)y}\] En ambos
casos, \emph{realizar} la aplicación consiste en sustituír las apariciones de
\(x\) por \(y\) en la función, dando como resultado \(y\). Sin embargo, no
podemos afirmar que \(\lc{(\x.x)y}=y\) sin antes mencionar de manera explícita
el significado que se le dá a la igualdad entre dos expresiones.\\

Como se mencionó anteriormente, lo único que se puede escribir en el cálculo
lambda son variables, funciones definidas en términos de otra expresión y
aplicaciones entre dos expresiones. Todas las partes de la aplicación del ejemplo
anterior también son expresiones válidas: ``\(\lc{(\x.x)y}\)'',
``\(\lc{\x.x}\)'', ``\(\lc{y}\)'' y ``\(\lc{x}\)''. Estas expresiones muestran
la manera en como se escriben las aplicaciones, las funciones y en el caso de
\(\lc{x}\) y \(\lc{y}\), las variables.\\

A pesar de ser aparentemente una notación mas inconveniente debido a que se
limita a tratar solo con tres clases de expresiones, esta notación nos permite
ser mas explícitos en la descripción de expresiones y provee uniformidad en el
lenguaje formal. Esta notación también permite tener mas control sobre la manera
en que las expresiones son transformadas.\\

La estructura de las expresiones hace que sea mas directa la relación entre una
expresión o una parte de la expreción y un significado. El significado de una
expresión puede referirse a lo que la expresión represente conceptualmente
hablando o a la manera en la que la expresión puede ser operada.\\

Un ejemplo de la importancia de la asignación explícita del significado
operacional de las expresiones es el de los posibles problemas que se pueden
encontrar cuando se realiza la sustitución al momento de aplicar una función a
una expresión, desde la perspectiva de la matemática clásica, consideremos la
función factorial \(f : \mathbb{N} \to \mathbb{N}\) definida como
\[f(n)=
\begin{cases}
  1 &\mbox{si } n=1\\
  n\times f(n-1) & \mbox{en otro caso.}
\end{cases}
\]

Para obtener el resultado correcto la aplicación de \(f\) en 5, primero
verificamos si \(5=0\), en donde, si fuera el caso, el resultado sería 1, pero
ya que \(5\not= 0\), el resultado es \(5\times f(4)\), el proceso mecánico de
sustituír el argumento en la expresión de la regla de correspondencia consiste
en primero verificar si la condición es cierta antes de proceder en sustituír el
valor del argumento en el consecuente correspondiente. Si este modelo de
sustitución no se especifica para el uso de la notación del análisis casos
presente en el ejemplo, se pudieran contemplar otras maneras de sustituír al 5
en la expresión, por ejemplo, sustituyendo el argumento en todas las apariciones
de la variable \(n\), luego ``expandir'' el valor de la aplicación de funciones y
posteriormente decidir el resultado final verificando si el argumento cumple la
condición. Sin embargo, utilizar este modelo de sustitución en el ejemplo resulta en
realizar una infinidad de sustituciones debido a la naturaleza recursiva de la
definición.\\

En el uso cotidiano de las matemáticas, no se suele analizar el proceso de
sustitución, sin embargo, en el cálculo lambda es de suma importancia. Esta
diferencia se debe a que en la matemática clásica las comparaciones entre dos
funciones o dos expresiones tienden a ser \emph{declarativas}, es decir, se
declaran las relaciones, aseverando que la expresión es cierta; mientras que en
el cálculo lambda son \emph{imperativas}, es decir, toda relación o equivalencia
entre dos expresiones expresa un mecanismo para construir una expresión a partir
de otra.\\

Un ejemplo de esta distinción es el manejo del concepto de función
inversa desde ambas perspectivas, una definición declarativa es: Sea \(f\)
una función cuyo dominio es \(A\) y cuya imágen es \(B\), la función inversa de
\(f\) es la función \(f^{-1}\) con dominio \(B\) e imagen \(A\) tal que,
\(f(a)=b\) si y sólo si \(f^{-1}(b)=a\) con \(a\in A\) y \(b\in B\). En el
cálculo lambda no es usual trabajar con este tipo de definiciones debido a que
no describen un procedimiento mediante el cual se puede obtener \(f^{-1}\) a
partir de \(f\).\\

Al referirse a una expresión del cálculo lambda, usualmente, se conoce
parcialmente su estructura, es decir, algúna descripción de sus partes. En el
resto de esta sección nos referiremos a una variable entre la \(\lambda\) y el
punto de una función como \emph{argumento de la función} y a la expresión
después del punto y antes del paréntesis cerrado como el \emph{cuerpo de la
  función}. A continuación se muestran algunos ejemplos de expresiones:

\begin{align*}
  \text{a) }\ &\lc{x}\\
  \text{b) }\ &\lc{\x.x}\\
  \text{c) }\ &\lc{y (\x.x)}\\
  \text{d) }\ &\lc{(\y.y(\x.x))(\w.w)}\\
  \text{e) }\ &\lc{\x.x x}\\
  \text{f) }\ &\lc{\f x.f x}\\
\end{align*}

Las variables en el cálculo lambda son expresiones válidas, en el inciso
\emph{a} aparece la variable \(\lc{x}\) la cual no es ni una función ni una
aplicación; las variables por si solas en el cálculo lambda casi no tienen
utilidad, pero al ser partes de otra expresión, puede aumentar su importancia:
en el caso del inciso \emph{b} la misma variable \(\lc{x}\) es el cuerpo de la
función y como es también el argumento, esta variable tiene el potencial de
convertirse en cualquier otra expresión a partir de la aplicación de la función
\(\lc{\x.x}\).\\

En el inciso \emph{c} se tiene una aplicación inusual, es la variable \(\lc{y}\)
siendo aplicada a una función. Comunmente se trabaja con expresiones en donde lo
que se aplica es una función, sin embargo si \(\lc{y (\x.x)}\) fuera el 
cuerpo de una función, entonces \(\lc{y}\) jugaría un papel mas relevante. Esto
se puede apreciar en el inciso \emph{d}, en donde la expresión del inciso \emph{c}
es el cuerpo de una función con argumento \(\lc{y}\) y esta función está siendo
aplicada a otra función. Este ejemplo nos permite abordar dos ideas importantes,
primero, las funciones pueden ser aplicadas a funciones y segundo el realizar la
aplicación del ejemplo \emph{d}, la variable \(\lc{y}\) toma el valor de
\(\lc{\w.w}\) y es ahora aplicada a la función \(\lc{\x.x}\):

\begin{align*}
  \text{1. } &\lc{(\y.y(\x.x))(\w.w)} & &\text{ expresión del inciso \emph{d}}\\
  \text{2. } &\lc{(\w.w)(\x.x)} & &\text{ al aplicar } \lc{\y.y(\x.x)} \text{ a } \lc{\w.w}\\
  \text{3. } &\lc{\x.x} & &\text{ al aplicar } \lc{\w.w} \text{ a } \lc{\x.x}
\end{align*}

En este último ejemplo se describe una secuencia de transformaciones mecánicas
sobre los símbolos de la expresión, este procedimiento tiene algunos detalles que
son importantes recalcar pero se abordan cuando se describa la formalización
del cálculo lambda en la sección \ref{sec:1.2}. Por el momento se describen los
últimos dos incisos los cuales presentan dos conceptos interesantes.\\ 

En el inciso \emph{e} se tiene una función cuyo cuerpo es la aplicación de su
argumento sobre sí mismo. Lo interesante de esta expresión es que encapsula la
idea de replicar cualquier expresión a la que se aplique. Por ejemplo, si
aplicamos la expresión a la variable \(\lc{y}\) y realizamos el proceso de
aplicación similar al mostrado con el anterior ejemplo, obtendremos \(\lc{y y}\)
como resultado; si aplicamos la expresión a sí misma obtendremos un
``\emph{quine}'' \cite{Hofstadter:GEB}:

\begin{align*}
  \text{1. } &\lc{(\x.x x)(\x.x x)} & &\text{ expresión del inciso \emph{e} aplicada a si misma}\\
  \text{2. } &\lc{x} \leftarrow \lc{\x.x x} & &\text{ valor que toma } \lc{x} \text{ en el cuerpo de } \lc{\x.x x}\\
  \text{3. } &\lc{x x} & &\text{ expresión en donde se sustituye } \lc{x}\\
  \text{4. } &\lc{(\x.x x)(\x.x x)} & &\text{ al completar la sustitución}
\end{align*}

Como podemos observar, el resultado de la aplicación es la expresión inicial, a
pesar de que el término quine se asoció originalmente a una paradoja sobre
valores de verdad \cite{Quine:Paradox}, hoy en día hace referencia a un programa
que tiene como resultado el código fuente de él mismo.\\

El inciso \emph{f} es una función cuyo cuerpo es otra función, en donde el cuerpo
de esta última es la aplicación del argumento de la primer función al argumento
de la segunda. El concepto interesante que ilustra esta expresión es el de
funciones de varias variables: Aplicar esta expresión a una expresión cualquiera
\(M\) y posteriormente aplicar este resultado a otra expresión cualquiera \(N\)
produce el mismo resultado a que si tuvieramos una función de dos argumentos
\(\lc{f}\) y \(\lc{x}\) cuyo cuerpo es \(\lc{f x}\) y aplicaramos esta expresión
hipotética a \(M\) y \(N\).\\

Otra manera de trabajar con funciones de varias variables es la de representar
a tuplas en el el cálculo lambda y tener expresiones para obtener cada elemento
de una tupla. Sin embargo, representar tuplas es un mecanismo mas complejo que
se aborda en la sección \ref{sec:1.3}.\\

\subsection{El concepto de igualdad} \label{sec:1.1.2}

El concepto de igualdad es de grán interés en el cálculo lambda. En el
desarrollo histórico del este sistema, el estudio de los criterios que permiten
establecer que dos expresiones son iguales dió pié a una grán diversidad de
variantes de la teoría original.\\

De la mano al concepto de igualdad, están los mecanismos de transformación de
expresiones, estos mecanismos de transformación no son operadores dentro del
lenguaje del cálculo lambda, si no mas bien, son transformaciones que permiten
explorar las diferentes estructuras de las expresiones del cálculo lambda y son
usados como metalenguaje para referirse a equivalencias entre dos expresiones. Hay
una grán variedad de operaciones que pueden transformar expresiones, sin embargo,
en esta subsección abordaremos las mas elementales.\\

Las definiciones precisas de cada transformación se plantearán en la sección
\ref{sec:1.2}, por el momento se describe el concepto de igualdad que engloba
cada transformación elemental, describiendo el proceso mecánico de
transformación asociado.\\

\subsubsection{Sustitución}

Un concepto que es de grán importancia para describir y definir las
transformaciones que realizemos sobre expresiones es el de \emph{sustitución}.
Cuando se describió informalmente el proceso mecánico de la aplicación de
funciones en los ejemplos anteriores se mencionó este concepto. A continuación
se presenta una descripción mas detallada de este concepto abordado como
operación de transformación.\\

La sustitución involucra dos expresiones \(M\) y \(N\) cualesquiera y una variable
\(x\), el proceso de transformación consiste en intercambiar todas las
apariciones de la variable \(x\) en la expresión \(M\) por la expresión \(N\),
denotado \(M[\lc{x}:=N]\). Es usual que en los sistemas formales, se tenga
cuidado al definir la transformación de sustitución, los detalles de la
transformación son pospuestos por el resto de la sección y se presentan
ejemplos en donde esta definición provisional es suficiente.\\

A manera de ejemplo, consideremos la sustitución de la variable \(y\) por \(x\)
en la expresión \(\lc{y w}\), se escribe
\[\lc{y w}[\lc{y}:=\lc{x}]\]
y la expresión resultante es \(\lc{x w}\).\\

Retomando el proceso descrito en el ejemplo de la expresión del inciso \emph{d},
el acto de aplicar la función \(\lc{\y.y(\x.x)}\) en \(\lc{\w.w}\) se escribe
con esta notación como:
\begin{align*}
  &\lc{(\y.y(\x.x))(\w.w)} & &\lc{y(\x.x)}[\lc{y}:=\lc{\w.w}]\\
  &\lc{(\w.w)(\x.x)}       & &\lc{w}[\lc{w}:=\lc{\x.x}]\\
  &\lc{\x.x}               & &
\end{align*}

A diferencia de las transformaciones que se abordan a continuación, la
sustitución no está relacionada directamente con algún concepto de igualdad mas
que el que describe la operación por si misma. Sin embargo es la transformación
fundamental sobre la cual se describe el resto.\\

\subsubsection{Equivalencia de expresiones}

Con la sustitución se pueden transformar expresiones del cálculo lambda
independientemente del contexto en el que se utilizan y sin prestar atención a
lo que la expresión representa conceptualmente. A excepción de la función
identidad y una representación del número 1, no se han abordado expresiones que
representen algún concepto mas allá de su estructura simbólica, y a pesar de ser
tentador asignarle un significado preciso a cada expresión presentada, es importante
seguir analizando únicamente su estructura para tratar el tema de equivalencia
de expresiones.\\

Una pregunta que posiblemente surge cuando se estudian las expresiones en el
cálculo lambda y mas aún cuando se comparan estas expresiones con las utilizadas en
la matemática clásica es, si \(M\) y \(N\) son dos expresiones del cálculo
lambda, ¿Son iguales?.\\

Usualmente podemos afirmar que dos expresiones son iguales cuando entendemos el
contexto y el nivel de abstracción en el que se refiere a ellas. Por ejemplo,
dos números se suelen considerar iguales si representan el mismo concepto con el
que se desea trabajar, si observamos una ecuación como \(3=\frac{6}{2}\) sabemos
de inmediato que la ecuación es cierta, a pesar de que \(frac{6}{2}\)
explícitamente hace referencia a una división y los dos lados de la igualdad se
escriban diferente simbolicamente. Cuando se involucran variables y operaciones
el concepto de igualdad requiere contexto, considerando la ecuación \(x\cdot
y=y\cdot x\), es imposible poder aseverar si la ecuación es cierta sin
establecer los valores que ``\(x\)'', ``\(y\)'' y ``\(\cdot\)'' representan, en
caso que sean números naturales y la operación aritmética de multiplicación la
ecuación es cierta, pero en caso que sean matrices y la operación de producto
matricial, la ecuación es falsa.\\

Al abordar expresiones matemáticas, el contexto en el que se expresan casi siempre
se puede inferir por la manera en como las expresiones son utilizadas y lo mas
común es tener a la mano la definición de las estructuras matemáticas y
operaciones utilizadas en las expresiones, sin embargo, en el estudio del cálculo
lambda, se tiene que ser mas explícito en especificar el concepto de igualdad
con el que se trabaja, es tan importante que modificar su significado, modifica los
axiomas de la teoría.\\



\subsubsection{Equivalencias}

Como se abordó previamente se pueden construír expresiones en el cálculo lambda
cuyo significado no esté definido con claridad o que el significado de una
expresión dependa del contexto en el que es utilizada.\\

Una pregunta que se puede responder independientemente del contexto en el que se
trabaje con el cálculo lambda es, si \(M\) y \(N\) son dos expresiones del
cálculo lambda, ¿Son equivalentes?. Pera responder esta pregunta se tiene que
explorar a que nos podemos referir con \emph{equivalente}.\\

Podemos afirmar que dos expresiones son equivalentes cuando entendemos el
contexto y el nivel de abstracción en el que se está refiriendo a ellas. Por
ejemplo, podemos considerar dos números equivalentes si se escriben igual, en
cuyo caso \(3\),  \(\frac{6}{2}\) y \(3.0\) no serían equivalentes. Sin embargo si consideramos
una equivalencia de valores, tanto \(3\), como \(\frac{6}{2}\), como \(3.0\) hacen referencia al mísmo
elemento en \(\mathbb{R}\). Quizá pueda parecer demasiado detallista precisar a
que tipo de equivalencia se está refiriendo cada vez que se comparan dos
expresiones, sin embargo, si consideramos a los algorítmos como los objetos que
comparamos, se suele tomar en cuenta la cantidad de operaciones que
realizan en función al tamaño del las entradas, por lo que dos algoritmos con
las mismas entradas y las mismas salidas no sean equivalentes desde un punto de
vista de complejidad computacional.\\

Ya que es importante precisar con exactitud el concepto de equivalencia,
abordaremos algunas maneras en las que podemos comparar dos expresiones del
cálculo lambda.

\paragraph{Equivalencia sintáctica}

Esta equivalencia es aquella que nos permite distinguir si dos expresiones son
lo mismo de acuerdo a la manera en como son escritas. Si \(M\) y \(N\) están
escritas de la misma manera, símbolo por símbolo, se dice que son equivalentes
sintácticamente y se denota \(M \synteq N\).\\

\paragraph{Equivalencia estructural}

Podemos ver las expresiones del cálculo lambda como definición de funciones,
aplicación de funciones, variables y combinaciones de estas. La posición en
donde se encuentran las partes de una expresión determinan su estructura, sin
embargo, los nombres de varaibles que se utilizan no influyen su significado
estructural, de manera similar al concepto de la equivalencia en gráficas
isomorfas.\\

Considerndo la función identidad \(\lc{\x.x}\) se puede observar que tiene la
misma estructura que \(\lc{\y.y}\) la cual también representa la función
identidad. A pesar de no estar escritas exactamente igual, la correspondencia
que hay de la posición de la variable \(x\) en la primera expresión con la
posición de la variable \(y\) en la segunda y el hecho de que ambas tienen la
misma estructura nos permite decir que son equivalente.\\

Considerando dos expresiones un poco mas complejas como \(\lc{\f x.f x}\) y
\(\lc{\g y.g y}\) podemos notar que también son equivalentes en este sentido.
Una manera intuitiva de identificar esta equivalencia es comprobar que las
operaciones que representan dos expresiones son leídas de la misma manera pero
en lugar de leer explícitamente el nombre de la variable, se lee la posición de
la primera aparición de dicha variable. En el ejemplo dado se lee ``Una función cuyo
cuerpo es una función cuyo cuerpo es la aplicación de la primer variable en la
segunda''. Si dos expresiones \(M\) y \(N\) son estructuralmente equivalentes,
se dice que \(M\) es \alphacong~a \(N\).\\

Una notación utilizada para corroborar la equivalencia estructural es el
\emph{índice de De Bruijn}, esta notación evita la aparición de variables en las
expresiones y en su lugar utiliza números que representan la distancia de una
variable a la \(\lambda\) de la función en donde aparece como argumento. De tal
manera que una expresión como

\begin{equation}\label{eq:2.1}
  \lc{\z.(\y.y (\x.x))(\x. z x)}
\end{equation}

se escribe usando el índice de De Bruijn como

\begin{equation}\label{eq:2.2}
  \lambda (\lambda 1 (\lambda 1)) (\lambda 2 1)
\end{equation}

En la figura~\ref{fig:DeBruijn-transformation} se puede observar de manera
gráfica la transformación de una notación a otra para este ejemplo en
particular.\\

\begin{figure}
  \centering
  
  \begin{tikzpicture}[level/.style={sibling distance=60mm/#1}]
    \node (term) {\(\lc{\z.(\y.y (\x.x))(\x. z x)}\)};
    \node [below of=term] (arrow1) {\(\Downarrow\)};
    \node [circle,draw,below of= arrow1] (z){\(\lambda z\)}
    child {node [circle,draw] (a) {\(\lambda y\)}
      child {node [circle,draw] (c) {\(y\)}}
      child {node [circle,draw] (d) {\(\lambda x\)}
        child {node [circle,draw] (g) {\(x\)}}
      }
    }
    child {node [circle,draw] (b) {\(\lambda x\)}
      child {node [circle,draw] (e) {\(z\)}}
      child {node [circle,draw] (f) {\(x\)}}
    };
    \node [below=4cm of z] (arrow2) {\(\Downarrow\)};
    \node [circle,draw,below of= arrow2] (z2){\(\lambda\)}
    child {node [circle,draw] (a2) {\(\lambda\)}
      child {node [circle,draw] (c2) {\(1\)}}
      child {node [circle,draw] (d2) {\(\lambda\)}
        child {node [circle,draw] (g2) {\(1\)}}
      }
    }
    child {node [circle,draw] (b2) {\(\lambda\)}
      child {node [circle,draw] (e2) {\(2\)}}
      child {node [circle,draw] (f2) {\(1\)}}
    };
    \node [below=4cm of z2] (arrow3) {\(\Downarrow\)};
    \node [below of=arrow3](bruijn) {\(\lambda (\lambda 1 (\lambda 1)) (\lambda 2 1)\)};
  \end{tikzpicture}
  \caption{Transformación de~\eqref{eq:2.1} a~\eqref{eq:2.2}.}
\label{fig:DeBruijn-transformation}
\end{figure}

Una desventaja de utilizar la notación de De Bruijn es que ciertas expresiones
del cálculo lambda no pueden ser escritas, en particular, toda variable tiene
que estar asociada a una \(\lambda\) para que esta notación pueda ser utilizada.
Sin embargo como veremos más adelante, la mayoría de los usos del cálculo lambda
asocian a todas las variables en las expresiones.\\

En este trabajo no se utiliza la notación de De Bruijn, sin embargo
es importante mencionarla ya que dos expresiones que sean
\alphacong~van a ser sintácticamente equivalentes utilizando los índices de De
Bruijn.\\

\paragraph{Equivalencia de aplicación}

Otra equivalencia que podemos encontrar en las expresiones es la de aplicación,
esta hace referencia a que la aplicación de una función a una expresión es
equivalente al resultado de evaluar la función con dicha expresión como
argumento. Para entender mejor este concepto, consideramos la función en
notación tradicional \(f(x)=x^2\), si se evalúa \(f(3)\) el resultado es 8, por
lo tanto podemos decir que \(f(3)\) y 8 son equivalentes.\\

Si consideramos la expresión de la función identidad \(\lc{\x.x}\) podemos
afirmar que para cualquier expresión \(M\), \(\lc{(\x.x) M}\) es equivalente a
\(M\), en el cálculo lambda a esta equivalencia se le llama
\(\beta\)-\emph{convertibilidad}.\\

En la notación tradicional, estas tres equivalencias se denotan con el mísmo
símbolo \(=\), de tal manera que si dos expresiones son equivalentes ya sea
sintácticamente, estructuralmente o aplicativamente, entonces son consideradas
iguales. En el cálculo lambda es importante diferenciar estas equivalencias ya
que el manejo de las funciones no se aborda desde el punto de vista de una
relación entre el dominio y codominio, si no como una expresión que puede ser
manipulada y transformada de manera mecáncia.\\

\paragraph{Equivalencia de redundancia}

Otro tipo de equivalencia es la de redundancia, consideremos la expresión
\(\lc{\x.(\y.y) x}\), el papel que puede jugar es el de ser aplicada en otra
expresión \(M\), la cual resulta igual a aplicar la expresión interna
\(\lc{\y.y}\) en \(M\). Por las equivalencias descritas previamente podemos
observar que \(\lc{\x.(\y.y) x}\) y \(\lc{\y.y}\) no son sintácticamente
equivalentes, ni estructuralmente equivalentes, ni siquiera aplicativamente
equivalentes. El trabajar con la función que envuelve a \(\lc{\y.y}\) resulta
redundante al momento de aplicar las funciones en expresiones, ésto nos permite
considerar un criterio de equivalencia.\\

En el cálculo lambda, la equivalencia de redundancia se denomina
\(\eta\)\emph{-equivalencia} y nos permite considerar como iguales las
expresiones de la forma \(\lc{\x.M x}\) y \(M\).\\

\paragraph{Equivalencia computacional}

En el estudio de la lógica, se hace la distinción que una equivalencia puede ser
extensional o intensional. La equivalencia extensional hace referencia a las
propiedades externas de los objetos, mientras que la equivalencia intensional
hace referencia a la definición o representación interna de los objetos.\\

Las equivalencias sintáctica y estructural son equivalencias intencionales,
mientras que las equivalencias de aplicación y redundancia son equivalencias
extensionales, debido a que se juzgan dos objetos a partir de su evaluación. Sin
embargo, las equivalencias de aplicación y de redundancia no comprenden el caso
mencionado al inicio de esta subsección. Suponiendo que tenemos dos expresiones
\(M\) y \(N\) que describen el mismo algoritmo o la misma función, la
equivalencia de aplicación no los considera equivalente.\\

En la notación tradicional, la igualdad de funciones es una equivalencia
extensional, por ejemplo \(f(x) = e^{i\pi}\times x\) y \(g(x) = x\) describen la
función identidad y podemos aseverar que \(f=g\) sin necesidad de evaluar ambas
funciones con un argumento en particular.\\

En el cálculo lambda se puede hablar de este tipo de igualdad funcional si
consideramos que para toda expresión del cálculo lambda \(P\), si \(\lc{M P}\)
es equivalente a \(\lc{N P}\), entonces las expresiones \(M\) y \(N\) se dice
que son \(ext\) equivalentes.\\

\paragraph{Una simple regla con fuertes implicaciones}

Existe una regla, llamada regla \(\xi\), la cual establece una equivalencia muy
sencilla: si dos expresiones \(M\) y \(N\) son equivalentes, entonces las
expresiones \(\lc{\x.M}\) y \(\lc{\x.N}\) también lo son.\\

Aunque esta regla aparente aportar poco y pueda ser considerada innecesaria si
combinamos todas las equivalencias previamente descritas, es suficiente para
eliminar la equivalencia de redundancia y la equivalencia computacional de la
formalización del cálculo lambda, la cuál es abordada en la sección \ref{sec:1.2}.\\


\subsubsection{Transformación de expresiones}

A cada equivalencia diferente a la sintáctica se le puede asociar una operación de
transformación la cual nos permita pasar de una expresión \(M\) a otra expresión
\(N\) de tal manera que estas dos expresiones sean equivalentes bajo algún
criterio específico.\\

En el caso de la \alphacong~la operación correspondiente consiste en cambiar
nombres de variables, en la \(\beta\)-\emph{convertibilidad} la operación
consiste en realizar una secuencia de sustituciones de las variables de una
función por expresiones a las que la función es aplicada y en la
\(\eta\)\emph{-equivalencia} la operación consiste en la eliminación de funciones
redundantes.\\

Estas operaciones se definen de manera formal más adelante y aunque puedan
parecer operaciones sencillas de definir a partir de la operación de
sustitución, se tiene que tener mucho cuidado en no obtener expresiones que
rompan la equivalencia asociada.\\

\section{Formalización de la teoría
  \texorpdfstring{$\boldsymbol\lambda$}{lambda}} \label{sec:1.2}

La teoría \(\boldsymbol\lambda\) es el conjunto de axiomas que definen
formalmente al cálculo lambda como sistema formal, el objeto de estudio
principal de esta teoría es el del conjunto cociente formado a partir de un
conjunto de fórmulas bien formadas y una relación de equivalencia. En las
siguientes subsecciones se definen estos conceptos, los cuales nos permitirán
comenzar el estudio formal del cálculo lambda.\\

\subsection{Fórmulas bien formadas} \label{sec:1.2.1}

Una fórmula bien formada es un objeto formal sintáctico al que se le puede
asociar un significado semántico. Para definir las fórmulas bien formadas de un
lenguaje no es necesario darle un significado a cada fórmula, pero sí es
importante expresar de manera rigurosa cómo se constituye simbolicamente.\\

El conjunto de fórmulas bien formadas del cálculo lambda es llamado
\emph{términos lambda}, denotado como \(\Lambda\). Este conjunto tiene elementos
que son expresiones construidas a partir del alfabeto \(\Sigma\). Éste alfabeto es
un conjunto que se conforma por los símbolos \((\) , \()\) , \(.\) , \(\lambda\)
y una infinidad de símbolos \(v ,\ v^{\prime} ,\ v^{\prime\prime} ,\ \dots\ \),
etc. A esta secuencia infinita de símbolos \(v^i\) se denota como \(V\), de
tal manera que \(\Sigma = \left\{\  (\ ,\ )\ ,\ .\ ,\ \lambda\ \right\} \cup V\).\\

\(\Lambda\) es el conjunto mas pequeño tal que:

\begin{align}
  \label{eq:2.3}
  \lc{x} \in V &\Rightarrow \lc{x} \in \Lambda\\
  \label{eq:2.4}
  \lc{M},\ \lc{N} \in \Lambda &\Rightarrow \lc{M N} \in \Lambda\\
  \label{eq:2.5}
  \lc{M} \in \Lambda,\ \lc{x} \in V &\Rightarrow \lc{\x.M} \in \Lambda
\end{align}

Cada una de estas tres reglas corresponde a los tres tipos de términos lambda.
La regla \eqref{eq:2.3} implica que los símbolos en \(V\) son términos lambda,
estos símbolos son llamados \emph{átomos}; la regla \eqref{eq:2.4} implica que dos
términos lambda entre paréntesis también son términos lambda, a este tipo de
términos se les llama \emph{aplicaciones}; la regla \eqref{eq:2.5} implica que
si se tiene entre paréntesis el símbolo \(\lambda\) seguido de un átomo, un
punto y un término lambda cualquiera, entonces ésta expresión también es un
término lambda, a este tipo de términos lambda se les llama
\emph{abstracciones}.\\

Desde la perspectiva de lenguajes formales, \(\Lambda = L(G)\), donde \(G\) es
una gramática libre de contexto con categorías sintácticas \(T\) (términos
lambda), \(E\) (aplicaciones), \(F\) (abstracciones) y \(A\) (átomos); símbolos
terminales \(\left\{\ (\ ,\ )\ ,\ .\ ,\ \lambda\ ,\ v,\ {}^{\prime}\
\right\}\); símbolo inicial \(T\) y con las siguientes reglas de producción:

\begin{align*}
  \text{1.  }\ T &\rightarrow  E\ \mid\ F\ \mid\ V\\
  \text{2.  }\ E &\rightarrow  (\ T\ T\ )\\
  \text{3.  }\ F &\rightarrow  (\ \lambda\ A\ .\ T\ )\\
  \text{4.  }\ A &\rightarrow  v\ \mid\ E\ {}^{\prime}
\end{align*}

Para facilitar la escritura de términos lambda, en este trabajo se realizan las
siguientes consideraciones sobre la notación:

\begin{itemize}
\item[I.] Cuando se hace referencia a cualquier término lambda se utilizan las
  letras mayúsculas \(M,\ N,\ O,\ \) etc. Es importante establecer que si en un
  ejemplo, explicación, teorema o demostración hacemos referencia a un término
  lambda con una letra mayúscula, cualquier otra aparición de esta letra hará
  referencia a este mismo término.
\item[II.] Cuando se hace referencia a cualquier átomo se utilizan las letras
  minúsculas \(x,\ y,\ z,\ w,\ \) etc. Al igual que en el punto anterior, la
  aparición de una letra minúscula en un ejemplo, explicación, teorema o
  demostración hace referencia al mismo término.
\item[III.] Los paréntesis son omitidos de acuerdo a las siguientes
  equivalencias sintácticas:
  \begin{itemize}
  \item[a)] \(\lc{M N O} \synteq \lc*{M N O}\), en general, se considera la
    aplicación de términos lambda como una operación con asociación a la
    izquierda. Se tiene que tener cuidado con respetar la asociación, por
    ejemplo \(\lc{M(N(O(P)))} \synteq \lc*{M(N(O(P)))} \not\synteq \lc*{M N O P}\).
  \item[b)] \(\lc{\x.M N} \synteq \lc*{\x.M N}\), en general, se puede escribir una
    abstracción omitiendo los paréntesis externos siempre y cuando no se escriba
    un término sintácticamente diferente. Por ejemplo \(\lc{(\x.M N) O} \synteq
    \lc*{(\x.M N) O} \not\synteq \lc*{\x.M N O}\) ya que el lado derecho de la
    equivalencia es sintácticamente equivalente a \(\lc*{\x.M N O}\).
  \item[c)] \(\lc{\x y z.M} \synteq \lc*{\x y z.M}\), en general, si el subtérmino a
    la derecha del punto en una abstracción es también una abstracción, se
    pueden agrupar los åtomos antes del punto de ambas abstracciones después de
    una \(\lambda\) y antes que el punto, dejando el subtérmino después del
    punto de la segunda abstracción, como el del nuevo término.
  \end{itemize}
\item[IV.] Se utiliza el símbolo \(=\) para representar la igualdad entre dos
  objetos matemáticos que no sean términos lambda, como por ejemplo números.
\end{itemize}

La notación explicada en \emph{III.a)} proviene de la reducción usada por
Schönfinkel, en donde funciones de varias variables se transformn a funciones
de una sola variable \cite{Schonfinkel:Varargs}.\\

\subsection{Relación de equivalencia} \label{sec:1.2.2}

Una relación de equivalencia es una relación binaria \(\sim\) sobre elementos de un
conjunto \(X\), donde \(\sim\) es reflexiva, simétrica y transitiva, es decir:

\begin{itemize}
\item[\S] \(a\in X \Rightarrow a\sim a\)
\item[\S] \(a,\ b\in X,\ a\sim b \Rightarrow b\sim a \)
\item[\S] \(a,\ b,\ c\in X, a\sim b,\ b\sim c \Rightarrow a\sim c\)
\end{itemize}

En el estudio formal del cálculo lambda, la relación de equivalencia asociada a
los términos lambda es llamada \emph{convertibilidad}. Ésta relación es generada
a partir de axiomas y para formular estos axiomas es necesario formalizar el
concepto de \emph{sustitución}.\\

\textbf{DEFINIR LOS CONCEPTOS NECESARIOS PARA HABLAR DE LO QUE SIGUE}

\textbf{DEFINIR SUSTITUCIÓN}\\

\begin{align}
  \lc{x}[\lc{x}:=\lc{M}] &\synteq M                       &\\
  \lc{y}[\lc{x}:=\lc{M}] &\synteq y                       &y \not\synteq x\\
  \lc{M N}[\lc{x}:=P] &\synteq (M[x:=P]\ N[x:=P])         &\\
  \lc{\x.M}[x:=N] &\synteq \lc{\x.M}                      &\\
  \lc{\y.M}[x:=N] &\synteq \lc{\y.M}                      &x \not\in FV(P)\\
  \lc{\y.M}[x:=N] &\synteq (\lambda\ y\ .\ M[x:=N])       &x\in FV(M),\ y\not\in FV(N)\\
  \lc{\y.M}[x:=N] &\synteq (\lambda\ z\ .\ M[y:=z][x:=N]) &x\in FV(M),\ y\in FV(N)
\end{align}

En las ecuaciones e, f y g, la variable $y$ debe de ser diferente a $x$ y en el
inciso g, la variable $z \in (FV(N) \cup FV(M))^c$.


\textbf{DEFINIR ALPHA CONVERSIÓN Y SUS DETALLES FINOS}\\

\textbf{DEFINIR BETA CONVERSIÓN Y SUS DETALLES FINOS}\\

\textbf{DEFINIR REGLA XI Y SUS DETALLES FINOS}\\

\subsection{Conjunto cociente}\label{sec:1.2.3}

\textbf{EXPLICAR THIS SHIT Y CLASES DE EQUIVALENCIA}\\

\subsection{Axiomas de \texorpdfstring{$\boldsymbol\lambda$}{lambda}} \label{sec:1.2.4}

Sean \(M,\ N,\ Z\in \Lambda\) y \(x,\ y\in V\), la convertibilidad en la teoría
\(\boldsymbol\lambda\) se genera a partir de los siguientes axiomas:

\begin{align}
  &\lc{M} \sim \lc{M} &(\text{reflexividad})\\
  &\lc{M} \sim \lc{N} \Rightarrow \lc{N} \sim \lc{M} &(\text{simetría})\\
  &\lc{M} \sim \lc{N},\ \lc{N} \sim \lc{L} \Rightarrow \lc{M} \sim \lc{L} &(\text{transitividad})\\
  &\lc{M} \sim \lc{N} \Rightarrow \lc{M Z} \sim \lc{N Z}\\
  &\lc{M} \sim \lc{N} \Rightarrow \lc{Z M} \sim \lc{Z N}\\
  &\lc{\x.M} \sim \lc{\y.M}[\lc{x}:=\lc{y}] &(\alpha\text{-conversión})\\
  &\lc{(\x.M)N} \sim \lc{M}[\lc{x}:=\lc{N}] &(\beta\text{-conversión})\\
  &\lc{M} \sim \lc{N} \Rightarrow \lc{\x.M} \sim \lc{\x.N} &(\text{regla } \xi)
\end{align}

\textbf{CLARIFICAR DIFERENCIAS SOBRE LAS TEORÍAS Y SUS NOMBRES}\\

\textbf{DESCRIBIR LÓGICA COMBINATORIA Y LA TEORIA LAMBDA I}

\section{Representaciones} \label{sec:1.3}

\subsection{Álgebra booleana} \label{sec:1.3.1}

\subsection{Aritmética} \label{sec:1.3.2}

\subsection{Estructuras complejas} \label{sec:1.3.3}

\subsection{Técnicas de representación} \label{sec:1.3.4}

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: "main"
%%% End: