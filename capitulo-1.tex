El cálculo lambda es un sistema formal originalmente creado por Alonzo Church en 1932 \cite{Church:FoundationsLogic} con la finalidad de expresar, manipular y estudiar funciones para el desarrollo de los fundamentos de la lógica y las matemáticas \cite[p.~248]{Church:FoundationsLogic}. A lo largo de la historia, este sistema se ha adaptado para el estudio de los fundamentos de la computación y como sustento teórico para el desarrollo de lenguajes de programación.

Tres características fundamentales del cálculo lambda son el lenguaje utilizado para describir expresiones; la interpretación, representación y manejo de funciones; y las nociones de transformación y equivalencia de expresiones.

Este capítulo consiste de dos secciones: primero se introduce informalmente el cálculo lambda, en donde se enfatiza las diferencias conceptuales, operacionales y de notación entre este sistema, la matemática clásica y la lógica de primer orden; en la segunda sección se presenta la formalización del cálculo lambda.

El contenido de este capítulo está basado en los primeros cuatro capítulos del libro \emph{The Lambda Calculus, Its Syntax and Semantics} por H.P. Barendregt \cite{Barendregt:Bible} y los capítulos 1, 3, 6, 7 y 8 del libro \emph{Lambda Calculus and Combinators, an Introduction} por J.R. Hindley y J.P. Seldin \cite{HindleySeldin:LambdaCalculusAndCombinators}.

\section{Noción informal del cálculo lambda}
\label{sec:informal}

En el estudio del cálculo lambda existen dos lenguajes, el de las expresiones del sistema y el que se utiliza para describir y analizar estas expresiones, llamado metalenguaje.

El lenguaje de las expresiones es un \emph{lenguaje formal} que especifica las secuencias de símbolos que representan expresiones válidas del cálculo lambda, se relaciona con las clases de objetos del sistema que son válidos manipular, comparar y representar. Por otro lado, el metalenguaje permite describir \emph{cómo} es que estas expresiones son manipuladas y comparadas, así como los mecanismos para representar conceptos y objetos matemáticos como expresiones.

\subsection{Expresiones}
\label{sec:expresiones}

Existen tres clases de expresiones en el cálculo lambda: \emph{átomos}, \emph{abstracciones} y \emph{aplicaciones}.

Las expresiones más simples son los átomos, usualmente representados con un símbolo como \( x \), \( y \) o \( z \). Estas expresiones también son llamadas variables y al igual que en la matemática clásica y la lógica de primer orden, no tienen mucha importancia por sí solas, pero al estar asociadas a cuantificadores (\( \forall x \) y \( \exists x \)) o a funciones (\( f(x) \)) pueden representar valores complejos.

Las abstracciones y aplicaciones son expresiones con estructura, es posible identificar y referirse a sus partes. Estos son complementarias: las abstracciones representan la generalización de una expresión y se asocian al concepto de \emph{función}, mientras que las aplicaciones representan el acto de concretar una expresión y se asocian al concepto de \emph{aplicación de funciones}.

La definición de función en la matemática clásica es el de una relación entre un conjunto de entradas, llamado \emph{dominio} y un conjunto de salidas, llamado \emph{codominio}. Esta relación tiene además la propiedad de que cada elemento del dominio se asocia exactamente con un elemento del codominio, formalmente, sean \( A \) y \( B \) dos conjuntos, una función \( f \) con dominio \( A \) y codominio \( B \) es un subconjunto del producto cartesiano \( A \times B \), tal que para toda \( a \in A \), existe \( b \in B \) tal que \( (a,\ b) \in f \) y si \( (a,\ b^{\prime}) \in f \) con \( b^{\prime} \in B \), entonces \( b=b^{\prime} \).

Las funciones tienen varias maneras de ser representadas. En la definición anterior la representación es la de pares ordenados, en donde la primer componente del par es un elemento en el dominio y la segunda es un elemento en el codominio. Dependiendo del uso que se le dá a las funciones, puede ser conveniente representarlas simbólicamente con expresiones, gráficamente con dibujos, numéricamente con tablas o incluso verbalmente con palabras.

Las abstracciones en el cálculo lambda son representadas simbólicamente con un átomo y con otra expresión, se escriben de la forma \( (λx.M) \) donde \( x \) es algún átomo llamado variable enlazada o argumento y \( M \) es alguna expresión ya sea otra abstracción, una aplicación o un átomo a la cual llamamos cuerpo de la abstracción.

Debido a la notación utilizada puede parecer que las abstracciones se relacionan directamente con las funciones \( f(x)=M \) o con fórmulas lógicas \( \forall x\ M \). Sin embargo, tanto las expresiones de funciones como las fórmulas lógicas están basadas en conjuntos y en operaciones sobre estos conjuntos, en contraste con el cálculo lambda, por definición no existen conjuntos, números, valores de verdad ni cuantificadores lógicos en el lenguaje.

Es posible utilizar la definición de función para \emph{describir} operaciones y transformaciones de expresiones en el cálculo lambda, o utilizar lógica de primer orden para aseverar verdades en el sistema, o cuantificar propiedades de las expresiones utilizando números, sin embargo estos objetos matemáticos no están incrustados en el lenguaje de las expresiones y conforman lo que es el metalenguaje.

Las aplicaciones son expresiones conformadas a partir de otras dos expresiones, se escriben de la forma \( (M N) \) donde \( M \) y \( N \) son cualesquiera átomos, abstracciones o aplicaciones. El concepto relacionado con las aplicaciones en la matemática clásica es el del acto de obtener un elemento del codominio de una función a partir de un elemento en su dominio, por ejemplo, considerando la función \( f(x)=x^{2} \), la aplicación de \( f \) en \( 4 \) es \( f(4) \).  La notación del cálculo lambda es similar a la notación tradicional \( f(x) \), solo que con el paréntesis abierto antes de la función, es decir, \( (f x) \). De manera similar a la aplicación de funciones, existe una operación la cual permite transformar expresiones de la forma \( (M N) \) donde \( N \) es cualquier expresión y \( M \) es una abstracción, a otra expresión \( Z \) similar al cuerpo de \( M \) pero con el argumento de \( M \) intercambiado por \( N \).

Las abstracciones y aplicaciones del cálculo lambda son en algunos aspectos más restrictivos que las funciones y la aplicación de funciones. La función considera dos conjuntos cualquiera y no importa que propiedades tengan sus elementos o que operaciones se pueden realizar sobre ellos. Por otro lado, las abstracciones y aplicaciones sólo pueden ser descritas a partir de otras expresiones del cálculo lambda.

Cuando se desea representar alguna función en el cálculo lambda, se deben \emph{codificar} como expresiones del lenguaje los elementos del dominio y el codominio de la función, así como las operaciones entre elementos de ambos conjuntos. Por ejemplo, para representar la función \( f \colon \mathbb{N} \to \mathbb{N} \) dada por \( f(x)=x^{2} \) primero se deben codificar los números naturales con expresiones del cálculo lambda, esta codificación debe ser acompañada de la codificación de las operaciones aritméticas elementales como la suma y resta así como de los predicados sobre números naturales como discriminar entre el mayor de dos números o si un número es cero; posteriormente se debe expresar la operación de exponenciación de cualquier número natural como base y el número \( 2 \) como exponente.

El hecho de tener un lenguaje tan reducido y minimalista para las expresiones del cálculo lambda nos permite entender con detalle y precisión todos los procesos de manipulación y transformación de expresiones y siendo que todo lo que se representa con el cálculo lambda debe ser codificado como expresiones, los objetos representados pueden ser entendidos de la misma manera.

Con solo átomos, aplicaciones y abstracciones se pueden formular expresiones complejas. A continuación se presentan seis ejemplos de expresiones y se describen diferentes maneras en las cuales estas se pueden componer para formar otras expresiones más complejas.

\begin{exmp}
  Algunas expresiones del cálculo lambda
  \label{exmp:expresiones}
  \begin{subequations}
    \begin{gather}
      \label{eq:expresiones:a} \tag{a}
      x \\
      \label{eq:expresiones:b} \tag{b}
      (λx.x) \\
      \label{eq:expresiones:c} \tag{c}
      (y(λx.x)) \\
      \label{eq:expresiones:d} \tag{d}
      ((λy.(y(λx.x)))(λw.w)) \\
      \label{eq:expresiones:e} \tag{e}
      (λx.(x x)) \\
      \label{eq:expresiones:f} \tag{f}
      (λf.(λx.(f(f x))))
    \end{gather}
  \end{subequations}
\end{exmp}


Los átomos por si solos son expresiones válidas, en el inciso \eqref{eq:expresiones:a} aparece el átomo \( x \), como tal no tiene mucha utilidad, no podemos decir que toma valores en algún conjunto o que representa algún valor en particular como falso o verdadero, es tan sólo un símbolo. Al ser parte de otra expresión, un átomo puede tener más relevancia, en el inciso \eqref{eq:expresiones:b} el átomo \( x \) en el cuerpo de la abstracción \( (λx.x) \) y ahora tiene el potencial de ser cambiado por cualquier otra expresión debido a que también es el argumento.

En el inciso \eqref{eq:expresiones:c} se tiene la aplicación del átomo \( y \) en la abstracción del inciso \eqref{eq:expresiones:b}. A pesar de ser contraintuitivo, las expresiones de aplicación se componen de dos expresiones cualesquiera, por lo tanto, a pesar de estar asociada conceptualmente con la aplicación de funciones, la expresión \( (y(λx.x)) \) es válida. La expresión del inciso \eqref{eq:expresiones:d} contiene la expresión anterior en una abstracción en la primer parte de la aplicación y nos permite observar dos ideas importantes: primero, las abstracciones pueden ser aplicadas a abstracciones; segundo, al realizar la operación de aplicar \( (λy.(y(λx.x))) \) a \( (λw.w) \), el átomo \( y \) es intercambiado por la expresión \( (λw.w) \) la cual a su vez puede ser aplicada a la expresión \( (λx.x) \).

\begin{exmp}
  Procedimiento de aplicar \( (λy.(y(λx.x))) \) en \( (λw.w) \)
  \label{exmp:aplicacion}
  \begin{align*}
    \text{1. } & ((λy.(y(λx.x)))(λw.w)) & \text{expresión del inciso \eqref{eq:expresiones:d}} \\
    \text{2. } & ((λw.w)(λx.x)) & \text{al aplicar \( (λy.(y(λx.x))) \) a \( (λw.w) \)} \\
    \text{3. } & (λx.x) & \text{al aplicar \( (λw.w) \) a \( (λx.x) \)}
  \end{align*}
\end{exmp}

En el inciso \eqref{eq:expresiones:e} se presenta una abstracción cuyo cuerpo es la aplicación de su argumento sobre sí mismo. Lo interesante de esta expresión es que es que encapsula la idea de replicar a partir de la aplicación cualquier expresión a la que sea aplicada. Por ejemplo, si aplicamos \( (λx.(x x)) \) al átomo \( y \) y se realiza el procedimiento de aplicación como en el ejemplo \ref{exmp:aplicacion}, se obtiene \( (y y) \) y en general al realizar la operación de aplicación sobre \( ((λx.(x x))M) \) donde \( M \) es cualquier expresión, se obtiene \( (M M) \). Con ésta expresión se puede formular una expresión auto-replicante en el cálculo lambda:

\begin{exmp}
  Procedimiento de aplicar \( (λx.(x x)) \) a \( (λx.(x x)) \)
  \label{exmp:aplicacion2}
  \begin{align*}
    \text{1. } & ((λx.(x x))(λx.(x x))) & \text{expresión del inciso \eqref{eq:expresiones:e} aplicada a sí misma} \\
    \intertext{\centering En \( (x x) \) se cambia cada \( x \) por \( (λx.(x x)) \)}
    \text{2. } & ((λx.(x x))(λx.(x x))) & \text{resultado del procedimiento.}
  \end{align*}
\end{exmp}

A este tipo de expresiones se les llaman ``quines'' \cite[pp.~431--437]{Hofstadter:GEB} término originalmente asociado a una paradoja sobre sistemas lógicos \cite{Quine:Paradox}. En la actualidad, el término ``quine'' hace referencia a un programa cuya \emph{salida} es el programa mismo.

En el inciso \eqref{eq:expresiones:f} se tiene una abstracción cuyo cuerpo es otra abstracción. El concepto interesante que ilustra esta expresión es el de la representación de funciones de varias variables. Al realizar la operación de abstracción de \( (λf.(λx.(f(f x)))) \) a una expresión cualquiera \( M \) se obtiene \( (λx.(M(M x))) \). Si posteriormente se realiza la aplicación de este resultado a una expresión cualquiera \( N \) se obtiene \( (M(M N)) \), esto sería similar al resultado que se obtendría de aplicar una función con argumentos \( f \) y \( x \), con cuerpo \( f(f(x)) \) a dos valores de su dominio \( M \) y \( N \).

Otra manera de representar funciones de varias variables como abstracciones del cálculo lambda es codificando \emph{tuplas} o \emph{secuencias} y poder hacer referencia a sus elementos de manera individual en el sistema, sin embargo, representar secuencias es un mecanismo más complejo que se aborda en el siguiente capítulo.

\subsection{Operaciones}
\label{sec:operaciones}

En el cálculo lambda se pueden realizar algunas operaciones para transformar expresiones, estas operaciones son parte del metalenguaje y consisten de una serie de cambios mecánicos a la estructura de las expresiones de acuerdo a un criterio particular.

En la subsección anterior se mencionan dos operaciones que se abordaron tangencialmente: el intercambio en una expresión de un átomo por otra expresión y la operación de aplicación de abstracciones.

La \emph{sustitución} es la operación que nos permite transformar una expresión cualquiera \( M \) intercambiando las apariciones de un átomo \( x \) por alguna otra expresión \( M \), este procedimiento se denota

\[ \subst{M}{x}{N} \]


En muchos casos la operación de sustitución se puede realizar de manera trivial: \\

\begin{exmp}
  Sustituciones sencillas
  \label{exmp:sustituciones}
  \begin{align}
    \label{eq:sustituciones:a} \tag{a}
    \subst{x}{x}{y} & = y \\
    \label{eq:sustituciones:b} \tag{b}
    \subst{(x(x(λy.y)))}{x}{z} & = ((z z)(λy.y)) \\
    \label{eq:sustituciones:c} \tag{c}
    \subst{\subst{(((w x)y)z)}{x}{a}}{y}{b} & = (((w a)b)z) \\
    \label{eq:sustituciones:d} \tag{d}
    \subst{(x x)}{x}{(λw.w)} & = ((λw.w)(λw.w))
  \end{align}
\end{exmp}

Existen algunos detalles de la sustitución que se deben tomar en cuenta para evitar obtener expresiones erróneas, en particular cuando se sustituye en expresiones que contienen abstracciones. Para ilustrar estos casos especiales, consideremos la abstracción lambda análoga a la función constante \( (λx.y) \), la cual al ser aplicada a cualquier otra expresión, resultará siempre en el átomo \( y \). Si se realiza la operación \( \subst{(λx.y)}{y}{z} \) se obtiene la expresión \( (λx.z) \) la cual también es análoga a la función constante pero con el átomo \( z \). Si no se tiene cuidado, sustituir un átomo por otro en esta abstracción puede resultar en una expresión con diferente interpretación.

\begin{exmp}
  Caso patológico de la sustitución ingenua
  \label{exmp:sustitucion3}

  \[ \subst{(λx.y)}{y}{x} \]

  Se puede pensar que el resultado es \( (λx.x) \) la cuál es análoga a la función identidad, sin embargo, la sustitución no permite cambiar las expresiones de esta manera.
\end{exmp}

Para entender la operación de sustitución se tiene que pensar que lo que le da sentido a un átomo \( x \) es una \( λ x \). Consideremos la expresión

\[ (λx.(λy.((x y)z))) \]

el átomo \( x \) que aparece en el cuerpo de la expresión se dice ser una variable \emph{ligada} a la \( λ x \), la cual se puede pensar como una especie de ``referencia'' a la expresión a la que la abstracción es aplicada, esto limita a la operación de sustitución a no romper la referencia de una variable ligada. De igual manera, el átomo \( y \) es una variable ligada a la \( λ y \) y debe mantener su referencia bajo la operación de sustitución. Sin embargo, el átomo \( z \) es lo que se llama variable \emph{libre}: No está en el \emph{alcance} de alguna \( λ z \) y puede ser libremente sustituida por alguna otra expresión.

En el ejemplo \ref{exmp:sustitucion3} se pretende sustituir la variable libre \( y \) por una expresión \( x \), lo cual no debería presentar problemas, sin embargo, una sustitución tal cual de \( y \) por \( x \) introduciría una referencia a la \( λ x \) de la expresión, la cuál no existía previamente. Con esto se identifica que la operación de sustitución \( \subst{M}{x}{y} \) no debe introducir o eliminar referencias a alguna \( λ \) en \( M \).


Para resolver el problema presentado en el ejemplo \ref{exmp:sustitucion3} se debe considerar otra operación llamada \emph{cambio de variable ligada}. Se parte de la observación que en una expresión del cálculo lambda, las referencias entre \( λ x \) y los átomos \( x \) (para cualquier átomo \( x \)) es más importante que el símbolo con el que se representa el átomo. En las expresiones simbólicas de funciones sucede lo mismo, al expresar \( f(x)=x^{2} \) y \( f(y)=y^{2} \) hacemos referencia a la misma regla de correspondencia y por lo tanto a la misma función (sin considerar el dominio y el codominio de \( f \)). En el cálculo lambda, cambiar el símbolo que representa el átomo \( x \) en la expresión \( (λx.y) \) por otro símbolo no utilizado como \( z \) nos permite realizar la sustitución sin problemas.

\begin{exmp}
  Procedimiento de sustitución para el ejemplo \ref{exmp:sustitucion3}
  \label{exmp:sustitucion4}
  \begin{align*}
    \text{1. } & \subst{(λx.y)}{y}{x} & \\
    \text{2. } & \subst{(λz.y)}{y}{x} & \text{después de realizar un cambio de variable ligada} \\
    \text{3. } & (λz.x) & \text{resultado del procedimiento de sustitución}
  \end{align*}
\end{exmp}

Cuando se realiza un cambio de variable ligada sobre una abstracción \( (λx.M) \) se cambia tanto el átomo \( x \) acompañado por la \( λ \), llamada variable \emph{enlazada} como todas las apariciones del átomo en el cuerpo de la abstracción, también llamado \emph{alcance de} \( λ x \). En el ejemplo \ref{exmp:sustitucion4} el cambio de variable ligada únicamente cambió la variable enlazada, en otras expresiones el cambio de variable ligada puede realizarse múltiples veces para transformar varias abstracciones.

\begin{exmp}
  Múltiples cambios de variable ligada
  \label{exmp:variableligada}
  \begin{align*}
    \text{1. } & (λf.(λx.(f(f(f x))))) & \\
    \text{2. } & (λg.(λx.(g(g(g x))))) & \text{Cambiando \( f \) por \( g \)} \\
    \text{3. } & (λg.(λy.(g(g(g y))))) & \text{Cambiando \( x \) por \( y \)}
  \end{align*}
\end{exmp}

El cambio de variable ligada en una abstracción \( (λx.M) \) de \( x \) a \( y \) resulta en la abstracción

\[ (λy.\subst{M}{x}{y}) \]

La definición de la operación de sustitución es recursiva y hace uso de la operación de cambio de variable ligada, considerando a \( x \), \( y \), \( z \) como átomos diferentes y \( M \), \( N \) y \( P \) como expresiones cualquiera diferentes:

\begin{itemize}
\item \( \subst{x}{x}{M} \) resulta en \( M \);
\item \( \subst{y}{x}{M} \) resulta en \( y \);
\item \( \subst{(M N)}{x}{P} \) resulta en \( (\subst{M}{x}{P} \subst{N}{x}{P}) \);
\item \( \subst{(λx.M)}{x}{N} \) resulta en \( (λx.M) \) debido a que las referencias a \( x \) no deben eliminarse;
\item \( \subst{(λy.M)}{x}{N} \) resulta en:
  \begin{itemize}
  \item \( (λy.M) \) cuando \( x \) no es una variable libre en \( M \),
  \item \( (λy.\subst{M}{x}{N}) \) cuando \( x \) es una variable libre en \( M \) pero \( y \) no es una variable libre en \( N \) debido a que esto introduciría una referencia a \( λ y \),
  \item \( (λz.\subst{\subst{M}{y}{z}}{x}{N}) \) cuando \( x \) es una variable libre en \( M \) y \( y \) es una variable libre en \( N \).
  \end{itemize}
\end{itemize}

La operación de \emph{aplicación de abstracciones} es el mecanismo mediante el cual se puede ``concretar'' una abstracción haciendo uso de otra expresión como valor de la variable enlazada. De la misma manera en como se efectúa la aplicación de funciones en la matemática clásica, el concretar una función consiste en sustituir todas las apariciones del argumento por el valor en el que la función es aplicada.

La definición de la aplicación de una abstracción \( (λx.M) \) en una expresión \( N \) es

\[ \subst{M}{x}{N} \]

A continuación se presentan ejemplos de aplicación de abstracciones con los pasos de la transformación

\begin{exmp}
  Procedimiento de aplicación de \( (λx.x) \) a \( y \)
  \label{exmp:aplicacion6}
  \begin{align*}
    \text{1. } & ((λx.x) y) \\
    \text{2. } & \subst{x}{x}{y} \\
    \text{3. } & y
  \end{align*}
\end{exmp}

\begin{exmp}
  Procedimiento de aplicación de \( (λw.w) \) a \( x \)
  \label{exmp:aplicacion7}
  \begin{align*}
    \text{1. } & (λx.((λw.w)x)) \\
    \text{2. } & (λx.\subst{w}{w}{x}) \\
    \text{3. } & (λx.x)
  \end{align*}
\end{exmp}

\begin{exmp}
  Procedimiento de múltiples aplicaciones
  \label{exmp:aplicacion8}
  \begin{align*}
    \text{1. } & (((λf.(λx.(f(f(f x))))) g) y) \\
    \text{2. } & ((λx.\subst{(f(f(f x)))}{f}{g}) y) \\
    \text{3. } & ((λx.(g(g(g x)))) y) \\
    \text{4. } & \subst{(g(g(g x)))}{x}{y} \\
    \text{5. } & (g(g(g y)))
  \end{align*}
\end{exmp}

El cálculo lambda es un sistema maleable y se permite definir operaciones arbitrarias sobre expresiones para estudiar como el sistema se comporta en diferentes contextos, por ejemplo, se puede considerar una operación similar a la sustitución que permite introducir referencias a una o más \( λ \) en una expresión, sin embargo, el presente trabajo está constituido para entender plenamente las ideas centrales del cálculo lambda haciendo solamente uso de las operaciones de \emph{sustitución}, \emph{cambio de variable ligada} y \emph{aplicación de abstracciones}.

\subsection{Equivalencias}
\label{sec:equivalencias}

El cálculo lambda se considera formalmente como una \emph{teoría ecuacional}, esto significa que los axiomas del sistema formal son ecuaciones que relacionan expresiones del lenguaje. Esto hace que el concepto de \emph{equivalencia} de expresiones sea de suma importancia.

Es tan relevante la formalización de las nociones de equivalencia que considerar alguna equivalencia entre dos expresiones que se escriben diferente puede cambiar por completo el sistema formal que se estudia. En el desarrollo histórico del cálculo lambda, el estudio de los criterios que permiten establecer que dos expresiones son equivalentes ha dado pie a una gran diversidad de variantes de la teoría original; es por ello que en la literatura se suele hablar de \emph{los cálculos lambda} y no únicamente de un cálculo lambda.

Como se aborda en la subsección anterior, con la operación de sustitución se puede transformar expresiones del cálculo lambda y definir otras operaciones como el cambio de variable ligada y la aplicación de abstracciones. Usualmente, las transformaciones de expresiones se pueden asociar a nociones de equivalencia. En terminología del cálculo lambda, las nociones de equivalencia entre expresiones son asociadas a la propiedad de \emph{convertibilidad}, la cual significa que si dos expresiones \( M \) y \( N \) son equivalentes en el sistema, es posible transformar \( M \) a \( N \) y viceversa por medio de un número finito de operaciones.

La \emph{equivalencia sintáctica} es una relación binaria entre expresiones que no está asociada a una transformación. Se considera como una equivalencia trivial, ya que asevera la igualdad entre dos expresiones que son escritas exactamente igual, símbolo por símbolo a excepción de abusos de notación. Por ejemplo, la expresión \( \sin^{2}(x) \) es un abuso de notación de \( \left( \sin(x) \right)^{2} \) y ambas son sintácticamente iguales.  En el cálculo lambda, la equivalencia sintáctica es denotada como \( M \synteq N \) cuando \( M \) es sintácticamente la misma expresión que \( N \).

Todos los cálculos lambda, al igual que la mayoría de los sistemas formales, comprenden la noción de equivalencia sintáctica. Sin embargo las equivalencias más interesantes son las que involucran transformaciones entre expresiones.

La operación de cambio de variable ligada se relaciona con una equivalencia estructural entre dos expresiones. Cuando se realiza esta operación no se modifica la estructura de la expresión, únicamente se modifica el símbolo usado para representar un átomo. Considerando la expresión que representa a la función identidad \( (λx.x) \) se observa que tiene la misma estructura que la abstracción \( (λy.y) \) y que \( (λz.z) \), estas tres representan el mismo concepto. De igual manera otras expresiones como \( ((x y)z) \) o \( (λw.x) \) son estructuralmente equivalentes a \( ((a b)c) \) y \( (λf.h) \) respectivamente. A pesar de que no se escriben sintácticamente igual, la correspondencia que hay entre las posiciones de los átomos en una y otra expresión nos permite considerarlas como equivalentes. Sin embargo, la operación de cambio de variable ligada no considera cambios de nombres a átomos que sean variables libres. Esta relación de equivalencia es llamada \( α \)-convertibilidad y se denota como \( M \convertible{α} N \) para dos expresiones del cálculo lambda \( M \) y \( N \) en donde a partir de un número finito de cambios de variables ligadas en \( M \) o parte de \( M \) y en \( N \) o parte de \( N \) se puedan obtener expresiones sintácticamente equivalentes.

Una técnica utilizada por algoritmos que verifican si dos expresiones \( M \) y \( N \) son \( α \)-convertibles es la de \emph{índices de De Bruijn}, esta transformación cambia la aparición de átomos por números naturales que representan la ``distancia'' de los átomos a las \( λ \) que hacen referencia.

\begin{exmp}[índices de De Bruijn]
  \label{exmp:indices-debrujn}
  La expresión \( (λz.((λy.(y(λx.x)))(λx.(z x)))) \) se escribe usando índices de De Bruijn como
  \label{exmp:debrujn}

  \[ λ (λ 1 (λ 1)) (λ 2\ 1) \]

  En la figura \ref{fig:debrujn} se puede observar de manera gráfica la transformación de una notación a otra para este ejemplo, visualizando las expresiones del cálculo lambda como árboles.
\end{exmp}

\begin{figure}
  \centering

  \begin{tikzpicture}[level/.style={sibling distance=60mm/#1}]
    \node [draw] (term) {\( (λz.((λy.(y (λx.x))) (λx.(z x)))) \)};
    \node [below of=term] (arrow1) {\( \Downarrow \)};
    \node [circle,draw,below of= arrow1] (z) {\( λ z \)}
      child {
        node [circle,draw] (a) {\( λ y \)}
        child {
          node [circle,draw] (c) {\( y \)}
        }
        child {
          node [circle,draw] (d) {\( λ x \)}
          child {
            node [circle,draw] (g) {\( x \)}
          }
        }
      }
      child {
        node [circle,draw] (b) {\( λ x \)} 
        child {
          node [circle,draw] (e) {\( z \)}
        } 
        child {
          node [circle,draw] (f) {\( x \)}
        }
      };
      \node [below=130pt of z] (arrow2) {\( \Downarrow \)};
      \node [circle,draw,below of= arrow2] (z2) {\( λ \)}
      child {
        node [circle,draw] (a2) {\( λ \)} 
        child {
          node [circle,draw] (c2) {\( 1 \)}
        }
        child {
          node [circle,draw] (d2) {\( λ \)} 
          child {
            node [circle,draw] (g2) {\( 1 \)}
          }
        }
      }
      child {
        node [circle,draw] (b2) {\( λ \)} 
        child {
          node [circle,draw] (e2) {\( 2 \)}
        }
        child {
          node [circle,draw] (f2) {\( 1 \)}
        }
      };
      \node [below=130pt of z2] (arrow3) {\( \Downarrow \)};
      \node [draw,below of=arrow3](bruijn) {\( λ (λ 1 (λ 1)) (λ 2\ 1) \)};
  \end{tikzpicture}
  
  \caption{Transformación gráfica del ejemplo \ref{exmp:debrujn}}
  \label{fig:debrujn}
\end{figure}

Una desventaja de utilizar la notación de De Bruijn es que ciertas expresiones del cálculo lambda no pueden ser escritas, en particular, los átomos no pueden ser variables libres para que esta transformación pueda ser realizada.

Al igual que el cambio de variable ligada, la operación de aplicación de abstracciones es utilizada para describir una equivalencia entre expresiones. La noción básica de esta equivalencia consiste en observar que al aplicar una abstracción \( (λx.M) \) a una expresión \( N \), el resultado de dicha operación siempre es el mismo. De manera similar a la aplicación de funciones, cuando se define una función \( f(x)=x^{2} \), la aplicación \( f(3) \) se suele igualar al resultado de la aplicación: \( f(3)=8 \).

Esta relación de equivalencia es llama \( β \)-convertibilidad y se denota como \( M \convertible{β} N \) para dos expresiones \( M \) y \( N \) en donde a partir de un número finito de aplicaciones de abstracciones, cambios de variable ligada o el proceso inverso de aplicación de abstracciones en \( M \) o parte de \( M \) y \( N \) o parte de \( N \) se puedan obtener expresiones sintácticamente equivalentes.

Es importante enfatizar que la \( β \)-convertibilidad considera el proceso inverso de la aplicación de abstracciones, por ejemplo

\[ (f(f(f x))) \convertible{β} (((λg.(λy.(g (g (g y))))) f) x) \]

Todas las relaciones de equivalencia por definición cumplen con tres propiedades:

\begin{enumerate}[a.]
\item Toda expresión \( M \) es equivalente a sí misma. \label{enum:rela:a}
\item Si una expresión \( M \) es relacionada con una equivalencia a otra expresión \( N \), entonces \( N \) también es relacionada a \( M \). \label{enum:rela:b}
\item Si una expresión \( M \) se relaciona con una equivalencia a otra expresión \( N \) y \( N \) se relaciona con la misma equivalencia a \( P \), entonces, \( M \) y \( P \) se relacionan con esta equivalencia. \label{enum:rela:c}
\end{enumerate}

La equivalencia sintáctica corresponde al inciso \ref{enum:rela:a} de las propiedades de equivalencias mencionadas y es llamada propiedad de \emph{reflexividad}; al igual que la \( α \)-conversión y la \( β \)-conversión, la equivalencia sintáctica no está asociada a una regla de inferencia. En los incisos \ref{enum:rela:b} y \ref{enum:rela:c} se tienen propiedades que parten de expresiones equivalentes y basado en si estas expresiones son equivalentes o no, ciertas propiedades se deben cumplir. En el inciso \ref{enum:rela:b} la propiedad es llamada \emph{simetría}, mientras que en el inciso \ref{enum:rela:c} la propiedad es llamada \emph{transitividad}.

La \( α \)-conversión y la \( β \)-conversión fueron definidas como equivalencias independientes y su definición cumple con las tres propiedades mencionadas a pesar de ser definidas en base a un procedimiento y no en una regla declarativa, sin embargo, es deseable referirse a una sola equivalencia de expresiones que tenga las propiedades de \emph{reflexividad}, \emph{simetría} y \emph{transitividad} y posteriormente considerar otras reglas que la equivalencia deba de cumplir.

Al igual que Haskell Curry en \cite[p.~59]{Curry:CombinatoryLogicI} se utilizan las letras griegas \( α \) y \( β \) para referirse a las ecuaciones relacionadas con la \( α \)-conversión y \( β \)-conversión respectivamente y las letras \( ρ \), \( σ \) y \( τ \) para referirse a las propiedades de reflexividad, simetría y transitividad respectivamente, se retoma esta convención para elaborar la siguiente definición de una relación de equivalencia \( \sim \):

\begin{defn}[Ecuaciones de \( \sim \)]
  Las ecuaciones con \( \sim \) que se satisfacen para expresiones del cálculo lambda son
  \label{defn:sim}
  \begin{subequations}
    \begin{align}
      \label{sim:alpha} \tag{\( α \)}
      (λx.M) & \sim (λy.\subst{M}{x}{y}) \\
      \label{sim:beta} \tag{\( β \)}
      ((λx.M)N) & \sim \subst{M}{x}{N} \\
      \label{sim:rho} \tag{\( ρ \)}
      M & \sim M \\
      \label{sim:sigma} \tag{\( σ \)}
      M \sim N & \implies N \sim M \\
      \label{sim:tau} \tag{\( τ \)}
      M \sim N,\ N \sim P & \implies M \sim P
    \end{align}
  \end{subequations}
\end{defn}

Las ecuaciones en la definición \ref{defn:sim} son muy parecidas a las propiedades de la \( β \)-conversión, con la excepción de que la \( β \)-conversión relaciona expresiones en donde sus partes fueron transformadas y \( \sim \) no, por ejemplo

\[ (λf.((λx.(f x)) y)) \convertible{β} (λf.(f y)) \]

pero

\[ (λf.((λx.(f x)) y)) \nsim (λf.(f y)) \]

Para capturar la definición de \( β \)-convertibilidad con ecuaciones, es necesario definir a \( \sim \) en partes de una expresión. Las siguientes reglas, nombradas por Curry \cite[p.~59]{Curry:CombinatoryLogicI} como \( ν \), \( μ \) y \( ξ \), junto con las reglas de \(\sim\) completan la definición declarativa de \(\beta\)-convertibilidad:

\begin{defn}
  Reglas que debe cumplir \( \sim \) para ser \( \convertible{β} \)
  \label{defn:simbeta}
  \begin{subequations}
    \begin{align}
      \label{simbeta:nu} \tag{\( ν \)}
      M \sim N & \implies (M Z) \sim (N Z) \\
      \label{simbeta:mu} \tag{\( μ \)}
      M \sim N & \implies (Z M) \sim (Z N) \\
      \label{simbeta:xi} \tag{\( ξ \)}
      M \sim N & \implies (λx.M) \sim (λx.N)
    \end{align}
  \end{subequations}
\end{defn}

Con estas reglas, las inferencias lógicas nos permiten abordar la equivalencia sobre partes de una expresión.

\begin{exmp}
  Razonamiento para concluir que \( (λf.((λx.(f x)) y)) \sim (λf.(f y)) \)
  \label{exmp:razonamiento-sim}
  \begin{align*}
    \text{1. } & ((λx.(f x)) y) \sim (f y) & & \text{por \( β \)} \\
    \text{2. } & (λf.((λx.(f x)) y)) \sim (λf.(f y)) & & \text{por \( ξ \)}
  \end{align*}
\end{exmp}

Es posible incluir aún más reglas de equivalencia cuando se estudia el cálculo lambda, a pesar de poder trabajar con expresiones en este sistema a partir de equivalencias arbitrarias, usualmente cada regla de equivalencia se asocia con alguna argumentación basada en la noción de función.

Por ejemplo, se pueden considerar dos abstracciones diferentes \( (λx.M) \) y \( (λy.N) \) que al ser aplicadas a cualquier expresión \( Z \) sean \( β \)-convertibles a una misma expresión \( W \). Si se relacionan las abstracciones del cálculo lambda con funciones, es natural pensar que \( M \) y \( N \) sean equivalentes, ya que por definición, dos funciones \( f \) y \( g \) son equivalentes si para toda \( x \) en su dominio \( f(x)=g(x) \). Por ejemplo, las funciones \( f(n)=\sum_{i=0}^{n}i \) y \( g(n)=\frac{n(n+1)}{2} \) a pesar de describir dos procedimientos diferentes para el cálculo de la suma de los primeros \( n \) números naturales son ``funcionalmente'' equivalentes ya que para todo natural \( f(n)=g(n) \). Por otro lado, si se relacionan las abstracciones del cálculo lambda con algoritmos, \( M \) y \( N \) no pudieran ser consideradas equivalentes ya que en el estudio de la complejidad algorítmica, el énfasis en la comparación entre dos procedimientos no es las entradas y salidas, si no el proceso que describen. Por ejemplo, el algoritmo de ordenamiento \emph{merge sort} logra ordenar una secuencia de \( n \) números de menor a mayor en \( \mathcal{O}(n \log n) \) mientras que el algoritmo \emph{bubble sort} computa el mismo resultado pero en \( \mathcal{O}(n^2) \).  La equivalencia ``funcional'' se pudiera incluír en la definición de \( \sim \) añadiendo la siguiente regla:

\[ (M P) \sim (N P) \implies M \sim N \]

Con esto se termina la introducción informal al cálculo lambda, las ideas que se han manejado en esta sección serán ahora formalizadas y definidas de manera rigurosa.

\section{Formalización del cálculo lambda}
\label{sec:formalizacion}

La teoría del cálculo lambda se puede formalizar de diferentes perspectivas, en este trabajo se abordan dos: a partir de la \emph{reducibilidad y convertibilidad} de expresiones y a partir de \emph{sistemas formales}. La primera consiste en definir transformaciones de expresiones mediante procedimientos, mientras que la segunda define axiomas y reglas de inferencia.

Independientemente de la perspectiva de la formalización, los conceptos son los mismos y las definiciones equivalentes. En ambos casos se formaliza la teoría \( \bs{λ} \), también llamado cálculo-\( λ K β \).

De acuerdo a Barendregt \cite[p.~22]{Barendregt:Bible}, el objeto de estudio principal de la teoría \( \bs{λ} \) es el conjunto de términos lambda módulo convertibilidad, estas nociones serán presentadas en las siguientes subsecciones.

\subsection{Términos lambda}
\label{sec:terminos-lambda}

Esta subsección está basada principalmente en el capítulo 2 de \cite{Barendregt:Bible}.

Los \emph{términos lambda} son las \emph{fórmulas bien formadas} del cálculo lambda, es decir, las expresiones válidas del sistema. El conjunto de todos los términos lambda es un lenguaje formal, denotado como \( Λ \).

El lenguaje \( Λ \) se puede definir de diferentes maneras, a continuación se presenta una definición inductiva y posteriormente una construcción a partir de una gramática libre de contexto.

\begin{defn}[Términos lambda]
  El conjunto \( Λ \) tiene elementos que son cadenas conformadas por símbolos en el alfabeto \( Σ=\{\mathtt{(},\ \mathtt{)},\ \mathtt{.},\ λ\} \cup V \), donde \( V \) es un conjunto infinito \( \{v_{0},\ v_{00},\ ... \} \) de variables. \( Λ \) es el conjunto más pequeño que satisface:
  \label{defn:terminos}
  \begin{subequations}
    \begin{align}
      \label{terminos:atomos} \tag{a}
      x \in V & \implies x \in Λ \\
      \label{terminos:abstracciones} \tag{b}
      M \in Λ,\ x \in V & \implies (λx.M) \in Λ \\
      \label{terminos:aplicaciones} \tag{c}
      M,\ N \in Λ & \implies (M N) \in Λ
    \end{align}
  \end{subequations}
\end{defn}

Cada una de estas tres reglas corresponde a las tres clases de términos lambda: la regla \eqref{terminos:atomos} define a todos los elementos de \( V \) como términos lambda, a estas variables se les llama \emph{átomos}; la regla \eqref{terminos:abstracciones} define a las cadenas de la forma \( (λx.M) \) (donde \( x \) es un átomo y \( M \) es un término lambda) como términos lambda, a estos términos se les llama \emph{abstracciones}; la regla \eqref{terminos:aplicaciones} define a las cadenas de la forma \( M N \) (donde \( M \) y \( N \) son términos lambda) como términos lambda, a estos términos se les llama \emph{aplicaciones}.

Una definición alternativa de \( Λ \) es haciendo uso de gramáticas libres de contexto:

\begin{defn}[Términos lambda]
  El conjunto de términos lambda es el lenguaje generado por la gramática libre de contexto \( G \) con categorías sintácticas \( T \) (términos lambda), \( E \) (aplicaciones), \( F \) (abstracciones) y \( A \) (átomos); símbolos terminales \( \{\mathtt{(},\ \mathtt{)},\ \mathtt{.},\ λ,\ v,\ {}_{0}\} \); símbolo inicial \( T \) y con las siguientes reglas de producción:
  \label{terminos-cfg}
  \begin{subequations}
    \begin{align}
      \label{terminos-cfg:terminos} \tag{a}
      T & \rightarrow E \mid F \mid A \\
      \label{terminos-cfg:atomos} \tag{b}
      A & \rightarrow \mathtt{v}_{0} \mid A {}_{0} \\
      \label{terminos-cfg:abstracciones} \tag{c}
      F & \rightarrow \mathtt{(} λ A \mathtt{.} T \mathtt{)} \\
      \label{terminos-cfg:aplicaciones} \tag{d}
      E & \rightarrow \mathtt{(} T T \mathtt{)}
    \end{align}
  \end{subequations}
\end{defn}

Para facilitar la escritura y lectura de los términos lambda, en este trabajo se hacen las siguientes consideraciones sobre la notación:

\begin{itemize}
\item Cuando se hace referencia a cualquier término lambda se utilizan las letras mayúsculas \( M \), \( N \), \( P \), etc. Es importante establecer que si en un ejemplo, explicación, teorema o demostración se hace referencia a un término lambda con una letra mayúscula, cualquier otra aparición de esta letra hace referencia a este mismo término dentro de ese contexto.
\item Cuando se hace referencia a cualquier átomo se utilizan las letras minúsculas \( x \), \( y \), \( z \), etc. Al igual que en el punto anterior, la aparición de una letra minúscula en un ejemplo, explicación, teorema o demostración hace referencia al mismo átomo.
\item Los paréntesis son omitidos de acuerdo a las siguientes equivalencias sintácticas:
  \begin{itemize}
  \item \( ((M N) P) \synteq M N P\), en general, se considera la aplicación de términos lambda con asociación a la izquierda. Se tiene que tener cuidado con respetar esta regla, por ejemplo \( (M(N(O P))) \synteq M(N(O P)) \not\synteq M N O P \).
  \item \( (λx.(M N)) \synteq λx.(M N) \), en general, se puede escribir una abstracción omitiendo los paréntesis externos. Es importante escribir de manera explícita los paréntesis en algunos casos, por ejemplo \( ((λx.(M N)) O) \synteq (λx.(M N)) O \not\synteq λx.(M N)O \) ya que el lado derecho de la equivalencia es sintácticamente equivalente a \( (λx.((M N)O)) \).
  \item \( (λx.(λy.(λz.M))) \synteq (λx y z.M) \), en general, si el cuerpo de una abstracción es también una abstracción, se pueden agrupar las variables ligadas y enlazadas. Éste abuso de notación es consistente con la reducción de funciones de varias variables usada por Schönfinkel \cite{Schonfinkel:Varargs}.
  \end{itemize}
\item El símbolo \( \synteq \) denota la equivalencia sintáctica entre dos términos lambda.
\end{itemize}

A continuación se muestran ejemplos de términos lambda asociados a términos sintácticamente equivalentes pero escritos con abuso de notación:

\begin{exmp}
  \label{exmp:notacion}
  \begin{align*}
    (((x y)z) (y x)) & \synteq x y z (y x) \\
    (λx.((u x)y)) & \synteq λx.y x y \\
    (λy.(u(λx.y))) & \synteq λu.u(λx.y) \\
    (((λy.((v u)u))z)y) & \synteq (λy.v u u) z y \\
    (((u x)(y z))(λv.(v y))) & \synteq u x(y z)(λv.v y) \\
    ((((λx.(λy.(λz.((x z) (y z))))) u) v) w) & \synteq (λx y z.x z(y z)) u v w
  \end{align*}
\end{exmp}

Para hacer referencia a una secuencia con una cantidad arbitraria de términos lambda se usa la notación \( \vec{x}=x_{1},...,x_{n} \) cuando es secuencia de átomos y \( \vec{M}=M_{1},...,M_{n} \) cuando es secuencia de términos lambda en general. Con esta notación se puede abreviar

\[ λ\vec{x}.M \synteq λx_{1} x_{2} ... x_{n}.M \]

\[ M \vec{N} \synteq M N_{1} N_{2} ... N_{n} \]

En algunas demostraciones realizadas por inducción, se usa la expresión ``inducción sobre \( M \)'' para referirse a la inducción sobre la \emph{longitud} de \( M \).

\begin{defn}[Longitud]
  La longitud de un término lambda, denotado como \( \| M \| \), es la cantidad de apariciones de átomos en el término lambda, se determina a partir de la estructura del término lambda como:
  \label{defn:longitud}
  \begin{align*}
    \|x\| & = 1 \\
    \|M N\| & = \|M\| + \|N\| \\
    \|λx.M\| & = 1 + \|M\|
  \end{align*}
\end{defn}

Por ejemplo, la longitud del término lambda \( x(λy.y u x) \) es \( 5 \).

Una cuestión importante al momento de demostrar un teorema o definir un concepto por inducción sobre un término lambda es que usualmente la inducción matemática relaciona proposiciones con números naturales. Sin embargo es posible tener dos términos diferentes \( M \) y \( N \) tal que \( \|M\| = \|N\| \), por ejemplo \( λx.x \) y \( z z \) tienen longitud \( 2 \). La inducción sobre la longitud de un término lambda considera la estructura del término, de tal manera que para una proposición \( P \) sobre un término lambda \( M \), los casos base de la inducción son aquellos en donde la estructura no es compuesta (en átomos cuya longitud siempre es \( 1 \)) y la hipótesis de inducción considera que \( P \) se cumple para los subtérminos de \( M \) cuya longitud siempre es estrictamente menor que \( \|M\| \).

El concepto de aparición de un término lambda en otro se formaliza a partir del concepto de subtérmino:

\begin{defn}[Subtérmino]
  \( M \) es un subtérmino de \( N \), denotado \( M \subset N \) si \( M \in \Sub(N) \) es la colección de subtérminos de \( N \) definida de manera inductiva como
  \label{defn:subtermino}
  \begin{align*}
    \Sub(x) & = \{ x \} \\
    \Sub(λx.M) & = \Sub(M) \cup \{ λx.M \} \\
    \Sub(M N) & = \Sub(M) \cup \Sub(N) \cup \{ M N \}
  \end{align*}
\end{defn}

\begin{defn}[Aparición]
  La aparición de \( M \) en \( N \) implica que \( M \subset N \) o que \( M \) es \emph{el} átomo del argumento de una abstracción en \( N \).
  \label{defn:aparicion}
\end{defn}

Un subtérmino \( N \) de \( M \) puede aparecer varias veces en \( M \), cuando dos subtérminos \( N_{1} \) y \( N_{2} \) de \( M \) no tienen apariciones de átomos en común, se dice que son \emph{disjuntas}. Cuando \( N \) es subtérmino de \( M \) se le llama \emph{activo} si aparece en una aplicación de la forma \( N Z \), de lo contrario, se le llama \emph{pasivo}.

Cuando \( λx.M \) es un subtérmino de \( P \), se dice que la aparición \( M \) es el \emph{alcance} de la aparición del átomo \( x \) que acompaña a la \( λ \).

\begin{exmp}
  Sea \( M \synteq λx.x y (λz.y) \):
  \label{exmp:subterminos-apariciones}
  \begin{itemize}
  \item el término \( x y \subset M \);
  \item el átomo \( z \not\subset M \) pero si aparece en \( M \), debido a que \( z \) acompaña a \( λ \);
  \item el término \( y(λz.y) \) a pesar de parecer ser un subtérmino de \( M \) no lo es, esto se puede corroborar escribiendo los términos sin el abuso de notación: \( y(λz.y) \synteq (y(λz.y)) \) y \( M \synteq λx.x y(λz.y) \synteq (λx.((x y)(λz.y))) \), en este caso, la clave está en observar la estructura de la aplicación \( x y(λz.y) \).
  \item Las apariciones de \( x \) y \( λz.y \) en \( M \) son disjuntas.
  \item Los términos \( x \) y \( (x y) \) son subtérminos activos de \( M \), mientras que \( y \) y \( λz.y \) son subtérminos pasivos.
  \end{itemize}
\end{exmp}

Las variables de un término lambda se pueden clasificar de diferentes maneras de acuerdo a la posición que tienen en el término y a los subtérminos a los que se asocian.

\begin{defn}[Clasificación de variables]
  La aparición de un átomo \( x \) en un término \( P \) es llamada:
  \label{defn:clasifvar}
  \begin{itemize}
  \item \emph{variable ligada} si es un subtérmino de \( M \) en una abstracción \( λx.M \) en \( P \);
  \item \emph{variable enlazada} si y sólo si es la \( x \) que acompaña la \( λ \) de \( λx.M \) en \( P \);
  \item \emph{variable libre} en otro caso.
  \end{itemize}
\end{defn}

Es importante aclarar la diferencia entre un átomo \( x \) como subtérmino de un término lambda \( M \) y una aparición de \( x \) en \( M \): la aparición hace referencia a la posición de \( x \) en \( M \). Por ejemplo, en el término lambda \( (λx.x) x \) la primera aparición del átomo \( x \) es una variable enlazada, la segunda aparición es una variable ligada y la tercera aparición es una variable libre.

\begin{exmp}
  Sea \( M \synteq x(λy.x y) \):
  \label{exmp:clasifvar}
  \begin{itemize}
  \item El átomo \( x \) aparece como variable libre dos veces en \( M \);
  \item El átomo \( y \) aparece como variable ligada en \( M \).
  \end{itemize}
\end{exmp}

En la definición formal de algunos conceptos es conveniente hacer referencia a las variables libres de un término lambda:

\begin{defn}[Variables libres]
  El conjunto de variables libres de un término lambda \( M \) se denota \( \FV(M) \) y se define de manera inductiva como:
  \label{defn:varlib}
  \begin{align*}
    \FV(x) & = \{ x \} \\
    \FV(λx.M) & = \FV(M) \setminus \{ x \} \\
    \FV(M N) & = \FV(M) \cup \FV(N)
  \end{align*}
  Cuando \( \FV(M)=\emptyset \) se dice que \( M \) es un \emph{combinador} o \emph{término cerrado}.
\end{defn}

\begin{exmp}
  Consideremos los términos \( x(λx.x y z) \), \( λx y z.y \) y \( (λy.x)λx.y\).
  \label{exmp:varlib}
  \begin{itemize}
  \item \( \FV(x(λx.x y z)) = \{x,\ y,\ z\} \);
  \item \( \FV(λx y z.y)=\emptyset \), por lo tanto es un combinador;
  \item \( \FV((λy.x)λx.y)=\{ x,\ y \} \).
  \end{itemize}
\end{exmp}

En ocaciones es importante distinguir los términos lambda cerrados de aquellos que contienen variables libres, para ello se identifica el subconjunto de \( Λ \) que contiene a todos los términos cerrados:

\begin{defn}[Términos cerrados]
  Se denota como \( Λ^{0} \) al conjunto
  \label{defn:termcerr}
  \[ \{ M \in Λ \mid M \text{es un término cerrado} \} \]
\end{defn}

La notación \( Λ^{0} \) se puede generalizar para identificar diferentes subconjuntos de \( Λ \) a partir de las variables libres de los términos lambda:

\[ Λ^{0}(\vec{x})=\{ M \in Λ \mid \FV(M) \subseteq \{ \vec{x} \} \} \]

De tal manera que:

\[ Λ^{0}=Λ^{0}(\emptyset) \]

Todos los términos lambda en \( Λ \setminus Λ^{0} \) tienen al menos una clausura en \( Λ^{0} \).

\begin{defn}[Clausura] \label{defn:clausura}
  La clausura de un término lambda \( M \) con \( \FV(M) \not= \emptyset \) es un término lambda
  \[ (λ\vec{x}.M) \]
  con \( \vec{x}=\FV(M) \)
\end{defn}

\begin{exmp} \label{exmp:clausura}
  Consideremos el términio lambda \( M \synteq λz.x y z \)
  \begin{itemize}
  \item \( λx y.λz.x y z \) es una clausura de \( M \);
  \item \( λy x z.x y z \) es una clausura de \( M \);
  \item \( λz x y.λz.x y z \) no es una clausura de \( M \).
  \end{itemize}
\end{exmp}

Al escribir términos lambda con repetición de aplicaciones suele ser conveniente utilizar una notación más compacta. Cuando se aplica \( n \) veces un término \( F \) por la izquierda a otro término \( M \) se denota \( F^{n} M \). Cuando se aplica \( n \) veces un término \( M \) por la derecha a otro término \( F \) se denota \( F M^{\sim n}\). La definición formal de esta notación es:

\begin{align*}
  F^{n+1} M & \synteq F (F^{n} M) \\
  F^{0} M & \synteq M
\end{align*}

\begin{align*}
  F M^{\sim n+1} & \synteq (F M^{\sim n}) M \\
  F M^{\sim 0} & \synteq F
\end{align*}

\begin{exmp}
  El término lambda \( λf x.f(f(f(f x))) \) se puede escribir de manera compacta como
  \[ λf x.f^{4} x \]
\end{exmp}

\begin{exmp}
  El término lambda \( λf x.f x x x x \) se puede escribir de manera compacta como
  \[ λf x.f x^{\sim 4} \]
\end{exmp}

\begin{defn}[Sustitución]
  \label{defn:sustitucion}
  Para cualquier \( M \), \( N \) y \( x \), se define \( M[x:=N] \) como el resultado de sustituir cada aparición libre de \( x \) por \( N \) en \( M \) de acuerdo a las siguientes reglas:
  \begin{align*}
    x[x:=N] & \synteq N; \\
    a[x:=N] & \synteq a && a \not \synteq x; \\
    (P Q)[x:=N] & \synteq P[x:=N] Q[x:=N]; \\
    (λx.P)[x:=N] & \synteq λx.P; \\
    (λy.P)[x:=N] & \synteq λy.P && x \not\synteq y,\ x \not\in \FV(P); \\
    (λy.P)[x:=N] & \synteq λy.P[x:=N] && x \not\synteq y,\ x \in \FV(P),\ y \not\in \FV(N); \\
    (λy.P)[x:=N] & \synteq λz.P[y:=z][x:=N] && x \not\synteq y,\ x \in \FV(P),\ y \in \FV(N),\ z \not\in \FV(N P).
  \end{align*}
\end{defn}

\begin{exmp} \label{exmp:sustitucion}
  Procedimientos de sustituciones para cada uno de los casos de la definición \ref{defn:sustitucion}:
  \begin{itemize}
  \item Caso \( x[x:=N] \)
    \begin{align*}
      y[y:=λx.x] \synteq λx.x
    \end{align*}
  \item Caso \( a[x:=N] \), donde \( a \not\synteq x \)
    \begin{align*}
      z[w:=x x] \synteq z
    \end{align*}
  \item Caso \( (P Q)[x:=N] \)
    \begin{align*}
      (y x x)[x:=y] & \synteq ((y x) x) \\
                    & \synteq (y x)[x:=y] x[x:=y] \\
                    & \synteq (y[x:=y] x[x:=y]) y \\
                    & \synteq y y y
    \end{align*}
  \item Caso \( (λx.P)[x:=N] \)
    \begin{align*}
      (λf x.f f x)[f:=g] \synteq λf x.f f x
    \end{align*}
  \item Caso \( (λy.P)[x:=N] \), donde  \( x \not\synteq y \), \( x \not\in \FV(P) \)
    \begin{align*}
      (λf x.f f x)[f:=g] \synteq λf x.f f x
    \end{align*}
  \item Caso \( (λy.P)[x:=N] \), donde \( x \not\synteq y \), \( x \in \FV(P) \), \( y \not\in \FV(N) \)
    \begin{align*}
      (λf.xλx.f f x)[x:=y] & \synteq λf.(xλx.f f x)[x:=y] \\
                           & \synteq λf.x[x:=y](λx.f f x)[x:=y] \\
                           & \synteq λf.yλx.f f x
    \end{align*}
  \item Caso \( (λy.P)[x:=N] \), donde \( x \not\synteq y \), \( x \in \FV(P) \), \( y \in \FV(N) \) y \( z \not\in \FV(N P) \)
    \begin{align*}
      (λf.xλx.f f x)[x:=f] & \synteq λg.(x λx.f f x)[f:=g][x:=f] \\
                           & \synteq λg.(x[f:=g](λx.f f x)[f:=g])[x:=f] \\
                           & \synteq λg.(x λx.(f f x)[f:=g])[x:=f] \\
                           & \synteq λg.(x λx.((f f)[f:=g] x[f:=g]))[x:=f] \\
                           & \synteq λg.(x λx.((f[f:=g] f[f:=g]) x))[x:=f] \\
                           & \synteq λg.(x λx.g g x)[x:=f] \\
                           & \synteq λg.x[x:=f] (λx.g g x)[x:=f] \\
                           & \synteq λg.f λx.g g x
    \end{align*}
  \end{itemize}
\end{exmp}

En el último caso es importante observar que las apariciones ligadas de \( x \) no se sustituyen.

\begin{lem}
  Si \( (y x) \not\in \FV(L) \) y \( x \not\synteq y \), entonces
  \[ M[x:=N][y:=L] \synteq M[y:=L][x:=N[y:=L]] \]
\end{lem}

En contraste a la operación de sustitución en donde no se permite introducir o quitar referencias a variables enlazadas, el \emph{contexto} es un término con ``hoyos'':

\begin{defn}[Contexto]
  \label{defn:contexto}
  Un contexto es un término lambda denotado \( C[\quad] \) definido de manera inductiva:
  \begin{itemize}
  \item \( x \) es un contexto;
  \item \( [\quad] \) es un contexto;
  \item Si \( C_{1}[\quad] \) y \( C_{2}[\quad] \) son contextos, entonces \( C_{1}[\quad] C_{2}[\quad] \) y \( λx.C_{1}[\quad] \) también lo son.
  \end{itemize}
\end{defn}

Si \( C[\quad] \) es un contexto y \( M \in Λ \), entonces \( C[M] \) denota el resultado de reemplazar por \( M \) los hoyos de \( C[\quad] \). Al realizar esto, las variables libres de \( M \) pueden convertirse en variables ligadas de \( C[M] \).

\begin{exmp}
  Consideremos el contexto \( C[\quad] \synteq λx.x λy.[\quad] \) y el término lambda \( M \synteq (x y) \).
  
  \begin{align*}
    C[M] & \synteq (λx.xλy.[\quad])[(x y)] \\
         & \synteq (λx.xλy.(x y))
  \end{align*}
  
  El caso análogo con la sustitución es

  \begin{align*}
    (λx.x λy.w)[w:=(x y)] & \synteq λz.(x λy.w)[x:=z][w:=(x y)] \\
                          & \synteq λz.(x[x:=z] (λy.w)[x:=z])[w:=(x y)] \\
                          & \synteq λz.(z λy.w)[w:=(x y)] \\
                          & \synteq λz.z[w:=(x y)] (λy.w)[w:=(x y)] \\
                          & \synteq λz.z λv.w[w:=(x y)] \\
                          & \synteq λz.z λv.(x y)
  \end{align*}
\end{exmp}

\subsection{Teoría \( \bs{λKβ} \)}
\label{sec:teorialambda}

El objetivo principal de esta subsección es presentar una formalización del cálculo lambda descrito en \ref{sec:informal} desde el punto de vista de teorías formales. El nombre técnico de la teoría formal principal de este trabajo es \( \bs{λKβ} \), se pueden realizar modificaciones y extensiones a esta teoría y los siguientes conceptos permiten estudiar las implicaciones de estos cambios.

Una \emph{teoría formal} \( \mathcal{T} \) es una tripleta \( (\mathcal{F},\mathcal{A},\mathcal{R}) \) donde

\begin{itemize}
\item \( \mathcal{F} \) es el conjunto de todas las \emph{fórmulas} \( X = Y \) con \( X \) y \( Y \) elementos de un lenguaje formal;
\item \( \mathcal{A} \) es un conjunto de \emph{axiomas} y \( \mathcal{A} \subseteq \mathcal{F} \);
\item \( \mathcal{R} \) es un conjunto de \emph{reglas}.
\end{itemize}

Una regla es una función \( φ \colon \mathcal{F}^{n} \to \mathcal{F} \) con \( n \geq 1 \). Una secuencia de fórmulas \( \langle A_{1},...,A_{n},B \rangle \) tal que

\[ φ(A_{1},...,A_{n})=B \]

es llamada una \emph{instancia} de \( φ \), donde las \emph{premisas} de la instancia son las fórmulas \( \langle A_{1},...,A_{n} \rangle \) y la \emph{conclusión} de la instancia es \( B \). Las instancias se denotan

\[ \infer{B}{A_{1} & ... & A_{n}} \]

\begin{rem}
  En la literatura se pueden encuentrar diferentes maneras de trabajar con teorías formales, dependiendo del estilo de las teorías y de la manera en como se formaliza su definición, por ejemplo en \cite{Troelstra:ProofTheory} las reglas se definen como conjuntos de secuencias \( \langle A_{1},...,A_{n+1} \rangle \) con \( n \) premisas y una conclusión, en donde los axiomas se definen como las reglas en \( \mathcal{R} \) con cero premisas. La definición de teoría formal es del estilo Hilbert y está basada en \cite[pp.~69--70]{HindleySeldin:LambdaCalculusAndCombinators}.
\end{rem}

Si consideramos un conjunto \( Γ \subseteq \mathcal{F} \), una \emph{deducción} deuna fórmula \( B \) desde \( Γ \) es un árbol dirigido de fórmulas en donde los vértices de un extremo son elementos de \( \mathcal{A} \) o \( Γ \), los vértices intermedios son deducidos a partir de los vértices que inciden en ellos a partir de una regla y el vértice de el otro extremo siendo \( B \). Las fórmulas que no sean axiomas cuyo grado de entrada sea cero son llamadas \emph{suposiciones}. Si y solo si existe una deducción para una fórmula \( B \), se dice que \( B \) es demostrable en \( \mathcal{T} \) suponiendo \( Γ \), denotado

\[ \mathcal{T},Γ \vdash B \]

En caso que la deducción no tenga suposiciones, se dice que es una \emph{demostración} y que \( B \) es un \emph{teorema}. Cuando \( Γ = \emptyset \) se escribe

\[ \mathcal{T} \vdash B \]

A continuación se presenta la definición de la teoría \( \bs{λKβ} \), debido a que esta teoría será la que se estudia principalmente en este trabajo, se acorta el nombre \( \bs{λKβ} \) a \( \bs{λ} \).


En el caso particular de la teoría \( \bs{λKβ} \) se considera que \( \mathcal{F} \) tiene elementos \( M = N \) donde \( M,N \in Λ \).


\begin{defn}[Teoría \( \bs{λ} \)]
  \label{defn:teorialambda}
  El conjunto de fórmulas tiene como elementos ecuaciones de la forma:

  \begin{align*}
    M = N & & \forall M,N \in Λ
  \end{align*}
  
  Los axiomas son:

  \begin{subequations}
    \begin{align}
      \label{teorialambda:alpha} \tag{\( α \)}
      λx.M & = λy.M[x:=y] & &  \forall y \not\in \FV(M) \\
      \label{teorialambda:beta} \tag{\( β \)}
      (λx.M)N & = M[x:=N] \\
      \label{teorialambda:rho} \tag{\( ρ \)}
      M & = M
    \end{align}
  \end{subequations}

  Y las reglas:

  \begin{equation}
    \label{teorialambda:mu} \tag{\( μ \)}
    \infer{Z M = Z N}{M = N}
  \end{equation}
  \begin{equation}
    \label{teorialambda:nu} \tag{\( ν \)}
    \infer{M Z = N Z}{M = N}
  \end{equation}
  \begin{equation}
    \label{teorialambda:xi} \tag{\( ξ \)}
    \infer{λx.M = λx.N}{M = N}
  \end{equation}
  \begin{equation}
    \label{teorialambda:tau} \tag{\( τ \)}
    \infer{M = P}{M = N & N = P}
  \end{equation}
  \begin{equation}
    \label{teorialambda:sigma} \tag{\( σ \)}
    \infer{N = M}{M = N}
  \end{equation}
  
\end{defn}

Al inicio de esta sección, se menciona que el objeto de estudio de la teoría \( \bs{λ} \) es el conjunto de términos lambda módulo convertibilidad. La \emph{convertibilidad} es la noción básica de equivalencia de términos lambda y las ecuaciones de la teoría \( \bs{λ} \) formalizan esta noción.

La relación binaria \( = \) en las ecuaciones de la teoría, es una relación de equivalencia y al igual que toda relación de equivalencia es \emph{reflexiva}, \emph{simétrica} y \emph{transitiva}, en \( = \) estas propiedades son descritas en las reglas \eqref{teorialambda:rho}, \eqref{teorialambda:sigma} y \eqref{teorialambda:tau} respectivamente. La \emph{clase de equivalencia} de un término lambda \( M \) con respecto a esta relación de equivalencia es el conjunto de todos los términos lambda \( N \) tal que \( M = N \), denotado:

\[ [M]_{\bs{λ}} = \{ N \in Λ \mid M = N \} \]


La frase ``módulo convertibilidad'' se refiere al conjunto de todas las clases de equivalencia de \( Λ \) considerando la relación de equivalencia de la teoría formal con la que se esté trabajando. Que este conjunto sea el objeto de estudio de la teoría \( \bs{λ} \) significa que cada elemento de \( Λ \) módulo convertibilidad (denotado \( Λ / =_{\bs{λ}} \)) es distinto y representa a una clase de términos lambda considerados en \( \bs{λ} \) como equivalentes.

\begin{defn}[Demostrabilidad]
  \label{defn:demostrabilidad}
  La demostrabilidad en \( \bs{λ} \) de una ecuación \( M = N \) es denotada \( \bs{λ} \vdash M = N \) e implica que \( M = N \) es un teorema en \( \bs{λ} \). En caso que la ecuación sea demostrable se dice que \( M \) y \( N \) son términos \emph{convertibles}.
\end{defn}

\begin{exmp}
  \label{exmp:demostrabilidad}
  Consideramos los términos lambda \( M \synteq (λf.x((λy.y f) λz.z))w \) y \( N \synteq x w \). Se muestra que

  \[ \bs{λ} \vdash M = N \]

  formulando el árbol de deducción de la figura \ref{fig:demostrabilidad}.
\end{exmp}

\begin{rem}
  Es posible formular mas de un árbol de deducción para un teorema en una teoría formal.
\end{rem}

\begin{figure}
  \centering
  \begin{tikzpicture}[
    equat/.style={rectangle,draw},grow=up,edge from parent/.style={draw,latex-},
    level 1/.style={sibling distance=20em, level distance=5em},
    level 2/.style={sibling distance=40em},
    level 3/.style={sibling distance=20em},
    level 4/.style={sibling distance=10em}
    ]
    \node [equat] (foo1) {\( (λf.x((λy.y f) λz.z))w = x w \)}
    child {
      node [equat] (foo3) {\( (λf.x f)w = x w \)}
    }
    child {
      node [equat] (foo5) {\( (λf.x((λy.y f) λz.z))w = (λf.x f)w \)}
      child {
        node [equat] (foo7) {\( λf.x((λy.y f) λz.z) = λf.x f \)}
        child {
          node [equat] (foo9) {\( x((λy.y f) λz.z) = x f \)}
          child {
            node [equat] (foo11) {\( (λy.y f)λz.z = f \)}
            child {
              node [equat] (foo13) {\( (λz.z)f = f \)}
            }
            child {
              node [equat] (foo14) {\( (λy.y f)λz.z = (λz.z) f \)}
            }
            edge from parent [] node [right] {\( (μ) \)}
          }
          edge from parent [] node [right] {\( (ξ) \)}
        }
        edge from parent [] node [right] {\( (ν) \)}
      }
    };
    \node [above=0em of foo13] (bar1) {\( (β) \)};
    \node [above=0em of foo14] (bar2) {\( (β) \)};
    \node [above=0em of foo11] (bar3) {\( (τ) \)};
    \node [above=0em of foo1] (bar4) {\( (τ) \)};
    \node [above=0em of foo3] (bar5) {\( (β) \)};
  \end{tikzpicture}
  \caption{Árbol de deducción para la ecuación del ejemplo \ref{exmp:demostrabilidad}}
  \label{fig:demostrabilidad}
\end{figure}

\begin{defn}[Combinadores SKI]
  \label{defn:ski}
  Tres términos lambda de suma importancia son
  \begin{align*}
    \bs{I} & \synteq λx.x \\
    \bs{K} & \synteq λx y.x \\
    \bs{S} & \synteq λx y z.x z(y z)
  \end{align*}
\end{defn}

\begin{cor}
  \label{cor:ski}
  Para todo término \( M,N,L \in Λ \)

  \begin{align*}
    \bs{I} M & =_{\bs{λ}} M \\
    \bs{K} M N & =_{\bs{λ}} M \\
    \bs{S} M N L & =_{\bs{λ}} M L (N L)
  \end{align*}
\end{cor}

Estos tres combinadores generan en la teoría \( \bs{λ} \) al conjunto \( Λ^{0} \) con combinaciones de aplicaciones. Debido a que \( \bs{S} \bs{K} \bs{K} =_{\bs{λ}} \bs{I} \), sólo es necesario combinar con aplicaciones a \( \bs{K} \) y a \( \bs{S} \) para generar cualquier término cerrado.

\subsubsection{Otras teorías}
\label{sec:otras-teorias}

En el artículo \cite{Church:LambdaConversion}, Alonzo Church presenta una definición del cálculo lambda con un conjunto restringido de términos lambda. A la teoría que considera a este conjunto restringido de términos lambda (denotado \( Λ_{I} \)) y los axiomas y reglas de inferencia de la teoría \( \bs{λ} \) cambiando \( Λ \) por \( Λ_{I} \) se le conoce como teoría \( \bs{λIβ} \) (o el cálculo \( λI \)).

\begin{defn}[Términos en \( Λ_{I} \)]
  \label{defn:lambdaI}
  \begin{align*}
    x \in V & \implies x \in Λ_{I} \\
    M \in Λ_{I},\ x \in \FV{M} & \implies λx.M \in Λ_{I} \\
    M, N \in Λ_{I} & \implies M N \in Λ_{I}
  \end{align*}
\end{defn}

La diferencia fundamental entre las teorías \( \bs{λKβ} \) y \( \bs{λIβ} \) es el término lambda \( \bs{K} \), ya que \( \bs{K} \in Λ \setminus Λ_{I} \) pero \( \bs{K} \not\in Λ_{I} \). Esto es debido a que el subtérmino \( λy.x \) en \( \bs{K} \) de la definición \ref{defn:ski} no puede existir en \( Λ_{I} \) debido a que \( y \not\in \FV(x) \).

\subsubsection{Extensionalidad}
\label{sec:extensionalidad}

El concepto de igualdad de funciones usado en la mayoría de las ramas de la matemática es lo que se conoce como ``extensional'', esta propiedad de las relaciones de equivalencia hace referencia a las características externas de los objetos que compara, en el caso de las funciones, se incluye la suposición de que para funciones \( f \) y \( g \) con el mismo dominio

\[ \forall x [ f(x)=g(x) ] \implies f=g \]

Contraria a esta suposición, en la computación, el tema central son los procedimientos y procesos que describen los programas o algoritmos, cuyas igualdades ``intensional'', es decir, si dos programas computan la misma función matemática, no necesariamente se dice que son el mismo programa ya que uno pudiera ser mas eficiente que otro (la característica de eficiencia es interna a cada algorítmo).

La teoría \( \bs{λ} \) también es intensional: existen dos términos lambda \( F \) y \( G \) tales que para tódo término \( X \)

\[ \bs{λ} \vdash F X = G X \]

Pero no \( \bs{λ} \vdash F=G \). Por ejemplo, \( F \synteq y \) y \( G \synteq λx.y x \)

Cuando se plantea formalizar un cálculo lambda que sea extensional, surge la pregunta, ¿Qué es demostrable en el sistema extensional que no es demostrable en \( \bs{λ} \). A continuación se presentan tres diferentes agregados a la teoría \( \bs{λ} \) las cuales incluyen la propiedad de extensionalidad y que han sido propuestas en la literatura \cite{HindleySeldin:LambdaCalculusAndCombinators,Barendregt:Bible}. Las teorías extendidas son llamadas \( \bs{λζ} \), \( \bs{λ+ext} \) y \( \bs{λη} \) de acuerdo a la regla que se añade a la definición \ref{defn:teorialambda}.

\begin{defn}[Reglas de extensionalidad]
  \label{defn:extensionalidad}
  Cada una de las siguientes reglas nos permite añadir a \( \bs{λ} \) la propiedad de extensionalidad.
  \begin{description}
  \item[Reglas de inferencia]
    \begin{subequations}
      \begin{align}
        \label{extensionalidad:zeta} \tag{\( ζ \)}
        \infer{M = N}{M x = N x} & & \text{si \( x \not\in \FV(M N) \)} \\
        \label{extensionalidad:ext} \tag{ext}
        \infer{M = N}{M P = N P} & & \forall P \in Λ
      \end{align}
    \end{subequations}
  \item[Axiomas]
    \begin{align}
      \label{extensionalidad:eta} \tag{\( η \)}
      λx.M x = M & & \text{si \( x \not\in \FV(M) \)}
    \end{align}
  \end{description}
\end{defn}

La regla \eqref{extensionalidad:zeta} dice, de manera informal, que si \( M \) y \( N \) tienen el mismo efecto sobre un objeto no especificado \( x \), entonces \( M = N \). La regla \eqref{extensionalidad:ext} tiene una infinidad de premisas, una por cada término lambda \( P \), por lo tanto, las deducciones en donde se involucre esta regla serán árboles infinitos.

\subsubsection{Equivalencia de teorías}
\label{sec:equivalenciateorias}

Comparación entre teorías formales, énfasis en \( η \) contra \( ζ \) contra \( ext \).

Ver \cite{HindleySeldin:LambdaCalculusAndCombinators}, \cite{Troelstra:ProofTheory}, \cite{Mendelson:Logic}.

Sea \( \mathcal{T} \) una teoría formal, se considera extender \( \mathcal{T} \) añadiendo una nueva regla \( \mathcal{R} \). Es natural preguntarse primer si \( \mathcal{R} \) es derivable en \( \mathcal{T} \). Pero ¿qué significa exactamente que \( \mathcal{R} \) sea derivable?

\begin{defn}[Regla]
  \label{defn:regla}
  Una regla \( \mathcal{R} \) de \( n \) premisas es un conjunto de secuencias \( \mathcal{S}_{0},...,\mathcal{S}_{n-1},\mathcal{S} \) de longitud \( n+1 \), donde \( \mathcal{S}_{i},\mathcal{S} \) son elementos de deducción. Un elemento de \( \mathcal{R} \) se dice ser una \emph{instancia} de \( \mathcal{R} \). Una instancia se denota

  \[ \infer{\mathcal{S}}{\mathcal{S}_{0} & \mathcal{S}_{1} & ... & \mathcal{S}_{n-1}} \]

  \( \mathcal{S} \) es la \emph{conclusión} y las \( \mathcal{S}_{i} \) son las \emph{premisas}. Un \emph{axioma} es una regla de cero premisas. Instancias de axiomas aparecen en árboles de deducción simplemente como vértices superiores o de manera equivalente como elementos de deducción con una línea sobre ellos:

  \[ \infer{S}{} \]
\end{defn}

\begin{defn}[Reglas derivables y admisibles]
  \label{defn:regla-derivable}
  Sea \( \mathcal{R} \) una regla determinada por una función \( φ \colon \mathcal{F}^{n} \to \mathcal{F} \). Se dice que \( \mathcal{R} \) es \emph{derivable} en \( \mathcal{T} \) si y solo si, por cada instancia de \( \mathcal{R} \), su conclusión es deducible en \( \mathcal{T} \) a partir de sus premisas, es decir

  \[ \mathcal{T},\ A_{1},...,A_{n} \vdash B \].

  Se dice que \( \mathcal{R} \) es \emph{admisible} en \( \mathcal{T} \) si y solo si, añadir \( \mathcal{R} \) a \( \mathcal{T} \) como una nueva regla no va a incrementar la cantidad de teoremas de \( \mathcal{T} \).

  Se dice que \( \mathcal{R} \) es \emph{correcta} en \( \mathcal{T} \) si y solo si, por cada instancia de \( \mathcal{R} \), si todas las premisas son demostrables en \( \mathcal{T} \), entonces también es demostrable la conclusión, es decir, si y solo si

  \[ (\mathcal{T} \vdash A_{1}),...,(\mathcal{T} \vdash A_{n}) \implies (\mathcal{T} \vdash B) \]

  Finalmente, una sola fórmula \( C \), como un nuevo axioma propuesto, se dice ser tanto \emph{derivable} como \emph{admisible} en \( \mathcal{T} \) si y solo si

  \[ \mathcal{T} \vdash C \]
\end{defn}

\subsubsection{Lemas y corolarios sobre términos lambda en \( \bs{λKβ} \)}
\label{sec:lemas-y-corolarios}

Resultados sobre términos lambda en la teoría \( \bs{λKβ} \).

\subsection{Teoría de reducción}
\label{sec:teoriareduccion}

\subsubsection{Contracciones}
\label{sec:contracciones}

Transformaciones de términos con un paso.

\subsubsection{Reducciones}
\label{sec:reducciones}

Reducciones basadas en contracciones.

\subsubsection{Convertibilidad}
\label{sec:convertibilidad}

Ecuaciones desde una perspectiva de reducción

\subsubsection{Teorema de Church-Rosser}
\label{sec:church-rosser}

Confluencia en términos lambda.

\subsection{Árboles Böhm}
\label{sec:arboles-bohm}

Estructura con perspectiva conjuntivista, no se formaliza el modelo pero se describe.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
