La noción de \emph{generalización} es de suma importancia en el estudio general de funciones, operaciones o transformaciones. Los predicados en la lógica de primer orden, las funciones en la matemática clásica, los algoritmos en la computación y las abstracciones en el cálculo lambda pueden ser considerados como implementaciones del concepto de generalización para los sistemas de los que forman parte y en algunos casos son la motivación original para el desarrollo de las teorías que los fundamentan.

El estudio de las propiedades generales de las funciones es una de las motivaciones originales del cálculo lambda, sin embargo, este cálculo se formuló de tal manera que es posible abstraer de su propósito original y ser tratado meramente como un sistema formal \cite{Church:LambdaConversion}.

El presente capítulo tiene el objetivo de formalizar las ideas presentadas en el capítulo \ref{ch:nocion-informal}. La formalización del cálculo lambda se realiza desde dos perspectivas:

\begin{enumerate}
\item Construyendo una \emph{teoría formal}, en donde un conjunto de axiomas y reglas de inferencia permiten plantear razonamientos lógicos para demostrar propiedades del cálculo lambda.
\item Formulando nociones de \emph{reducción}, de tal manera que mediante procedimientos de transformación de expresiones del cálculo lambda, se puedan estudiar sus propiedades.
\end{enumerate}

Independientemente de la perspectiva de la formalización, los conceptos son similares, se describe la misma idea general del cálculo lambda y ambos trabajan con el lenguaje formal de sus expresiones.

De acuerdo a Barendregt \cite[p.~22]{Barendregt:Bible}, el objeto de estudio del cálculo lambda es el conjunto de términos lambda módulo convertibilidad. Estos conceptos serán presentados a lo largo de este capítulo.

El contenido de este capítulo está basado en los primeros cuatro capítulos del libro \emph{The Lambda Calculus, Its Syntax and Semantics} de H.P. Barendregt \cite{Barendregt:Bible} y los capítulos 1, 3, 6, 7 y 8 del libro \emph{Lambda Calculus and Combinators, an Introduction} de J.R. Hindley y J.P. Seldin \cite{HindleySeldin:LambdaCalculusAndCombinators} así como el artículo \emph{A Set of Postulates for the Foundation of Logic} y la monografía \emph{The Calculi of Lambda-Conversion} de Alonzo Church \cite{Church:FoundationsLogic,Church:LambdaConversion}.

\section{Términos lambda}
\label{sec:terminos-lambda}

Esta subsección está basada principalmente en el capítulo 2 de \cite{Barendregt:Bible}.

Los \emph{términos lambda} son la formalización de las expresiones descritas en la sección \ref{sec:expresiones}. El conjunto de todos los términos lambda es un lenguaje formal \( Λ \) en donde sus elementos son cadenas compuestas de símbolos de un alfabeto \cite{Hopcroft:Automata}.

El lenguaje \( Λ \) se puede definir de diferentes maneras, a continuación se presenta una definición inductiva y posteriormente una definición basada en una gramática libre de contexto.

\begin{rem}[Notación]\
  \begin{itemize}
  \item El símbolo \( \implies \) denota una implicación lógica, \( P \implies Q \) se lee ``Si \( P \), entonces \( Q \)''.
  \item El símbolo \( \, \longrightarrow\, \) denota una producción en una gramática, \( P \longrightarrow Q \) se lee ``\( P \) produce \( Q \)''.
  \item El símbolo \( \, \Rightarrow\, \) denota un paso en la derivación de una cadena.
  \end{itemize}
\end{rem}

\begin{defn}[Términos lambda]
  El conjunto \( Λ \) tiene elementos que son cadenas conformadas por símbolos en el alfabeto \( Σ=\{\mathtt{(},\ \mathtt{)},\ \mathtt{.},\ λ\} \cup V \), donde \( V \) es un conjunto infinito \( \{v_{0},\ v_{00},\ ... \} \) de variables. \( Λ \) es el conjunto más pequeño que satisface:
  \label{defn:terminos}
  \begin{subequations}
    \begin{align}
      \label{terminos:atomos} \tag{a}
      x \in V & \implies x \in Λ \\
      \label{terminos:abstracciones} \tag{b}
      M \in Λ,\ x \in V & \implies (λx.M) \in Λ \\
      \label{terminos:aplicaciones} \tag{c}
      M,\ N \in Λ & \implies (M\, N) \in Λ
    \end{align}
  \end{subequations}
\end{defn}

Cada uno de estos tres incisos corresponde a las tres clases de términos lambda:

\begin{description}
\item[\eqref{terminos:atomos}] establece que todo elemento de \( V \) es un término lambda a los cuales se les llama \emph{átomos};
\item[\eqref{terminos:abstracciones}] establece que las cadenas de la forma \( (λx.M) \) son términos lambda, donde \( x \) es un átomo y \( M \) es cualquier término lambda, a estos términos se les llama \emph{abstracciones};
\item[\eqref{terminos:aplicaciones}] establece que las cadenas de la forma \( (M\, N) \) son términos lambda, donde \( M \) y \( N \) son términos lambda cualesquiera, a estos términos se les llama \emph{aplicaciones}.
\end{description}

En el estudio usual de lenguajes formales \cite{Hopcroft:Automata}, \( Λ \) pertenece a la clase de lenguajes libres de contexto y puede ser definido de la siguiente manera:

\begin{defn}[Términos lambda]
  \label{defn:terminos-cfg}
  El conjunto de términos lambda es el lenguaje generado por la gramática libre de contexto \( G \) conformado por

  \begin{description}
  \item[categorías sintácticas] \( T \), \( E \), \( F \) y \( A \), las cuales denotan las reglas para derivar términos lambda, aplicaciones, abstracciones y átomos respectivamente;
  \item[símbolos terminales] \( \{\mathtt{(},\ \mathtt{)},\ \mathtt{.},\ λ,\ v,\ {}_{0}\} \), los cuales son los símbolos que conforman a las cadenas en \( Λ \);
  \item[símbolo inicial] \( T \), el cual es el símbolo del que se derivan todos los términos lambda;
  \item[reglas de producción]
    \begin{subequations}
    \begin{align}
      \label{terminos-cfg:terminos} \tag{a}
      T & \rightarrow E\ \mid\ F\ \mid\ A \\
      \label{terminos-cfg:atomos} \tag{b}
      A & \rightarrow \mathtt{v}_{0}\ \mid\ A {}_{0} \\
      \label{terminos-cfg:abstracciones} \tag{c}
      F & \rightarrow \mathtt{(} λ\ A\ \mathtt{.}\ T\ \mathtt{)} \\
      \label{terminos-cfg:aplicaciones} \tag{d}
      E & \rightarrow \mathtt{(}\ T\ T\ \mathtt{)}
    \end{align}
  \end{subequations}
  \end{description}
\end{defn}

Dada una secuencia de símbolos \( M \), se pueden utilizar estas dos definiciones para verificar si \( M \) es o no un término lambda. En el caso de la definición inductiva, se debe presentar un razonamiento que pruebe que las partes de la cadena satisface la definición \ref{defn:terminos}. En el caso de la gramática libre de contexto \ref{defn:terminos-cfg} se debe presentar una derivación de la cadena a partir de la categoría sintáctica \( T \).

\begin{exmp} Sea \( M = (λv_{0}.(v_{00} (λv_{00}.v_{000}))) \), la cadena \( M \) es un término lambda ya que

  \begin{description}
  \item[Por definición inductiva]
    \begin{align*}
      v_{000} \in V &\implies v_{000} \in Λ; \\
      v_{00} \in V,\ v_{000} \in Λ &\implies (λv_{00}.v_{000}) \in Λ,\ v_{00} \in Λ; \\
      v_{00},\ (λv_{00}.v_{000}) \in Λ &\implies (v_{00} (λv_{00}.v_{000})) \in Λ; \\
      v_{0} \in V,\ (v_{00} (λv_{00}.v_{000})) \in Λ &\implies (λv_{0}.(v_{00} (λv_{00}.v_{000}))).
    \end{align*}
  \item[Por gramática] Se mantienen los espacios en los lados derechos de las producciones de la gramática para ser consistentes, sin embargo, el espacio en blanco no es un símbolo terminal, por lo tanto pueden ser omitidos.
    \begin{align*}
      T &\Rightarrow F \Rightarrow (\ λ\ A\ .\ T\ ) \Rightarrow (\ λ\ v_{0}\ .\ T\ ) \Rightarrow (\ λ\ v_{0}\ .\ E\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ T\ T\ )\ ) \\
        &\Rightarrow (\ λ\ v_{0}\ .\ (\ A\ T\ )\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ A_{0}\ T\ )\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ T\ )\ ) \\
        &\Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ F\ )\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ A\ .\ T\ )\ )\ ) \\
        &\Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ A_{0}\ .\ T\ )\ )\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ v_{00}\ .\ T\ )\ )\ ) \\
        &\Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ v_{00}\ .\ A\ )\ )\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ v_{00}\ .\ A_{0}\ )\ )\ ) \\
        &\Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ v_{00}\ .\ A_{00}\ )\ )\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ v_{00}\ .\ v_{000}\ )\ )\ ).
    \end{align*}
  \end{description}
\end{exmp}

\begin{exmp} Sea \( N = ((λv_{00}.v_{0}\, v_{00}) v_{0}) \), la cadena \( N \) no es un término lambda ya que

  \begin{description}
  \item[Por definición inductiva] Ya que \( Λ \) se definió como el \emph{conjunto más pequeño}, se demuestra que \( N \not\in Λ \) de la siguiente manera
    \begin{align*}
      (λv_{00}.v_{0}\, v_{00}), v_{0} \in Λ &\implies ((λv_{00}.v_{0}\, v_{00}) v_{0}) \in Λ; \\
      v_{00} \in V,\ v_{0}\, v_{00} \in Λ &\implies (λv_{00}.v_{0}\, v_{00}) \in Λ; \\
      v_{0}\, v_{00} \not\in Λ &\therefore ((λv_{00}.v_{0}\, v_{00}) v_{0}) \not\in Λ.
    \end{align*}
  \item[Por gramática] La gramática no es ambigua, realizando una derivación por la izquierda
    \begin{align*}
      T &\Rightarrow E \Rightarrow (\ T\ T\ ) \Rightarrow (\ F\ T\ ) \Rightarrow (\ (\ λ\ A\ .\ T\ )\ T\ ) \\
        &\Rightarrow (\ (\ λ\ A_{0}\ .\ T\ )\ T\ ) \Rightarrow (\ (\ λ\ v_{00}\ .\ T\ )\ T\ ) \\
        &\nRightarrow (\ (\ λ\ A\ .\ v_{0}\, v_{00}\ )\ T\ ).
    \end{align*}
  \end{description}
\end{exmp}

La sintaxis del cálculo lambda es uniforme, lo cual permite identificar su estructura con facilidad y evitar ambigüedades, sin embargo, suele ser tedioso escribir términos largos debido al extenso uso de paréntesis. Es por esto que en este trabajo se hacen las siguientes consideraciones sobre la notación:

\begin{enumerate}
\item \label{enum:notacion:1} El símbolo \( \synteq \) denota la equivalencia sintáctica entre dos términos lambda, esta equivalencia contempla las consideraciones de este listado.
\item \label{enum:notacion:2} Cuando se hace referencia a \emph{cualquier} término lambda se utilizan las letras mayúsculas \( M \), \( N \), \( P \), etc. Es importante establecer que si en un ejemplo, explicación, teorema o demostración se hace referencia a un término lambda con una letra mayúscula, cualquier otra aparición de esta letra hace referencia a este mismo término dentro de ese contexto.
\item \label{enum:notacion:3} Cuando se hace referencia a \emph{cualquier} átomo se utilizan las letras minúsculas \( x \), \( y \), \( z \), etc. Al igual que en el punto anterior, la aparición de una letra minúscula en un ejemplo, explicación, teorema o demostración hace referencia al mismo átomo.
\item \label{enum:notacion:4} Los paréntesis son omitidos de acuerdo a las siguientes equivalencias sintácticas:
  \begin{enumerate}
  \item \label{enum:notacion:4a} \( ((M\, N) P) \synteq M\, N\, P\), en general, se considera la aplicación de términos lambda con asociación a la izquierda. Se tiene que tener cuidado con respetar esta regla, por ejemplo \( (M(N(O\, P))) \synteq M(N(O\, P)) \not\synteq M\, N\, O\, P \).
  \item \label{enum:notacion:4b} \( (λx.(M N)) \synteq λx.(M N) \), en general, se puede escribir una abstracción omitiendo los paréntesis externos. Es necesario escribir de manera explícita los paréntesis en algunos casos, por ejemplo \( ((λx.(M\, N)) O) \synteq (λx.(M\, N)) O \not\synteq λx.(M\, N)O \) ya que el lado derecho de la equivalencia es sintácticamente equivalente a \( (λx.((M\, N)O)) \).
  \item \label{enum:notacion:4c} \( (λx.(λy.(λz.M))) \synteq (λx\, y\, z.M) \), en general, si el cuerpo de una abstracción es también una abstracción, se pueden agrupar las variables ligadas y enlazadas. Éste abuso de notación es consistente con la representación de funciones de varias variables usada por Schönfinkel \cite{Schonfinkel:Varargs}.
  \end{enumerate}
\item \label{enum:notacion:5} Para hacer referencia a una secuencia con una cantidad arbitraria de términos lambda se usa la notación \( \vec{x}=x_{1},...,x_{n} \) cuando es secuencia de átomos y \( \vec{M}=M_{1},...,M_{n} \) cuando es secuencia de términos lambda en general. Con esta notación se puede abreviar la consideración de \ref{enum:notacion:4a} como
  \[ ((\, ...\, ((M_{1}\, M_{2}) M_{3})\, ...\, ) M_{n}) \synteq \vec{M} \]
  y la consideración de \ref{enum:notacion:4c} como
  \[ (λx_{1}.(λx_{2}.(λx_{3}.\, ...\, (λx_{n}.M)\, ...\, ))) \synteq (λ\vec{x}.M) \]
  Ya que la notación no indica la cantidad de términos en la secuencia, se suele decir que \( \vec{M} \) cabe en \( \vec{N} \) cuando son secuencias con la misma cantidad de elementos.
\item Al escribir términos lambda con repetición de aplicaciones suele ser conveniente utilizar una notación más compacta. Cuando se aplica \( n \) veces un término \( F \) por la izquierda a otro término \( M \) se denota \( F^{n}\, M \). Cuando se aplica \( n \) veces un término \( M \) por la derecha a otro término \( F \) se denota \( F\, M^{\sim n}\). Por ejemplo, el término \( (f(f(f(f\, x)))) \) se puede denotar como \( (f^{4}\, x) \) y el término \( (f\, x\, x\, x\, x) \) se puede denotar como \( (f\, x^{\sim 4}) \). La definición inductiva de esta notación es:
  \begin{align}
    \label{eq:abuso:F}
    \begin{split}
      F^{n+1}\, M & \synteq F (F^{n}\, M) \\
      F^{0}\, M & \synteq M
    \end{split}
  \end{align}
  \begin{align}
    \label{eq:abuso:M}
    \begin{split}
      F\, M^{\sim n+1} & \synteq (F\, M^{\sim n}) M \\
      F\, M^{\sim 0} & \synteq F
    \end{split}
  \end{align}
\end{enumerate}

Inicialmente, estos abusos de notación pueden resultar confusos, sin embargo, al escribir términos lambda complejos resulta conveniente acortarlos. A continuación se muestran ejemplos de términos lambda asociados a términos sintácticamente equivalentes pero escritos con abuso de notación:

\begin{exmp}
  \label{exmp:notacion}
  \begin{align*}
    (((x\, y)z) (y\, x)) & \synteq x\, y\, z (y\, x) \\
    (λx.((u\, x)y)) & \synteq λx.u\, x\, y \\
    (λy.(u(λx.y))) & \synteq λy.u(λx.y) \\
    (((λy.((v\, u)u))z)y) & \synteq (λy.v\, u\, u) z\, y \\
    (((u\, x)(y\, z))(λv.(v\, y))) & \synteq u\, x(y\, z)(λv.v\, y) \\
    ((((λx.(λy.(λz.((x\, z) (y\, z))))) u) v) w) & \synteq (λx\, y\, z.x\, z(y\, z)) u\, v\, w
  \end{align*}
\end{exmp}

\subsection{Estructura}

Dado un término lambda \( M \) es deseable poder cuantificar algunas propiedades de acuerdo a su estructura, la medida más común es la de \emph{longitud}. Esta propiedad resulta importante en los razonamientos inductivos, por ejemplo, al plantear una demostración se suele usar la expresión ``por inducción sobre \( M \)'' la cual técnicamente se refiere a una inducción sobre la longitud de \( M \).

\begin{defn}[Longitud]
  La longitud de un término lambda \( M \), denotada como \( \| M \| \), es la cantidad de \emph{apariciones} de átomos en \( M \), se determina a partir de la estructura del término lambda como:
  \label{defn:longitud}
  \begin{align*}
    \|x\| & = 1 \\
    \|M\, N\| & = \|M\| + \|N\| \\
    \|λx.M\| & = 1 + \|M\|
  \end{align*}
\end{defn}

Debido a que la definición considera la cantidad de átomos en \( M \) y la longitud de un átomo es \( 1 \), se infiere que para cualquier término lambda \( M \), su longitud será estrictamente mayor a cero. Una implicación de esta observación es que al ``desbaratar'' la longitud de un término lambda de acuerdo a su estructura, en el caso de que \( M \) sea una aplicación o una abstracción, la longitud de sus partes es estríctamente menor a su longitud.

\begin{exmp} A continuación se presenta el procedimiento para calcular la longitud del término \( M \synteq (x(λy.y\, u\, x)) \) siguiendo la definición \ref{defn:longitud}
  \begin{align*}
    \| M \| &= \| (x(λy.y\, u\, x)) \| = \| (x (λy.((y\, u) x))) \\
            &= \| x \| + \| (λy.((y\, u) x)) \| = 1 + \| (λy.((y\, u) x)) \| \\
            &= 1 + ( 1 + \| ((y\, u) x) \|  ) = 2 + \| ((y\, u) x) \| \\
            &= 2 + \| (y\, u) \| + \| x \| = 2 + \| (y\, u) \| + 1 = 3 + \| (y\, u) \| \\
            &= 3 + \| y \| + \| u \| = 3 + 1 + 1 \\
            &= 5
  \end{align*}
\end{exmp}

Una cuestión importante al momento de demostrar un teorema o definir un concepto por inducción sobre un término lambda es que usualmente la inducción matemática relaciona proposiciones con números naturales. Sin embargo es posible tener dos términos diferentes \( M \) y \( N \) tal que \( \|M\| = \|N\| \), por ejemplo \( (λx.x) \) y \( (z\, z) \) tienen longitud \( 2 \).

La inducción sobre la longitud de un término lambda considera también la estructura del término, de tal manera que para una proposición \( P \) sobre un término lambda \( M \), los casos base de la inducción son aquellos en donde la estructura no es compuesta (en átomos cuya longitud siempre es \( 1 \)) y la hipótesis de inducción considera que \( P \) se cumple para los subtérminos de \( M \) cuya longitud siempre es estrictamente menor que \( \|M\| \).

En la definición de longitud se menciona de la cantidad de \emph{apariciones} de átomos en \( M \), el concepto de aparición de \( M \) en \( N \) para cualesquiera \( M \) y \( N \) se formaliza a partir del concepto de \emph{subtérmino}.

\begin{defn}[Subtérmino]
  \( M \) es un subtérmino de \( N \), denotado \( M \subset N \) si \( M \in \Sub(N) \), donde \( \Sub(N) \) es la colección de subtérminos de \( N \) definida de manera inductiva como
  \label{defn:subtermino}
  \begin{align*}
    \Sub(x) & = \{ x \} \\
    \Sub(λx.M) & = \Sub(M) \cup \{ λx.M \} \\
    \Sub(M\, N) & = \Sub(M) \cup \Sub(N) \cup \{ M\, N \}
  \end{align*}
\end{defn}

\begin{defn}[Aparición]
  La aparición de \( M \) en \( N \) implica que \( M \subset N \) o que \( M \) es \emph{el} argumento de una abstracción en \( N \).
  \label{defn:aparicion}
\end{defn}

Usualmente se habla de la aparición de \( M \) en \( N \) para referirse a una subtérmino en particular en \( N \), sin embargo, un subtérmino pude \emph{aparecer} varias veces en un término. Algunas clasificaciones de subtérminos son:

\begin{itemize}
\item Si \( M_{1} \) y \( M_{2} \) son subtérminos de \( N \) y no tienen átomos en común, se dice que son términos \emph{disjuntos} de \( N \), ya que si esta condición se cumple \( \Sub(M_{1}) \cap \Sub(M_{2}) = \emptyset \);
\item Si \( M \subset N \) y \( (M\, Z) \subset N \) se dice que \( M \) es un término \emph{activo} en \( N \), de lo contrario, se le llama \emph{pasivo};
\item Si \( M \subset N \) y \( (λx.M) \subset N \), se dice que la aparición \( M \) es el \emph{alcance} de la aparición del átomo \( x \) que acompaña a la \( λ \).
\end{itemize}

\begin{exmp}
  Sea \( M \synteq λx.x\, y (λz.y) \):
  \label{exmp:subterminos-apariciones}
  \begin{itemize}
  \item el término \( (x\, y) \subset M \);
  \item el átomo \( z \not\subset M \) pero si aparece en \( M \), debido a que \( z \) acompaña a una \( λ \);
  \item el término \( y(λz.y) \) a pesar de parecer ser un subtérmino de \( M \) no lo es, esto se puede corroborar escribiendo los términos sin el abuso de notación: \( y(λz.y) \synteq (y(λz.y)) \) y \( M \synteq λx.x y(λz.y) \synteq (λx.((x\, y)(λz.y))) \), en este caso, la clave está en observar la estructura de la aplicación \( (x\, y(λz.y)) \).
  \item Las apariciones de \( x \) y \( (λz.y) \) en \( M \) son disjuntas.
  \item Los términos \( x \) y \( (x\, y) \) son subtérminos activos de \( M \), mientras que \( y \) y \( (λz.y) \) son subtérminos pasivos.
  \end{itemize}
\end{exmp}

Los conceptos de longitud y de subtérmino nos permiten razonar de manera clara sobre la estructura de los términos lambda y con la clasificación de los subtérminos se puede caracterizar el rol que juegan las partes de un término en la estructura general.

\subsection{Clasificación}

A continuación se presentan algunos criterios para clasificar partes de los términos lambda y las propiedades que tienen los términos de acuerdo a su clasificación.

Al considerar las apariciones de átomos en un término lambda, es conveniente diferenciar a los átomos sintácticamente iguales dependiendo de el papel que juegan en el término.

\begin{defn}[Clasificación de variables]\label{defn:clasifvar}
  La aparición de un átomo \( x \) en un término \( P \) es llamada:
  \begin{itemize}
  \item \emph{variable ligada} si es un subtérmino de \( M \) en una abstracción \( (λx.M) \) en \( P \);
  \item \emph{variable enlazada} si y sólo si es la \( x \) que acompaña la \( λ \) de \( (λx.M) \) en \( P \);
  \item \emph{variable libre} en otro caso.
  \end{itemize}
\end{defn}

La diferencia entre un átomo \( x \subset M \) y una aparición de \( x \) en \( M \) es que la aparición se refiere a una variable en particular nombrada \( x \) en una parte específica de la estructura de \( M \). Por ejemplo, en el término lambda \( ((λx.x) x) \) la primera aparición del átomo \( x \) es una variable enlazada, la segunda aparición es una variable ligada y la tercera aparición es una variable libre.

Cuando se abordó el concepto de reducción en la sección \ref{sec:op-reduccion} la distinción entre una variable libre y una ligada era importante ya que las variables libres nunca son sustituídas en una reducción ya que el procedimiento relacionaba únicamente a las variables ligadas en el alcance de una abstracción activa.

\begin{exmp}
  Sea \( M \synteq x(λy.x\, y) \):
  \label{exmp:clasifvar}
  \begin{itemize}
  \item El átomo \( x \) aparece como variable libre dos veces en \( M \);
  \item El átomo \( y \) aparece como variable ligada en \( M \);
  \item El átomo \( y \) aparece como la variable enlazada de la abstracción.
  \end{itemize}
\end{exmp}

En la definición formal de algunos conceptos es conveniente hacer referencia a todas las variables libres de un término lambda.

\begin{defn}[Variables libres]
  El conjunto de variables libres de un término lambda \( M \) se denota \( \FV(M) \) y se define de manera inductiva como:
  \label{defn:varlib}
  \begin{align*}
    \FV(x) & = \{ x \} \\
    \FV(λx.M) & = \FV(M) \setminus \{ x \} \\
    \FV(M\, N) & = \FV(M) \cup \FV(N)
  \end{align*}
  Cuando \( \FV(M)=\emptyset \) se dice que \( M \) es un \emph{combinador} o \emph{término cerrado}.
\end{defn}

\begin{exmp}
  Consideremos los términos \( (x(λx.x\, y\, z)) \), \( (λx\, y\, z.y) \) y \( ((λy.x)λx.y) \).
  \label{exmp:varlib}
  \begin{itemize}
  \item \( \FV(x(λx.x\, y\, z)) = \{x,\ y,\ z\} \);
  \item \( \FV(λx\, y\, z.y)=\emptyset \), por lo tanto es un combinador;
  \item \( \FV((λy.x)λx.y)=\{ x,\ y \} \).
  \end{itemize}
\end{exmp}

En ocaciones es importante distinguir los términos lambda cerrados de aquellos que contienen variables libres, para ello se identifica el subconjunto de \( Λ \) que contiene a todos los términos cerrados:

\begin{defn}[Términos cerrados]
  Se denota como \( Λ^{0} \) al conjunto
  \label{defn:termcerr}
  \[ \{ M \in Λ \mid M \text{ es un término cerrado} \} \]
\end{defn}

La notación \( Λ^{0} \) se puede generalizar para identificar diferentes subconjuntos de \( Λ \) a partir de las variables libres de los términos lambda:

\[ Λ^{0}(\vec{x})=\{ M \in Λ \mid \FV(M) \subseteq \{ \vec{x} \} \} \]

De tal manera que:

\[ Λ^{0}=Λ^{0}(\emptyset) \]

Si consideramos un término \( M \) con variables libres, se puede encontrar otro término \( N \in Λ^{0} \) similar a \( M \), al cual se le llama clausura de \( M \).

\begin{defn}[Clausura] \label{defn:clausura}
  La clausura de un término lambda \( M \) con \( \FV(M) \not= \emptyset \) es un término lambda
  \[ (λ\vec{x}.M) \]
  con \( \vec{x}=\FV(M) \)
\end{defn}

\begin{exmp} \label{exmp:clausura}
  Sea \( M \synteq λz.x\, y\, z \)
  \begin{itemize}
  \item \( (λx\, y.λz.x\, y\, z) \) es una clausura de \( M \);
  \item \( (λy\, x\, z.x\, y\, z) \) es una clausura de \( M \);
  \item \( (λz\, x\, y.λz.x\, y\, z) \) no es una clausura de \( M \).
  \end{itemize}
\end{exmp}

\subsection{Sustitución de términos}

En la sección \ref{sec:op-sustitucion} se dió una descripción informal pero precisa de la sustitución en el cálculo lambda. A continuación se presenta la definición utilizando los conceptos introducidos en este capítulo.

\begin{defn}[Sustitución]
  \label{defn:sustitucion}
  Para cualesquiera términos lambda \( M \), \( N \) y \( x \), se define \( M[x:=N] \) como el resultado de sustituir cada aparición libre de \( x \) por \( N \) en \( M \) de acuerdo a las siguientes reglas:
  \begin{align*}
    x[x:=N] & \synteq N; \\
    a[x:=N] & \synteq a && a \not \synteq x; \\
    (P\, Q)[x:=N] & \synteq P[x:=N]\, Q[x:=N]; \\
    (λx.P)[x:=N] & \synteq λx.P; \\
    (λy.P)[x:=N] & \synteq λy.P && x \not\synteq y,\ x \not\in \FV(P); \\
    (λy.P)[x:=N] & \synteq λy.P[x:=N] && x \not\synteq y,\ x \in \FV(P),\ y \not\in \FV(N); \\
    (λy.P)[x:=N] & \synteq λz.P[y:=z][x:=N] && x \not\synteq y,\ x \in \FV(P),\ y \in \FV(N),\ z \not\in \FV(N P).
  \end{align*}
\end{defn}

\begin{exmp} \label{exmp:sustitucion}
  Procedimientos de sustituciones para cada uno de los casos de la definición \ref{defn:sustitucion}:
  \begin{itemize}
  \item Caso \( x[x:=N] \)
    \begin{align*}
      y[y:=λx.x] \synteq λx.x
    \end{align*}
  \item Caso \( a[x:=N] \), donde \( a \not\synteq x \)
    \begin{align*}
      z[w:=x\, x] \synteq z
    \end{align*}
  \item Caso \( (P\, Q)[x:=N] \)
    \begin{align*}
      (y\, x\, x)[x:=y] & \synteq ((y\, x) x)[x:=y] \\
                        & \synteq (y\, x)[x:=y]\, x[x:=y] \\
                        & \synteq (y[x:=y]\, x[x:=y]) y \\
                        & \synteq y\, y\, y
    \end{align*}
  \item Caso \( (λx.P)[x:=N] \)
    \begin{align*}
      (λf\, x.f\, f\, x)[f:=g] \synteq λf\, x.f\, f\, x
    \end{align*}
  \item Caso \( (λy.P)[x:=N] \), donde  \( x \not\synteq y \), \( x \not\in \FV(P) \)
    \begin{align*}
      (λf\, x.f\, f\, x)[f:=g] \synteq λf\, x.f\, f\, x
    \end{align*}
  \item Caso \( (λy.P)[x:=N] \), donde \( x \not\synteq y \), \( x \in \FV(P) \), \( y \not\in \FV(N) \)
    \begin{align*}
      (λf.x\, λx.f\, f\, x)[x:=y] & \synteq λf.(x\, λx.f\, f\, x)[x:=y] \\
                                  & \synteq λf.x[x:=y]\, (λx.f\, f\, x)[x:=y] \\
                                  & \synteq λf.y\, λx.f\, f\, x
    \end{align*}
  \item Caso \( (λy.P)[x:=N] \), donde \( x \not\synteq y \), \( x \in \FV(P) \), \( y \in \FV(N) \) y \( z \not\in \FV(N P) \)
    \begin{align*}
      (λf.x\, λx.f\, f\, x)[x:=f] & \synteq λg.(x\, λx.f\, f\, x)[f:=g][x:=f] \\
                                  & \synteq λg.(x[f:=g](λx.f\, f\, x)[f:=g])[x:=f] \\
                                  & \synteq λg.(x\, λx.(f\, f\, x)[f:=g])[x:=f] \\
                                  & \synteq λg.(x\, λx.((f\, f)[f:=g] x[f:=g]))[x:=f] \\
                                  & \synteq λg.(x\, λx.((f[f:=g]\, f[f:=g]) x))[x:=f] \\
                                  & \synteq λg.(x\, λx.g\, g\, x)[x:=f] \\
                                  & \synteq λg.x[x:=f] (λx.g\, g\, x)[x:=f] \\
                                  & \synteq λg.f\, λx.g\, g\, x
    \end{align*}
  \end{itemize}
\end{exmp}

En el último caso es importante observar que las apariciones ligadas de \( x \) no se sustituyen.

Las siguientes equivalencias de sustituciones múltiples son importantes para resaltar la relevancia de los detalles de la definición \ref{defn:sustitucion}.

\begin{itemize}
\item \( \subst{\subst{M}{x}{y}}{y}{P} \)
  
  Esta operación es equivalente a \( \subst{M}{x}{P} \) siempre y cuando \( y\not\in \FV(M) \), de otro modo, \( M \) tiene variables sustituíbles \( y \) que no serán sustituídas con \( \subst{M}{x}{P} \).
\item \( \subst{\subst{M}{x}{y}}{y}{x} \)

  Esta operación es equivalente a \( M \) siempre y cuando \( y\not\in \FV(M) \), el argumento es el mismo que el punto anterior.
\item \( \subst{\subst{M}{y}{Q}}{x}{P} \)

  Esta operación debe analizarse por casos ya que \( P \) y \( Q \) pudieran o no contener apariciones  de \( x \) y \( y \):
  \begin{itemize}
  \item Es equivalente a \( \subst{\subst{M}{x}{P}}{y}{Q} \) cuando \( y\not\in \FV(P) \) y \( x\not\in \FV(Q) \) ya que ni la primer operación no introduce variables libres \( x \) no afecta el resultado de la segunda operación y ya que la segunda operación no introduce variables libres \( y \) no afecta invertir el orden de las operaciones.
  \item Cuando la segunda operación no introduce variables libres \( y \) pero la primera operación si introduce variables libres \( x \) es equivalente a \( \subst{\subst{M}{x}{P}}{y}{\subst{Q}{x}{P}} \), es decir, se sustituyen las variables libres \( x \) de \( Q \) por las que se sustituirían con la operación original y se procede como en el punto anterior.
  \end{itemize}
\item \( \subst{\subst{M}{x}{Q}}{x}{P} \)

  Esta operación es equivalente a \( \subst{M}{x}{\subst{Q}{x}{P}} \), debido a que la sustitución de \( x \) por \( P \) tiene efecto únicamente cuando \( Q \) introduce variables \( x \) libres, por lo tanto, cambiar las \( x \) libres de \( Q \) por \( P \) antes de hacer la primera operación produce el resultado correcto.
\end{itemize}

\begin{lem}
  Si \( (y\, x) \not\in \FV(L) \) y \( x \not\synteq y \), entonces
  \[ M[x:=N][y:=L] \synteq M[y:=L][x:=N[y:=L]] \]
\end{lem}

En contraste a la operación de sustitución en donde no se permite introducir o quitar referencias a variables enlazadas, el \emph{contexto} es un término con ``hoyos'':

\begin{defn}[Contexto]
  \label{defn:contexto}
  Un contexto es un término lambda denotado \( C[\quad] \) definido de manera inductiva:
  \begin{itemize}
  \item \( x \) es un contexto;
  \item \( [\quad] \) es un contexto;
  \item Si \( C_{1}[\quad] \) y \( C_{2}[\quad] \) son contextos, entonces \( C_{1}[\quad]\, C_{2}[\quad] \) y \( λx.C_{1}[\quad] \) también lo son.
  \end{itemize}
\end{defn}

Si \( C[\quad] \) es un contexto y \( M \in Λ \), entonces \( C[M] \) denota el resultado de reemplazar por \( M \) los hoyos de \( C[\quad] \). Al realizar esto, las variables libres de \( M \) pueden convertirse en variables ligadas de \( C[M] \).

\begin{exmp}
  Consideremos el contexto \( C[\quad] \synteq λx.x\, λy.[\quad] \) y el término lambda \( M \synteq (x y) \).
  
  \begin{align*}
    C[M] & \synteq (λx.x\, λy.[\quad])[(x\, y)] \\
         & \synteq (λx.x\, λy.(x\, y))
  \end{align*}
  
  El caso análogo con la sustitución es

  \begin{align*}
    (λx.x\, λy.w)[w:=(x\, y)] & \synteq λz.(x\, λy.w)[x:=z][w:=(x\, y)] \\
                              & \synteq λz.(x[x:=z] (λy.w)[x:=z])[w:=(x\, y)] \\
                              & \synteq λz.(z\, λy.w)[w:=(x y)] \\
                              & \synteq λz.z[w:=(x\, y)] (λy.w)[w:=(x\, y)] \\
                              & \synteq λz.z\, λv.w[w:=(x\, y)] \\
                              & \synteq λz.z\, λv.(x\, y)
  \end{align*}
\end{exmp}

\section{Los cálculos de la conversión lambda}
\label{sec:conversion-lambda}

El objetivo principal de esta subsección es presentar una formalización del cálculo lambda descrito en el capítulo \ref{ch:nocion-informal} desde el punto de vista de \emph{teorías formales}. El nombre técnico de la teoría formal principal de este trabajo es \( \bs{λKβ} \), se pueden realizar modificaciones y extensiones a esta teoría y los siguientes conceptos permiten estudiar las implicaciones de estos cambios.

\subsection{Teorías formales}
\label{sec:teorias-formales}

Una \emph{teoría formal} \( \mathcal{T} \) es una tripleta \( (\mathcal{F},\mathcal{A},\mathcal{R}) \) donde

\begin{itemize}
\item \( \mathcal{F} \) es el conjunto de todas las \emph{fórmulas} \( X = Y \) con \( X \) y \( Y \) elementos de un lenguaje formal;
\item \( \mathcal{A} \) es un conjunto de \emph{axiomas} y \( \mathcal{A} \subseteq \mathcal{F} \);
\item \( \mathcal{R} \) es un conjunto de \emph{reglas}.
\end{itemize}

Una regla es una función \( φ \colon \mathcal{F}^{n} \to \mathcal{F} \) con \( n \geq 1 \). Si se consideran \( n \) fórmulas \( A_{1},\ ...\ ,\ A_{n} \) tal que

\[ φ(A_{1},\ ...\ ,\ A_{n})=B \]

Se dice que la secuencia \( \langle A_{1},\ ...\ ,\ A_{n},\ B \rangle \) es una \emph{instancia} de la regla \( φ \). Las primeras \( n \) fórmulas de una instancia son llamadas \emph{premisas} y la última fórmula es llamada \emph{conclusión}. Para escribir una instancia de una regla se utiliza la notación

\[ \infer{B}{A_{1} & ... & A_{n}} \]

\begin{rem}
  En la literatura se pueden encuentrar diferentes maneras de trabajar con teorías formales, dependiendo de su ``estilo'' y definición, por ejemplo en \cite{Troelstra:ProofTheory} las reglas se definen como conjuntos de secuencias \( \langle A_{1},...,A_{n+1} \rangle \) con \( n \) premisas y una conclusión, en donde los axiomas se definen como elementos de \( \mathcal{R} \) con cero premisas. La definición de teoría formal presentada en este trabajo es del estilo Hilbert y está basada en \cite[pp.~69--70]{HindleySeldin:LambdaCalculusAndCombinators}.
\end{rem}

Si consideramos un conjunto de \emph{suposiciones} \( Γ \subseteq \mathcal{F} \), una \emph{deducción} de una fórmula \( B \) desde \( Γ \) es un árbol dirigido de fórmulas en donde los vértices de un extremo son elementos de \( \mathcal{A} \) o \( Γ \), los vértices intermedios son deducidos a partir de los vértices que inciden en ellos a partir de una regla y el vértice de el otro extremo siendo \( B \). Si y solo si existe una deducción para una fórmula \( B \), se dice que \( B \) es \emph{demostrable} en \( \mathcal{T} \) suponiendo \( Γ \), denotado

\[ \mathcal{T},Γ \vdash B \]

En caso que la deducción no tenga suposiciones, se dice que es una \emph{demostración} y que \( B \) es un \emph{teorema}. Cuando una deducción no tiene suposiciones, es decir, \( Γ = \emptyset \) se denota

\[ \mathcal{T} \vdash B \]

La relación binaria \( = \) en las fórmulas de una teoría es una relación de equivalencia, la cual por definición es \emph{reflexiva}, \emph{simétrica} y \emph{transitiva}. La \emph{clase de equivalencia} de un objeto \( x \) con respecto a \( = \) de una teoría formal \( \mc{T} \), denotado \( [x]_{\mc{T}} \), es el conjunto de todos los objetos \( y \) tal que \( x = y \) es una fórmula de \( \mc{T} \).

En el contexto de las teorias que formalizan los cálculos lambda, los objetos que se relacionan son términos lambda. La frase ``módulo convertibilidad'' se refiere al conjunto de todas las clases de equivalencia de \( Λ \) considerando la relación de equivalencia de la teoría formal con la que se esté trabajando.

Que este conjunto sea el objeto de estudio de una teoría \( \bs{λ} \) del cálculo lambda significa que cada elemento de \( Λ \) módulo convertibilidad, denotado \( Λ/\!=_{\bs{λ}} \), es distinto y representa una clase de términos lambda considerados en la teoría \( \bs{λ} \) como equivalentes. Cuando \( \bs{λ} \vdash M = N \) se dice que \( M \) y \( N \) son términos \emph{convertibles}, también denotado \( M =_{\bs{λ}} N \).

Habiendo definido una teoría \( \bs{λ} \), el interés de estudiarla es

\begin{itemize}
\item determinar los términos que son convertibles en \( \bs{λ} \);
\item estudiar las propiedades que comparten dos términos convertibles;
\item modificar a \( \bs{λ} \) y comparar la teoría modificada con la original.
\end{itemize}

La comparación entre teorías usualmente consiste en partir de una teoría \( \bs{λ} \), modificar sus fórmulas, axiomas o reglas para obtener otra teoría \( \bs{λ}^{\prime} \) y determinar si \( \bs{λ} \) y \( \bs{λ}^{\prime} \) son equivalentes. Para poder realizar esto, se debe definir formalmente cómo se modifica una teoría y cómo se demuestra que dos teorías son equivalentes.

Modificar una teoría \( \bs{λ} \) puede implicar cambiar la definición de sus términos, es decir, utilizar un lenguaje formal diferente al de \( \bs{λ} \) para expresar las fórmulas \( M=N \). Hacer cambios al lenguaje formal suele requerir modificar al conjunto \( \mc{F} \), \( \mc{A} \) y \( \mc{R} \) de la teoría.

La modificación al lenguaje formal puede ser únicamente de relevancia sintáctica, por ejemplo modificar una teoría \( \bs{λ} \) cuyo lenguaje de términos es el conjunto \( Λ^{0} \) para que los términos sean escritos con el índice de DeBruijn mostrado en \ref{exmp:debrujn} no tendría implicaciones fuertes en la convertibilidad de la teoría, ya que hay una correspondencia uno a uno entre estas dos notaciones. Por otro lado, modificar una teoría \( \bs{λ} \) con términos \( Λ \) de tal manera que se consideren únicamente los términos cerrados \( Λ^{0} \) si puede tener fuertes implicaciones en la convertibilidad de la teoría ya que habrá términos lambda no admitidos en fórmulas.

Otra manera de modificar una teoría \( \bs{λ} \) es añadir o quitar axiomas y reglas de inferencia. Para abordar la modificación de estas dos componentes de una teoría consideramos que los axiomas son reglas sin premisas.

Cuando se considera extender una teoría \( \bs{λ} \) con una nueva regla \( φ \) lo primero que se debe estudiar es si \( φ \) es \emph{derivable} en \( \bs{λ} \), es decir, si para cada instancia de \( φ \), su conclusión es deducible en \( \bs{λ} \) considerando sus premisas como suposiciones. Formalmente, para cada instancia \( \langle A_{1},\ ...\ ,\ A_{n},\ B \rangle \) de \( φ \), \( φ \) es derivable en \( \bs{λ} \) si y sólo si

\begin{equation}
  \label{eq:teorias-derivable}
  \bs{λ},\ \{ A_{1},\ ...\ ,\ A_{n} \} \vdash B
\end{equation}

Cuando añadir una regla \( φ \) a una teoría \( \bs{λ} \) no cambia el conjunto de teoremas se dice que la regla es \emph{admisible}, por ejemplo si \( φ \) es utilizada en la demostración de un teorema, pero este teorema se puede demostrar sin suponer las premisas de \( φ \), entonces añadir a \( φ \) no afecta el hecho de que el teorema exista en la teoría.

Otra manera de verificar si una regla \( φ \) es admisible en \( \bs{λ} \) es demostrando que la regla es \emph{correcta}. Una regla se dice ser correcta en una teoría \( \bs{λ} \) si y sólo si, para cada instancia \( \langle A_{1},\ ...\ ,\ A_{n},\ B \rangle \) de \( φ \):

\begin{equation}
  \label{eq:teorias-correcta}
  (\bs{λ} \vdash A_{1}),\ ...\ ,\ (\bs{λ} \vdash A_{n}) \implies (\bs{λ} \vdash B)
\end{equation}

Si una regla es derivable, entonces es admisible, sin embargo, una regla admisible no siempre es derivable. Consideremos una instancia \( \mc{r} \) de una regla admisible en \( \bs{λ} \) tal que ni las premisas, ni la conclusión de \( \mc{r} \) son demostrables en la teoría, entonces la implicación \eqref{eq:teorias-correcta} es verdadera para \( \mc{r} \), sin embargo esto no implica que se pueda demostrar la conclusión suponiendo las premisas. Por otro lado, si consideramos una instancia \( \mc{r} \) de una regla derivable en \( \bs{λ} \), entonces ya que la conclusión es demostrable suponiendo las premisas, demostrar las premisas asegura que se puede demostrar la conclusión.

Con estos conceptos se pueden definir dos criterios de equivalencia entre teorías: \emph{equivalentes en teoremas} y \emph{equivalentes en reglas}.

\begin{defn}[Equivalencia de teorías] \label{defn:teorias-equivalentes}
  Sean \( \bs{λ} \) y \( \bs{λ}^{\prime} \) dos teorías formales con el mismo conjunto de fórmulas.

  Se dice que las teorías son \emph{equivalentes en teoremas} cuando cada regla y axioma de \( \bs{λ} \) es admisible en \( \bs{λ}^{\prime} \) y viceversa.

  Se dice que las teorías son \emph{equivalentes en reglas} cuando cada regla y axioma de \( \bs{λ} \) es derivable en \( \bs{λ}^{\prime} \) y viceversa.

  La equivalencia en teoremas es una equivalencia más débil que la equivalencia en reglas.
\end{defn}

\subsection{Teoría \( \bs{λKβ} \)}
\label{sec:teorialambda}

La teoría \( \bs{λKβ} \) es la formalización del cálculo lambda que se ha tratado desde el inicio de este trabajo. Ya que es la teoría principal, a partir de este punto cuando se hable de \emph{la} teoría \( \bs{λ} \) se estará refiriendo a la teoría \( \bs{λKβ} \) y cuando se hable de \emph{las} teorías \( \bs{λ} \) se estará refiriendo a la familia de teorías que formalicen los cálculos lambda.

\begin{defn}[Teoría \( \bs{λKβ} \)]
  \label{defn:teorialambda}

  El conjunto de fórmulas \( \mc{F} \) en \( \bs{λKβ} \) tiene como elementos ecuaciones de la forma:

  \begin{align*}
    M = N & & \forall M,N \in Λ \text{ (de la definición~\ref{defn:terminos})}
  \end{align*}
  
  Los axiomas \( \mc{A} \) de \( \bs{λKβ} \) son:

  \begin{subequations}
    \begin{align}
      \label{teorialambda:alpha} \tag{\( α \)}
      λx.M & = λy.M[x:=y] & &  \forall y \not\in \FV(M) \\
      \label{teorialambda:beta} \tag{\( β \)}
      (λx.M)N & = M[x:=N] \\
      \label{teorialambda:rho} \tag{\( ρ \)}
      M & = M
    \end{align}
  \end{subequations}

  Las reglas \( \mc{R} \) de \( \bs{λKβ} \) son:

  \begin{equation}
    \label{teorialambda:mu} \tag{\( μ \)}
    \infer{Z\, M = Z\, N}{M = N}
  \end{equation}
  \begin{equation}
    \label{teorialambda:nu} \tag{\( ν \)}
    \infer{M\, Z = N\, Z}{M = N}
  \end{equation}
  \begin{equation}
    \label{teorialambda:xi} \tag{\( ξ \)}
    \infer{λx.M = λx.N}{M = N}
  \end{equation}
  \begin{equation}
    \label{teorialambda:tau} \tag{\( τ \)}
    \infer{M = P}{M = N & N = P}
  \end{equation}
  \begin{equation}
    \label{teorialambda:sigma} \tag{\( σ \)}
    \infer{N = M}{M = N}
  \end{equation}
  
\end{defn}

Consideremos la convertibilidad en \( \bs{λKβ} \) de los términos lambda
\begin{align*}
  M &\synteq (λf.x((λy.y\, f) λz.z))w \\
  N &\synteq x\, w
\end{align*}

Se demuestra que \( M=_{\bs{λKβ}}N \) construyendo un árbol de deducción como el de la figura \ref{fig:demostrabilidad}.

\begin{figure}[h!]
  \centering
  \begin{tikzpicture}[
    equat/.style={rectangle,draw},grow=up,edge from parent/.style={draw,latex-},
    level 1/.style={sibling distance=15em, level distance=4em},
    level 2/.style={sibling distance=40em},
    level 3/.style={sibling distance=20em},
    level 4/.style={sibling distance=10em}
    ]
    \node [equat] (foo1) {\( (λf.x((λy.y\, f) λz.z))w = x\, w \)}
    child {
      node [equat] (foo3) {\( (λf.x\, f)w = x\, w \)}
    }
    child {
      node [equat] (foo5) {\( (λf.x((λy.y\, f) λz.z))w = (λf.x\, f)w \)}
      child {
        node [equat] (foo7) {\( λf.x((λy.y\, f) λz.z) = λf.x\, f \)}
        child {
          node [equat] (foo9) {\( x((λy.y\, f) λz.z) = x\, f \)}
          child {
            node [equat] (foo11) {\( (λy.y\, f)λz.z = f \)}
            child {
              node [equat] (foo13) {\( (λz.z)f = f \)}
            }
            child {
              node [equat] (foo14) {\( (λy.y\, f)λz.z = (λz.z) f \)}
            }
            edge from parent [] node [right] {\( (μ) \)}
          }
          edge from parent [] node [right] {\( (ξ) \)}
        }
        edge from parent [] node [right] {\( (ν) \)}
      }
    };
    \node [above=0em of foo13] (bar1) {\( (β) \)};
    \node [above=0em of foo14] (bar2) {\( (β) \)};
    \node [above=0em of foo11] (bar3) {\( (τ) \)};
    \node [above=0em of foo1] (bar4) {\( (τ) \)};
    \node [above=0em of foo3] (bar5) {\( (β) \)};
  \end{tikzpicture}
  \caption{Árbol de deducción para demostrar la convertibilidad entre dos términos}
  \label{fig:demostrabilidad}
\end{figure}

La teoría \( \bs{λ} \) puede ser modificada de muchas maneras, en este trabajo se considera una extensión no trivial a esta teoría con interpretaciones y consecuencias interesantes.

El concepto de igualdad de funciones usado en la mayoría de las ramas de la matemática tiene una propiedad conocida como \emph{extensionalidad}, esta propiedad de las relaciones de equivalencia hace referencia a las características externas de los objetos que compara, en el caso de las funciones, esto implica que para funciones \( f \) y \( g \) con el mismo dominio

\[ \forall x\ f(x)=g(x) \implies f=g \]

Contrario a esta propiedad de las funciones, en la computación, el tema central son los procedimientos y procesos que describen los programas o algoritmos, cuyas igualdades son \emph{intensionales}, es decir, si dos programas computan la misma función matemática, no necesariamente se dice que son el mismo programa ya que uno pudiera ser, por ejemplo, más eficiente que otro y la eficiencia es una característica interna de cada algorítmo, independiente de los resultados que computa.

La teoría \( \bs{λ} \) también es intensional ya existen dos términos lambda \( F \) y \( G \) tales que para tódo término \( X \) la aplicación \( (F\, X) \) es convertible a \( (G\, X) \) pero \( F \not=_{\bs{λ}} G \).

Consideremos por ejemplo, dos términos \( F \synteq y \) y \( G \synteq λx.y\, x \). Claramente \( F \not=_{\bs{λ}} G \), sin embargo al aplicar estos dos términos a un término cualquiera \( M \) se tiene que
\begin{align*}
  G\, X &=_{\bs{λ}} (λx.y\, x) X \\
        &=_{\bs{λ}} y\, X \\
        &=_{\bs{λ}} F\, X
\end{align*}

Cuando se plantea formalizar un cálculo lambda que sea extensional, surge la pregunta, ¿Qué es demostrable en la teoría extensional que no es demostrable en \( \bs{λ} \). A continuación se presentan tres diferentes agregados a la teoría \( \bs{λ} \) las cuales incluyen la propiedad de extensionalidad y que han sido propuestas en la literatura \cite{HindleySeldin:LambdaCalculusAndCombinators,Barendregt:Bible}. Las teorías extendidas son llamadas \( \bs{λζ} \), \( \bs{λ+ext} \) y \( \bs{λη} \) de acuerdo a la regla que se añade a la definición \ref{defn:teorialambda}.

\begin{defn}[Reglas de extensionalidad]
  \label{defn:extensionalidad}
  Cada una de las siguientes reglas nos permite añadir a \( \bs{λ} \) la propiedad de extensionalidad.
  \begin{description}
  \item[Reglas de inferencia]
    \begin{subequations}
      \begin{align}
        \label{extensionalidad:zeta} \tag{\( ζ \)}
        \infer{M = N}{M\, x = N\, x} & & \text{si \( x \not\in \FV(M\, N) \)} \\
        \label{extensionalidad:ext} \tag{ext}
        \infer{M = N}{M\, P = N\, P} & & \forall P \in Λ
      \end{align}
    \end{subequations}
  \item[Axiomas]
    \begin{align}
      \label{extensionalidad:eta} \tag{\( η \)}
      λx.M\, x = M & & \text{si \( x \not\in \FV(M) \)}
    \end{align}
  \end{description}
\end{defn}

Hindley y Seldin en \cite[p.~77]{HindleySeldin:LambdaCalculusAndCombinators} presentan las reglas \eqref{extensionalidad:zeta} y \eqref{extensionalidad:ext} como equivalentes, explicadas de manera informal como ``Si \( M \) y \( N \) tienen el mismo efecto sobre un objeto, entonces \( M=N \)''. En este trabajo se consideran dos teorías modificadas a partir de \( \bs{λ} \):

\begin{itemize}
\item La teoría \( \bs{λζ} \) es igual que \( \bs{λ} \) pero incluyendo también la regla \( ζ \);
\item La teoría \( \bs{λη} \) es igual que \( \bs{λ} \) pero incluyendo también el axioma \( η \).
\end{itemize}

El ejemplo presentado para introducir la propiedad de extensionalidad es precisamente el axioma \( η \), en \cite[p.~32]{Barendregt:Bible} se presenta el siguiente teorema y demostración.

\begin{thm} \label{thm:extencional-equivalentes}
  Las teorías \( \bs{λζ} \) y \( \bs{λη} \) son equivalentes en reglas.

  \begin{proof}[Demostración] Primero, se demuestra que la fórmula \( η \) es derivable en \( \bs{λζ} \):
    \begin{enumerate}
    \item Aplicando \( β \), se tiene que \( (λx.M\, x)x =_{\bs{λζ}} (M\, x) \) si \( x\not\in \FV(M) \);
    \item Aplicando \( ζ \), se tiene que \( (λx.M\, x) =_{\bs{λζ}} M \).
    \end{enumerate}
    Después, se demuestra que la regla \( ζ \) es derivable en \( \bs{λη} \):
    \begin{enumerate}
    \item Se parte de la primicia \( (M\, x) =_{\bs{λη}} (N\, x) \) si \( x\not\in \FV(M) \);
    \item Aplicando \( ξ \), se tiene que \( (λx.M\, x) =_{\bs{λη}} (λx.N\, x) \);
    \item Aplicando \( η \), se tiene que \( M =_{\bs{λη}} N \).
    \end{enumerate}
  \end{proof}
\end{thm}

En \cite{HindleySeldin:LambdaCalculusAndCombinators,Barendregt:Bible} se le da un tratamiento más extenso a diferentes teorías formales del cálculo lambda y otros sistemas similares, incluyendo aquellas con la propiedad de extensionalidad.

\subsection{Lógica combinatoria}
\label{sec:logica-combinatoria}

En esta sección se introduce una teoría similar en objetivos y contemporánea al cálculo lambda, llamada lógica combinatoria. Creada inicialmente por Moses Schönfinkel pero desarrollada extensamente por Haskell Curry en la década de 1930, la lógica combinatoria tiene tanto en común con el cálculo lambda, que comparten una grán cantidad de definiciones, teoremas y extensiones.

En este trabajo no se desarrolla la lógica combinatoria, pero se presenta la teoría \( \bs{CLω} \) que formaliza este sistema para su comparación con \( \bs{λKβ} \).

Los términos de la lógica combinatoria \( CL \) se definen de la siguiente manera

\begin{defn}[Términos CL]\label{defn:terminos-cl}
  Sea \( V \) el conjunto de variables \( \{v_{0},\ v_{00},\ v_{000},\ ...\} \) y \( C \) el conjunto de constantes atómicas \( \{ \bs{I},\ \bs{K},\ \bs{S} \} \). El conjunto de términos de la lógica combinatoria, denotado \( CL \) se define de manera inductiva de la siguiente manera:
  \begin{subequations}
    \begin{align}
      \label{terminos-cl:atomos} \tag{a}
      x \in V & \implies x \in CL \\
      \label{terminos-cl:constantes} \tag{b}
      x \in C & \implies x \in CL  \\
      \label{terminos-cl:aplicaciones} \tag{c}
      X,\ Y \in CL & \implies (X\, Y) \in CL
    \end{align}
  \end{subequations}
\end{defn}

Como se puede apreciar en la definición de \( CL \), los términos en la lógica combinatoria son parecidos a los términos en el cálculo lambda, sólo que en \( CL \) no hay abstracciones y en \( Λ \) no hay constantes atómicas.

\begin{defn}[Teoría \( \bs{CLω} \)] \label{defn:teoria-cl}
  El conjunto de fórmulas \( \mc{F} \) en \( \bs{CLω} \) tiene como elementos ecuaciones de la forma:
  \begin{align*}
    X=Y && \forall X,\ Y \in CL \text{ (de la definición \ref{defn:terminos-cl})}
  \end{align*}

  Los axiomas \( \mc{A} \) de \( \bs{CLω} \) son:
  \begin{subequations}
    \begin{align}
      \label{teoriacl:I} \tag{\( \bs{I} \)}
      \bs{I}\, X &= X \\
      \label{teoriacl:K} \tag{\( \bs{K} \)}
      \bs{K}\, X\, Y & = X \\
      \label{teoriacl:S} \tag{\( \bs{S} \)}
      \bs{S}\, X\, Y\, Z & = X\, Z(Y\, Z) \\
      \label{teoriacl:ro} \tag{\( ρ \)}
      X &= X
    \end{align}
  \end{subequations}
  Las reglas \( \mc{R} \) de \( \bs{CLω} \) son:
  \begin{equation}
    \label{teoriacl:mu} \tag{\( μ \)}
    \infer{Z\, X = Z\, X^{\prime}}{X = X^{\prime}}
  \end{equation}
  \begin{equation}
    \label{teoriacl:nu} \tag{\( ν \)}
    \infer{X\, Z = X^{\prime}\, Z}{X = X^{\prime}}
  \end{equation}
  \begin{equation}
    \label{teoriacl:tau} \tag{\( τ \)}
    \infer{X = Z}{X = Y & Y = Z}
  \end{equation}
  \begin{equation}
    \label{teoriacl:sigma} \tag{\( σ \)}
    \infer{Y = X}{X = Y}
  \end{equation}
\end{defn}
  
Existen equivalencias entre modificaciones de teorías del cálculo lambda y la lógica combinatoria \cite[pp.~92--106]{HindleySeldin:LambdaCalculusAndCombinators}, pero en este trabajo se muestra una introducción a las similitudes entre \( \bs{λ} \) y \( \bs{CLω} \), en particular, la correspondencia entre las clases de términos de \( \bs{CLω} \) que se pueden representar en \( \bs{λ} \) y viceversa.
  
Es sencillo representar las constantes atómicas de \( CL \) utilizando abstracciones del cálculo lambda. Los términos que representen a \( \bs{I} \), \( \bs{K} \) y \( \bs{S} \) en \( Λ \) deben satisfacer las reglas \eqref{teoriacl:I}, \eqref{teoriacl:K} y \eqref{teoriacl:S} de la definición \ref{defn:teoria-cl}.

\begin{defn}[Constantes \( \bs{I} \), \( \bs{K} \) y \( \bs{S} \) en \( Λ \)]
  \label{defn:ski}
  \begin{align*}
    \bs{I} & \synteq λx.x \\
    \bs{K} & \synteq λx\, y.x \\
    \bs{S} & \synteq λx\, y\, z.x\, z(y\, z)
  \end{align*}
\end{defn}

Se corroboran estas definiciones considerando a \( M \), \( N \) y \( Z \)  en \( Λ \) utilizando el axioma \( (β) \) de \( \bs{λ} \).

\begin{align*}
  \bs{I}\, M &=_{\bs{λ}} (λx.x) M \\
             &=_{\bs{λ}} M \\
  \bs{K}\, M\, N &=_{\bs{λ}} (λx\, y.x)M\, N \\
             &=_{\bs{λ}} (λy.M)N\\
             &=_{\bs{λ}} M \\
  \bs{S}\, M\, N\, Z &=_{\bs{λ}} (λx\, y\, z.x\, z(y\, z))M\, N\, Z \\
             &=_{\bs{λ}} (λy\, z.M\, z(y\, z)) \\
             &=_{\bs{λ}} (λz.M\, z(N\, z)) \\
             &=_{\bs{λ}} M\, Z(N\, Z)
\end{align*}

Las variables en \( CL \) pueden representarse en \( Λ \) como átomos, las aplicaciones en \( CL \) como aplicaciones en \( Λ \) y el resto de los axiomas y reglas en \( \bs{CLω} \) tienen sus contrapartes en \( \bs{λ} \). Por lo tanto, todo término en \( CL \) puede ser representado con términos en \( Λ \) y toda deducción realizada en \( \bs{CLω} \) puede también realizarse en \( \bs{λ} \) considerando la definición \ref{defn:ski}.

Por otra parte, la lógica combinatoria puede representar grán parte del cálculo lambda, pero no todo. En particular la regla \( (ξ) \) en \( \bs{λ} \) no es admisible en la teoría \( \bs{CLω} \) \cite[p.~92]{HindleySeldin:LambdaCalculusAndCombinators}.

Con la teoría \( \bs{CLω} \) se puede generar al conjunto \( Λ^{0} \) con combinaciones de aplicaciones. Debido a que \( \bs{SKK} =_{\bs{λ}} \bs{I} \), sólo es necesario combinar con aplicaciones a \( \bs{K} \) y a \( \bs{S} \) para generar cualquier término cerrado.

\begin{defn}[Bases]
  \label{defn:bases}
  El concepto de \emph{base} es de importancia para plantear formalmente la proposición anterior.
  \begin{enumerate}
  \item Sea \( \mathcal{X} \subset Λ \). El conjunto de términos \emph{generado} por \( \mathcal{X} \), denotado \( \mathcal{X}^{+} \), es el conjunto mas pequeño tal que
    \begin{enumerate}
    \item \( \mathcal{X} \subseteq \mathcal{X}^{+} \),
    \item \( M, N \in \mathcal{X}^{+} \implies (M N) \in \mathcal{X}^{+} \).
    \end{enumerate}
  \item Sea \( \mathcal{P}, \mc{X} \subset Λ \). \( \mathcal{X} \) es una \emph{base} para \( \mathcal{P} \) si para toda \( M \in \mathcal{P} \) existe \( N \in \mathcal{X}^{+} \) tal que \( N = M \).
  \item \( \mathcal{X} \) es llamada una \emph{base} si \( \mathcal{X} \) es una base para \( Λ^{0} \).
  \end{enumerate}
\end{defn}

\begin{prop}
  \label{prop:ski}
  \( \{ \bs{S}, \bs{K}, \bs{I} \} \) es una base, es decir, para todo término \( M \in Λ^{0} \), existe un término \( M' \) compuesto de aplicaciones de \( \bs{S} \), \( \bs{K} \) e \( \bs{I} \) tal que \( M =_{\bs{λ}} M' \).
\end{prop}

La demostración de la proposición \ref{prop:ski} consiste en la construcción de un algoritmo para transformar \( M \) a \( M' \). El siguiente lema es utilizado en esa demostración:

\begin{lem}
  \label{lem:ski}
  Sea \( λx.M \) una abstracción tal que \( \Sub(M) \) no contiene abstracciones

  \begin{enumerate}
  \item Si \( M =_{\bs{λ}} x \), entonces \( λx.M =_{\bs{λ}} \bs{I} \);
  \item Si \( x \not\in \FV(M) \), entonces \( λx.M =_{\bs{λ}} (\bs{K} M) \);
  \item Si \( M =_{\bs{λ}} P\, Q \), entonces \( λx.M =_{\bs{λ}} \bs{S}(λx.P)(λx.Q) \).
  \end{enumerate}
\end{lem}

\begin{proof}
  Utilizando la definición \ref{defn:ski}
  \begin{align*}
    \bs{I}\, N &=_{\bs{λ}} N && (1) \\
                 &=_{\bs{λ}} (λx.x) N  \\
                 &=_{\bs{λ}} (λx.M) N \\
    \bs{K}\, M\, N &=_{\bs{λ}} (λx\, y.x)M\, N && (2) \\
                     &=_{\bs{λ}} (λy.M)N \\
                 &=_{\bs{λ}} (λx.M)N \\
    \bs{S}(λx.P)(λx.Q) &=_{\bs{λ}} (λabc.(a\, c)(b\, c))(λx.P)(λx.Q) && (3)\\
                         &=_{\bs{λ}} λc.((λx.P)c)((λx.Q)c) \\
                         &=_{\bs{λ}} λc.P[x:=c]Q[x:=c] \\
                         &=_{\bs{λ}} λc.(P\, Q)[x:=c] \\
                         &=_{\bs{λ}} λx.P\, Q \\
                         &=_{\bs{λ}} λx.M
  \end{align*}
\end{proof}

\begin{proof}[Demostración de la proposición \ref{prop:ski}]
  \label{proof:ski}
  Sea \( M \in Λ^{0} \), se construye un término \( M' \in \{ \bs{S},\bs{K},\bs{I} \}^{+} \) tal que \( M' =_{\bs{λ}} M \) con el algoritmo \ref{alg:ski}.

  \begin{algorithm}
    \caption{SKI}
    \label{alg:ski}
    \begin{algorithmic}
      \REQUIRE \( M \in Λ^{0} \)
      \ENSURE \( M' \in \{ \bs{S},\ \bs{K},\ \bs{I} \} \)
      
      \STATE \( M' \leftarrow M \)
      \STATE \( \mathcal{L} \leftarrow \{ A \in \Sub(M') \mid A \synteq λx.N \} \)
      
      \WHILE{\( \mathcal{L} \not= \emptyset \)}
      
      \STATE \( A \leftarrow λx.N \in \mathcal{L} \mid \| λx.N \| \leq A', \forall A' \in \mathcal{L} \)
      
      \IF{\( A \synteq λx.a \)}
      \IF{\( a \synteq x \)}
      \STATE \( M'[A] \leftarrow \bs{I} \)
      \ELSIF{\( a \not\synteq x \)}
      \STATE \( M'[A] \leftarrow \bs{K}\, a \)
      \ENDIF
      \ELSIF{\( A \synteq λx.P\, Q \)}
      \IF{\( x \not\in \FV(P) \land x \not\in \FV(Q) \)}
      \STATE \( M'[A] \leftarrow \bs{S} (\bs{K}\, P) (\bs{K}\, Q) \)
      \ELSIF{\( x \not\in \FV(P) \land x \in \FV(Q) \)}
      \STATE \( M'[A] \leftarrow \bs{S} (\bs{K}\, P) (λx.Q) \)
      \ELSIF{\( x \in \FV(P) \land x \not\in \FV(Q) \)}
      \STATE \( M'[A] \leftarrow \bs{S} (λx.P) (\bs{K}\, Q) \)
      \ELSIF{\( x \in FV(P) \land x \in \FV(Q) \)}
      \STATE \( M'[A] \leftarrow \bs{S} (λx.P) (λx.Q) \)
      \ENDIF
      \STATE \( M'[A] \leftarrow \mathrm{SKI}(\ M'[A]\ ) \)
      \ENDIF
      
      \STATE \( \mathcal{L} \leftarrow \mathcal{L} \setminus \{ A \} \)
      
      \ENDWHILE
      \RETURN \( M' \)
    \end{algorithmic}
  \end{algorithm}
  
  El algoritmo enumera los subtérminos en \( M \) que sean abstracciones de menor a mayor longitud. Sea \( λx.N \) la abstracción con menor longitud en \( M \), según la estructura de \( N \) se aplican las siguientes transformaciones:
  \begin{enumerate}
  \item Si \( N = a \)
    \begin{enumerate}
    \item \label{item:ski:1a} Si \( a = x \) se transforma \( λx.N \) a \( \bs{I} \) en \( M \).
    \item \label{item:ski:1b}Si \( a \not= x \) se transforma \( λx.N \) a \( (\bs{K}\, a) \) en \( M \).
    \end{enumerate}
  \item \( N = (P\, Q) \)
    \begin{enumerate}
    \item \label{item:ski:2a} Si \( x \not\in \FV(P) \) y \( x \not\in \FV(Q) \) se transforma \( λx.P\, Q \) a \( \bs{S} (\bs{K}\, P) (\bs{K}\, Q) \) en \( M \).
    \item \label{item:ski:2b} Si \( x \not\in \FV(P) \) y \( x \in \FV(Q) \) se transforma \( λx.P\, Q \) a \( \bs{S} (\bs{K}\, P) (λx.Q) \) en \( M \).
    \item \label{item:ski:2c} Si \( x \in \FV(P) \) y \( x \not\in \FV(Q) \) se transforma \( λx.P\, Q \) a \( \bs{S} (λx.P) (\bs{K}\, Q) \) en \( M \).
    \item \label{item:ski:2d} Si \( x \in \FV(P) \) y \( x \in \FV(Q) \) se transforma \( λx.P\, Q \) a \( \bs{S} (λx.P) (λx.Q) \) en  \( M \).
    \end{enumerate}
  \end{enumerate}
  En los casos \ref{item:ski:2a}, \ref{item:ski:2b}, \ref{item:ski:2c}, \ref{item:ski:2d} se forman abstracciones con longitud menor a \( λx.N \), por lo tanto serán las que se transformarán después. Ya que la longitud de estas abstracciones es estrictamente menor a \( λx.N \) y los casos base \ref{item:ski:1a} y \ref{item:ski:1b} de la transformación no introducen abstracciones, en una cantidad finita de pasos el término \( M \) transformado no tendrá abstracciones de la forma \( λx.N \).

  Si el término \( M \) tiene dos o más abstracciones con la misma longitud, el orden en el que se procesen por el algoritmo no cambia el resultado, esto es debido a que los términos que transforma son subtérminos de las abstracciones.

  Para un término \( M \) con sólo una abstracción, \( \mathit{a} \) aplicaciones y \( \mathit{v} \) variables ligadas (no enlazadas) una cota superior para la máxima cantidad de pasos se calcula considerando que para los términos de la forma \( λx.a \) se cumple el caso \ref{item:ski:1b} (el cual aumenta la cantidad de aplicaciones en 1) y que para los términos de la forma \( λx.P\, Q \) se cumple el caso \ref{item:ski:2d} (el cual aumenta la cantidad de aplicaciones en 2) ya que en estos casos se produce el término con mas aplicaciones, las cuales determinan la cantidad de veces que se repite el algoritmo por cada abstracción en \( M \). Para calcular la cota superior de la cantidad de aplicaciones \( a' \) que produce el algoritmo para un término con \( n \) abstracciones se plantea la siguiente relación de recurrencia:
  \begin{align*}
    \mathit{a}'_{0} &= \mathit{a} \\
    \mathit{a}'_{n} &= 2 \times \mathit{a}'_{n-1} + \mathit{v}
  \end{align*}
  Esta recurrencia describe la función \( \mathit{a}' \colon \mathbb{N} \to \mathbb{N} \):
  \[ \mathit{a}'(n) = 2^{n} \times \mathit{a} + (2^{n}-1) \times \mathit{v} \]
  Para la cota superior de la cantidad de pasos realizados por el algoritmo para un término \( M \) con \( n \) abstracciones, se plantea la siguiente relación de recurrencia basada en \( \mathit{a}' \) y en el hecho de que la cantidad de variables ligadas y no enlazadas no aumenta en los pasos del algoritmo:
  \begin{align*}
    \mathit{p}_{0} &= 0 \\
    \mathit{p}_{n} &= \mathit{p}_{n-1} + \mathit{a}'(n-1) + \mathit{v}
  \end{align*}
  Esta recurrencia describe la función \( \mathit{p} \colon \mathbb{N} \to \mathbb{N} \):
  \begin{align*}
    \mathit{p}(n) &= (\mathit{a} + \mathit{v}) \times \sum_{i=0}^{n-1} 2^{i} \\
                  &= (\mathit{a} + \mathit{v}) \times (2^{n}-1)
  \end{align*}
\end{proof}

Con esta proposición demostrada, tenemos que cualquier término lambda cerrado puede ser traducido a términos en \( CL \) sin variables y estos dos términos son convertibles en la teoría \( \bs{λ} \).

\section{Teoría de reducción}
\label{sec:teoriareduccion}

El concepto de reducción fue introducido en la sección \ref{sec:op-reduccion} como el análogo de la evaluación de funciones para el cálculo lambda. Sin embargo, la formalización del cálculo lambda como una teoría de reducción va más allá de complementar la analogía de este sistema con las funciones de la matemática clásica.

Cuando se estudia el cálculo lambda desde una perspectiva computacional, la convertibilidad de términos lambda vista como la demostrabilidad de una fórmula en una teoría formal presenta cierta asimetría
\[ (λx.x\, x)y =_{\bs{λ}} (y\, y) \]
puede ser interpretada como ``\( (y\, y) \) es el resultado de computar \( (λx.x\, x)y \)'', pero no viceversa. Esto es debido a que toda la información necesaria para obtener \( (y\, y) \) se encuentra en \( (λx.x\, x)y \)  mientras que en el otro sentido, \( (y\, y) \) no nos dice como obtener un resultado. Conociendo las reglas de transformación de términos \( (λx.x\, x)y \) nos provee, de cierta manera, un algoritmo y una entrada.

En este capítulo se desarrolla el complemento computacional al estudio del cálculo lambda de la sección \ref{sec:conversion-lambda}. Primero se aborda la reducción en general, independiente de la regla \( (β) \) como fué presentada en la introducción a este trabajo. Después se aborda la propiedad de confluencia, la cuál contempla ciertas características deseables de los sistemas de reducción. Finalmente se presentarán algunas estrategias para la reducción de términos lambda.

Esta sección se basa principalmente en el capítulo 3, 11 y 13 de \cite{Barendregt:Bible}.

\subsection{Nociones de reducción}
\label{sec:nociones-reduccion}

El concepto de reducción que se ha considerado hasta el momento corresponde a la \( β \)-reducción, sin embargo, nociones de reducción pueden ser definidas de manera general.

Las reducciones sobre \( Λ \) se formalizan como relaciones binarias \( \bs{R} \) representadas como conjuntos de tuplas \( (M,\ M^{\prime}) \) donde \( M,\ M^{\prime} \in Λ \). Las propiedades que cumplan las tuplas de una relación nos permiten caracterizar las relaciones de varias maneras.

Consideremos las reglas de inferencia en la definición \ref{defn:teorialambda} de la teoría \( \bs{λ} \). Asignarle una de estas reglas a una relación nos permite analizar el tipo de transformaciones que se pueden realizar en un término para obtener otro.

Cuando se le asignan a una relación \( \bs{R} \) sobre \( Λ \) las reglas \( (μ) \), \( (ν) \) y \( (ξ) \) de la teoría \( \bs{λ} \) se dice que \( \bs{R} \) es \emph{compatible}. Formalmente, una relación es compatible cuando
\begin{align*}
  (M,\ M^{\prime}) \in \bs{R} &\implies (Z\, M,\ Z\, M^{\prime}) \in \bs{R} \\
  (M,\ M^{\prime}) \in \bs{R} &\implies (M\, Z,\ M^{\prime}\, Z) \in \bs{R} \\
  (M,\ M^{\prime}) \in \bs{R} &\implies (λx.M,\ λx.M^{\prime}) \in \bs{R}
\end{align*}
para toda \( M,\ M^{\prime},\ Z \in Λ \). La compatibilidad de una regla nos permite asegurar que las transformaciones de una regla se pueden realizar sobre subtérminos de un término.

Una \emph{relación de reducción} sobre \( Λ \) es aquella que es compatible, reflexiva y transitiva. Esto complementa las propiedades de compatibilidad con las reglas \( (ρ) \) y \( (τ) \) de la teoría \( \bs{λ} \), es decir
\begin{align*}
  (M,\ M) &\in \bs{R} \\
  (M,\ M^{\prime}) \in \bs{R},\ (M^{\prime},\ Z) &\implies (M\, Z) \in \bs{R}
\end{align*}
para toda \( M,\ M^{\prime},\ Z \in Λ \). Una relación de reducción establece transformaciones de más de un paso y también la capacidad de no transformar un término.

Finalmente, si a una relación de reducción sobre \( Λ \) se le añade la regla \( (σ) \) de la teoría \( \bs{λ} \), se dice que es una \emph{relación de igualdad} o \emph{congruencia}, debido a que además de ser compatible, es simétrica, reflexiva y transitiva. Formalmente una relacion \( \bs{R} \) sobre \( Λ \) es de congruencia cuando es una relación de reducción y además
\begin{align*}
  (M,\ M^{\prime}) \in \bs{R} &\implies (M^{\prime},\ M) \in \bs{R}
\end{align*}
para toda \( M,\ M^{\prime}\in Λ \). Una relación de igualdad establece que las transformaciones se pueden realizar de forma inversa.

Para definir reducciones en el cálculo lambda se define primero una \emph{noción de reducción}, esta es simplemente una relación binaria sobre \( Λ \), por ejemplo, la noción de reducción \( \bs{β} \) se define como
\begin{equation}
  \label{eq:reduccion-nocion-beta}
  \bs{β} = \{ ((λx.M)N\ ,\ \subst{M}{x}{N}) \mid M,\ N \in Λ \}
\end{equation}

A partir de una noción de reducción nos podemos referir a sus \emph{clausuras}. Sea \( \bs{R} \) una noción de reducción sobre \( Λ \), entonces

\begin{itemize}
\item La clausura reflexiva de \( \bs{R} \) es la relación más pequeña que extiende a \( \bs{R} \) para que sea reflexiva;
\item La clausura transitiva de \( \bs{R} \) es la relación más pequeña que extiende a \( \bs{R} \) para que sea transitiva;
\item La clausura compatible de \( \bs{R} \) es la relación más pequeña que extiende a \( \bs{R} \) para que sea compatible.
\end{itemize}

Al considerar las nociones de reducción como reglas de transformación de términos lambda, es natural referirse a las transformaciones realizadas en un paso, en cero o más pasos y en ambas direcciones.

\begin{defn}
  Sea \( \bs{R} \) una noción de reducción sobre \( Λ \). \( \bs{R} \) introduce las siguientes relaciones binarias
  \begin{itemize}
  \item \( R \)-contracción, denotada \( \contract{R} \), es la clausura compatible de \( \bs{R} \):
    \begin{align*}
      (M,N)\in \bs{R} &\implies M \contract{R} N\\
      M \contract{R} N &\implies Z\, M \contract{R} Z\, N\\
      M \contract{R} N &\implies M\, Z \contract{R} N\, Z\\
      M \contract{R} N &\implies λx.M \contract{R} λx.N
    \end{align*}
  \item \( R \)-reducción, denotada \( \reduce{R} \), es la clausura reflexiva y transitiva de \( \contract{R} \):
    \begin{align*}
      M \contract{R} N &\implies M \reduce{R} N \\
      M &\reduce{R} M \\
      M \reduce{R} N,\ N \reduce{R} L &\implies M \reduce{R} L
    \end{align*}
  \item \( R \)-convertibilidad, denotada \( \convertible{R} \), es la relación de equivalencia generada por \( \reduce{R} \):
    \begin{align*}
      M \reduce{R} N &\implies M \convertible{R} N \\
      M \convertible{R} N &\implies N \convertible{R} M \\
      M \convertible{R} N,\ N \convertible{R} L &\implies M \convertible{R} L
    \end{align*}
  \end{itemize}
\end{defn}

\begin{rem}[Notación]
  Las nociones de reducción serán denotadas con letras en negritas, por ejemplo \( \bs{β} \) y sus relaciones derivadas omitirán esta convención, por ejemplo \( \contract{β} \), \( \reduce{β} \), \( \convertible{β} \).
\end{rem}

\begin{exmp} \label{exmp:reduccion-nocion-beta}
  Considerando la noción de reducción \( \bs{β} \) 
  \begin{align*}
    (λx.x\, x)(λy.y)z &\contract{β} (λy.y)(λy.y)z\\
                      &\contract{β} (λy.y)z \\
                      &\contract{β} z \\
    (λx.x\, x)(λy.y)z &\reduce{β} z \\
    z &\convertible{β} (λx.x\, x)(λy.y)z
  \end{align*}
\end{exmp}

Una manera alternativa de definir nociones de reducción en el cálculo lambda es establecer la transformación denotada como una contracción, por ejemplo, la noción de reducción \( \bs{α} \) es

\[ \bs{α}\ :\ (λx.M) \contract{} λy.\subst{M}{x}{y} \text{ dado que \( y\not\in \FV(M) \)} \]

Ya que las nociones de reducción son conjuntos es posible tomar la unión de dos nociones de reducción para formar otra. Por ejemplo, la noción de reducción \( \bs{β} \) no considera cambios de variables ligadas entre términos, sin embargo, la noción de reducción \( \bs{αβ} = \bs{β}\cup\bs{α} \) si. De hecho, \( \convertible{\bs{αβ}} \) tiene las mismas propiedades que la convertibilidad \( =_{\bs{λ}} \) de la teoría formal \( \bs{λ} \).También se puede definir una noción de reducción para el axioma de extensionalidad de la teoría \( \bs{λη} \) y estudiar las transformaciones en \( \bs{α}\cup\bs{β}\cup\bs{η} \) es equivalente a estudiar la demostrabilidad en la teoría \( \bs{λη} \):

\[ \bs{η}\ :\ λx.M\, x \contract{} M \text{ dado que \( x\not\in \FV(M) \)} \]

\begin{prop}[Equivalencia \( \bs{αβ} \) y \( \bs{λ} \) ]
  Para todo \( M,\ N \in Λ \)
  \[ M \convertible{αβ} N \iff \bs{λ} \vdash M=N \]

  \begin{proof} Se demuestran las implicaciones por separado
    \begin{itemize}
    \item[\( (\ \Longleftarrow\ ) \)] Ya que \( \bs{λ} \vdash M=N \), existe un árbol de deducción que a partir de los axiomas y reglas de \( \bs{λ} \) hasta la fórmula \( M=N \). Las fórmulas del árbol se etiquetan con \( (α) \), \( (β) \), \( (ρ) \), \( (μ) \), \( (ν) \), \( (ξ) \), \( (τ) \) y \( (σ) \) de acuerdo al axioma o regla aplicada a la fórmula. En cada paso de la deducción se aplica la noción o clausura correspondiente de \( \bs{αβ} \) para pasar al siguiente paso:
      \begin{itemize}
      \item La noción \( \bs{α} \) para el axioma \( (α) \);
      \item La noción \( \bs{β} \) para el axioma \( (β) \);
      \item La clausura compatible de \( \bs{αβ} \) para las reglas \( (μ) \), \( (ν) \) y \( (ξ) \);
      \item La clausura transitiva y reflexiva de \( \bs{αβ} \) para el axioma \( (ρ) \) y la regla \( (τ) \);
      \item La relación \( =_{αβ} \) para la regla \( (σ) \).
      \end{itemize}
    \item[\( (\implies) \)] Por las definiciones de las relaciones que genera \( \bs{αβ} \)
      \begin{itemize}
      \item \( M \contract{αβ} N \implies \bs{λ} \vdash M=N \);
      \item \( M \reduce{αβ} N \implies \bs{λ} \vdash M=N \);
      \item \( M \convertible{αβ} N \implies \bs{λ} \vdash M=N \).
      \end{itemize}
    \end{itemize}
  \end{proof}
\end{prop}

\begin{rem}[Sobre notación]
Dada esta equivalencia, se abrevia la noción \( \bs{αβ} \) simplemente como \( \bs{β} \) ya que las propiedades interesantes de \( \bs{αβ} \) son las de la \( β \)-reducción.
\end{rem}

Ya que las nociones de reducción son estudiadas como cómputos sobre un término, las siguientes definiciones nos permiten identificar las partes de un término lambda que pueden o no ser transformadas por una noción de reducción \( \bs{R} \):

\begin{defn}[Clasificación de términos]
  Dada una noción \( \bs{R} \), los términos lambda pueden ser clasificados con respecto a esta noción de la siguiente manera:
  \begin{itemize}
  \item Un \( R \)-redex es un término \( M \) tal que \( (M,N)\in \bs{R} \) para algún término \( N \);
  \item Si \( (M,N)\in \bs{R} \), a \( N \) se le llama \( R \)-contractum de \( M \);
  \item Un término \( M \) es llamado una \( R \)-forma normal si \( M \) no contiene algún subtérmino que sea \( R \)-redex;
  \item Se dice que \( M \) tiene la \( R \)-forma normal \( N \) si \( M \convertible{R} N \) y \( N \) es una \( R \)-forma normal.
  \end{itemize}
\end{defn}

La idea de que un término que sea una \( R \)-forma normal puede ser vista desde una perspectiva computacional como si una máquina realizara reducciones sobre un término \( M \) hasta llegar a un punto en donde no hay más posibles transformaciones que realizar, es entonces cuando el término resultante es el estado final de la máquina. Es por ello que en la literatura es común encontrar que se refieren a un término como ``\( M \) está en \( R \)-forma normal'' en lugar de ``\( M \) es una \( R \)-forma normal''.

\begin{exmp} \label{exmp:clasificacion-nocion-beta}
  Considerando las reducciones del ejemplo \ref{exmp:reduccion-nocion-beta}
  \begin{itemize}
  \item \( (λx.x\, x)(λy.y) \) es un \( β \)-redex;
  \item \( (λy.y)z \) no está en \( β \)-forma normal;
  \item Estos términos tienen la \( β \)-forma normal \( z \).
  \end{itemize}
\end{exmp}

Las nociones de reducción pueden visualizarse y estudiarse como pseudográficas dirigidas. Sea \( \bs{R} \) una noción de reducción, la \( R \)-gráfica  de un término \( M \), denotada \( G_{R}(M) \) es la pseudográfica con el conjunto de vértices \( \{ N\in Λ \mid M \reduce{R} N \} \) y conjunto de aristas \( \contract{R} \).

\begin{exmp}[\( β \)-Gráficas] Los siguientes son ejemplos de gráficas de reducción con la noción \( \bs{β} \):
  \begin{enumerate}
  \item \( G_{β}(\bs{I}\, x) \)
    
    \includegraphics{rgraphs-1.mps}
  \item \( G_{β}(\bs{I}(\bs{I}\, x)) \)

    \includegraphics{rgraphs-2.mps}
  \item \( G_{β}((λx.x\, x)(λx.x\, x)) \)

    \includegraphics{rgraphs-3.mps}
  \item \( G_{β}(\bs{W}\, \bs{W}\, \bs{W}) \) con \( \bs{W} \synteq λx\, y.x\, y\, y \)

    \includegraphics{rgraphs-4.mps}
  \item \( G_{β}(M\, M) \) con \( M \synteq λx.(λy.y\, y)x \)

    \includegraphics{rgraphs-5.mps}
  \item \( G_{β}((λx.x\, x\, x)(λx.x\, x\, x)) \)

    \includegraphics{rgraphs-6.mps}
  \end{enumerate}
\end{exmp}

Un \( R \)-camino de reducción es una secuencia finita o infinita de \( R \)-contracciones

\[ M_{0} \xcontract{R}{Δ_{0}} M_{1} \xcontract{R}{Δ_{1}} M_{2} \contract{R} ... \]

Donde \( Δ_{i} \) es el \( R \)-redex de \( M_{i} \) que es contraído en cada paso de las \( R \)-contracciones. Sea \( M \) un término lambda, se puede categorizar su \( R \)-reducción a partir de \( G_{R}(M) \) y sus caminos con las siguientes definiciones
\begin{enumerate}
\item \( M \) \( R \)-normaliza fuertemente si no hay un \( R \)-camino de reducción infinito a partir de \( M \);
\item \( M \) es \( R \)-infinito si \( M \) no \( R \)-normaliza fuertemente;
\item \( R \) normaliza fuertemente, si para toda \( M \), \( M \) \( R \)-normaliza fuertemente.
\end{enumerate}

\begin{exmp}
  Sea \( G_{β}(M) \) una \( β \)-gráfica de un término \( M \):

  Es posible que \( M \) tenga una \( β \)-forma normal pero que \( G_{β}(M) \) sea infinita. Si consideramos el término
  \[ M \synteq (λx.\bs{I})((λx.x\, x\, x)(λx.x\, x\, x)) \]
  el cual tiene \( β \)-forma normal \( \bs{I} \), al dibujar su \( β \)-gráfica se obtiene
  \begin{center}
    \includegraphics{rgraphs-7.mps}
  \end{center}

  Si \( G_{β}(M) \) es finita y \( M \) tiene una \( β \)-forma normal, es posible que \( M \) no \( β \)-normalice fuertemente. Si consideramos el término
  \[ M \synteq (λx.\bs{I})((λx.x\, x)(λx.x\, x)) \]
  su \( β \)-forma normal es \( \bs{I} \) y su \( β \)-gráfica es
  \begin{center}
    \includegraphics{rgraphs-8.mps}
  \end{center}
  Sin embargo, tiene el \( β \)-camino de reducción infinito
  \[ (λx.\bs{I})((λx.x\, x)(λx.x\, x)) \xcontract{β}{(λx.x\, x)(λx.x\, x)} (λx.\bs{I})((λx.x\, x)(λx.x\, x)) \xcontract{β}{(λx.x\, x)(λx.x\, x)} ... \]
\end{exmp}

\subsection{Confluencia}
\label{sec:confluencia}

En la sección anterior se presenta una formalización del cálculo lambda como un sistema de reducción, a partir de la noción \( \bs{β} \) sobre los términos lambda se puede estudiar el comportamiento de los términos bajo transformaciones ya sea en un paso, cero o muchos pasos y admitiendo transformaciones inversas. En general un sistema de reducción es una relación binaria sobre algún conjunto de objetos.

Consideremos por ejemplo un sistema de reducción para expresiones aritméticas con números naturales y operaciones \( + \) y \( \times \). Las transformaciones que realiza este sistema de reducción son muy similares a las que realiza una calculadora simplificada, por ejemplo:
\begin{align*}
  (5\times 3)+(9\times 2) &\contract{} 15+(9\times 2) \\
                          &\contract{} 15+18 \\
                          &\contract{} 33
\end{align*}
Estas reducciones pudieron haberse realizado de una manera diferente, por ejemplo, de derecha a izquierda:
\begin{align*}
  (5\times 3)+(9\times 2) &\contract{} (5\times 3)+18 \\
                          &\contract{} 15+18 \\
                          &\contract{} 33
\end{align*}
El resultado en ambos casos es el mismo y es natural pensar que, mientras se respeten las reglas de precedencia, las expresiones aritméticas podrán ser reducidas en cualquier orden y el resultado final será siempre el mismo.

Sin embargo, esta característica no es una propiedad general de todos los sistemas de reducción. Consideremos un sistema con las siguientes reducciones:
\begin{align*}
  f(0) &\contract{} f(1) \\
  f(1) &\contract{} f(0) \\
  f(g(x)) &\contract{} g(x) \\
  g(x) &\contract{} x
\end{align*}
Al reducir \( f(g(0)) \) se tienen dos caminos
\begin{align*}
  f(g(0)) &\contract{} g(0) & f(g(0)) &\contract{} f(0) \\
          &\contract{} 0    &         &\contract{} f(1) \\
  & & &\contract{} ...
\end{align*}
Por un lado se obtiene el resultado final \( 0 \) el cual no puede ser reducido por ninguna regla, por otro lado se llega al término \( f(1) \) el cual entra en un ciclo de reducciones del que no puede salir:
\[ f(1) \contract{} f(0) \contract{} f(1) \contract{} ... \]

Al estudiar los sistemas de reducción desde un punto de vista computacional, independientemente de su utilidad, el segundo ejemplo puede nunca llegar a una forma normal (no tener un resultado final) y además el orden en el que se apliquen las reducciones es importante para determinar el resultado. En el caso del primer ejemplo, ya que la suma y la multiplicación son conmutativas y el orden de sus operandos no altera el resultado, por lo tanto el primer ejemplo no tendrá estas características indeseables.

La propiedad de los sistemas de reducción que se refiere a estas características es la \emph{confluencia}. A continuación se aborda su definición considerando relaciones sobre términos lambda.

\begin{defn}[Propiedad de diamante]
  Sea \( \rightarrowtail \) una relacion binaria sobre \( Λ \). Se dice que \( \rightarrowtail \) satisface la \emph{propiedad de diamante}, si para toda \( M \), \( M_{1} \) y \( M_{2} \)
  \[ M \rightarrowtail M_{1} \text{ y } M \rightarrowtail M_{2} \implies \text{ existe } M_{3} \text{ tal que } M_{1} \rightarrowtail M_{3} \text{ y } M_{2} \rightarrowtail M_{3} \]

  Gráficamente, esta propiedad se visualiza
  \begin{center}
    \includegraphics{diagrams-1.mps}
  \end{center}
\end{defn}

\begin{defn}[Confluencia global]
  Una noción de reducción \( \bs{R} \) se dice ser \emph{Church-Rosser}, abreviado CR, si \( \reduce{R} \) tiene la propiedad de diamante. Cuando una relación de reducción es CR, se dice que tiene la propiedad de \emph{confluencia global}.
\end{defn}

El siguiente teorema y corolario relacionan algunos conceptos abordados en la anterior sección con la propiedad de confluencia.

\begin{thm}
  Sea \( \bs{R} \) una noción CR. Entonces
  \[ M \convertible{R} N \implies \text{ existe } Z \text{ tal que } M \reduce{R} Z \text{ y } N \reduce{R} Z \]
  \begin{proof}
    Por inducción de la definición de \( \convertible{R} \):
    \begin{itemize}
    \item Si \( M \convertible{R} N \) es una consecuencia directa de que \( M \reduce{R} N \), entonces \( Z \synteq N \).
    \item Si \( M \convertible{R} N \) es una consecuencia directa de que \( N \convertible{R} M \), \( Z \) puede ser encontrada por la hipótesis de inducción.
    \item Si \( M \convertible{R} N \) es una consecuencia directa de que \( M \convertible{R} L \) y \( L \convertible{R} N \), \( Z \) puede ser encontrada usando la hipótesis de inducción y la suposición de que \( \reduce{R} \) es CR, gráficamente
      \begin{center}
        \includegraphics{diagrams-2.mps}
      \end{center}
    \end{itemize}
  \end{proof}
\end{thm}

\begin{cor}
  Sea \( \bs{R} \) una noción CR. Entonces
  \begin{enumerate}
  \item Si \( N \) es una \( R \)-forma normal de \( M \), entonces \( M \reduce{R} N \).
  \item Un término \( M \) puede tener a lo más una \( R \)-forma normal.
  \end{enumerate}
  \begin{proof}
    \begin{enumerate}
    \item Sea \( M \convertible{R} N \) y \( N \) un término en \( R \)-forma normal. Para algúna \( Z \) se tiene que \( M \reduce{R} Z \) y \( N \reduce{R} Z \), pero ya que \( N \) está en forma normal \( Z \synteq N \). Por lo tanto \( M \reduce{R} N \).
    \item Supongamos que \( N_{1} \) y \( N_{2} \) son dos \( R \)-formas normales de \( M \). Ya que \( M \reduce{N_{1}} \) y \( M \reduce{N_{2}} \), por la propiedad de confluencia, \( N_{1} \reduce{R} Z \) y \( N_{2} \reduce{R} Z \), pero ya que \( N_{1} \) y \( N_{2} \) no tienen subtérminos \( R \)-redex, \( N_{1} \synteq N_{2} \synteq Z \).
    \end{enumerate}
  \end{proof}
\end{cor}

Ya que la sustitución es una operación fundamental para definir las nociones de reducción en el cálculo lambda, la siguiente definición establece una característica de las relaciones que se comportan bien bajo la sustitución.

\begin{defn}
  Una noción de reducción \( \bs{R} \) es \emph{sustitutiva} si para todo término lambda \( M \), \( N \) y \( L \) y toda variable \( x \)
  \[ (M,N)\in \bs{R} \implies (\subst{M}{x}{L},\subst{N}{x}{L})\in \bs{R} \]
\end{defn}

Es importante observar que si una noción \( \bs{R} \) es sustitutiva, entonces las relaciones generadas \( \contract{R} \), \( \reduce{R} \) y \( \convertible{R} \) también lo son.

Consideremos la noción \( \bs{β} \), considerando dos términos \( M \) y \( N \) tal que \( (M,N)\in \bs{β} \), se muestra que \( \bs{β} \) es sustitutiva ya que
\begin{align*}
  M &\synteq (λy.P)Q \\
  N &\synteq \subst{P}{y}{Q} \\
  \subst{M}{x}{L} &\synteq (λy.\subst{P}{x}{L})\subst{Q}{x}{L} \\
  \subst{N}{x}{L} &\synteq \subst{\subst{P}{y}{Q}}{x}{L} \\
    &\synteq \subst{\subst{P}{x}{L}}{y}{\subst{Q}{x}{L}}
\end{align*}

La propiedad de diamante está detrás de la definición de las relaciones Church-Rosser, otra propiedad similar que es importante considerar al estudiar nociones de reducción en el cálculo lambda es la propiedad débil de diamante.

\begin{defn}[Propiedad débil de diamante]
  Una relación binaria \( \rightarrowtail \) satisface la propiedad \emph{débil} de diamante si para todo término \( M \), \( M_{1} \) y \( M_{2} \)
  \[ M \rightarrowtail M_{1} \text{ y } M \rightarrowtail M_{2} \implies \text{ existe } M_{3} \text{ tal que } M_{1} \underset{=}{\overset{*}{\rightarrowtail}} M_{3} \text{ y } M_{2} \underset{=}{\overset{*}{\rightarrowtail}} M_{3} \]
  donde \( \underset{=}{\overset{*}{\rightarrowtail}} \) es la clausura transitiva y reflexiva de \( \rightarrowtail \).
\end{defn}

\begin{defn}[Confluencia local]
  Una noción de reducción \( \bs{R} \) se dice ser Church-Rosser débil, abreviado WCR, si \( \contract{R} \) satisface la propiedad débil de diamante. Cuando una noción de reducción es WCR se dice que tiene la propiedad de \emph{confluencia local}.
\end{defn}

Se pudiera pensar que una noción \( \bs{R} \) que sea Church-Rosser débil debe ser Church-Rosser, ya que la relación \( \contract{R} \) tiene como clausura transitiva y reflexiva a \( \reduce{R} \) y todo lo que se puede reducir con \( \contract{R} \) se puede reducir con \( \reduce{R} \), sin embargo, esto no siempre se cumple.

Existen algunas nociones de reducción que son WCR pero no CR, consideremos la siguiente gráfica de reducción para una noción \( \bs{R} \) a partir de un término \( M \):

\begin{center}
  \includegraphics{rgraphs-9}
\end{center}

En este ejemplo se puede apreciar que la noción \( \bs{R} \) es WCR ya que \( M \contract{R} M_{1} \) y \( M \contract{R} N \) y que también \( M_{1} \reduce{R} M_{1} \) y \( N \reduce{R} M_{1} \), de manera similar comenzando desde \( M_{1} \), \( N \) y \( N_{1} \). Sin embargo, la noción no es CR ya que \( M \reduce{R} M_{1} \) y \( M \reduce{R} N_{1} \), pero no existe un término \( Z \) en donde \( M_{1} \reduce{R} Z \) y \( N_{1} \reduce{R} Z \).

Alonzo Church y Barkley Rosser en un artículo publicado en 1936 \cite{ChurchRosser:Confluence} demostraron que la noción de reducción \( \bs{β} \) es Church-Rosser y que por lo tanto, si un término lambda podía ser reducido a dos términos diferentes, estos podían ser reducidos a un término en común \cite[p.~14]{HindleySeldin:LambdaCalculusAndCombinators}. Este resultado es de grán importancia para poder considerar al cálculo lambda como un sistema que fundamente la computación.

A diferencia del cálculo lambda, los lenguajes de programación suelen asignar un orden particular a la manera en la que sus expresiones son reducidas. Consideremos el fragmento de pseudocódigo \ref{alg:reduc-problema}.

\begin{algorithm}
  \caption{Potencial ciclo infinito}
  \label{alg:reduc-problema}
  \begin{algorithmic}
    \STATE \( x \leftarrow 4 \)
    \IF{\( x \not= 4 \)}
    \LOOP
    \STATE \( ... \)
    \ENDLOOP
    \ELSE
    \RETURN x
    \ENDIF
  \end{algorithmic}
\end{algorithm}

Si en la expresión condicional se reduce primero su consecuente el programa nunca terminará de ejecutarse, sin embargo, si se reduce de manera usual, es decir, primero el predicado \( x \not= 4 \) y dependiendo de su resultado se reducir o el consecuente o la alternativa, este programa terminará.

Estos problemas ocurren ya que, aunque el programa tenga una forma normal, automatizar el proceso de reducción puede causar que nunca se encuentre. En la siguiente sección se estudian diferentes estrategias para reducir términos en el cálculo lambda.

\subsection{Estrategias de reducción}
\label{sec:estrategias-reduccion}

Cuando un término lambda tiene varios redex puede ser reducido de diferentes maneras. Por la propiedad de Church-Rosser no se obtendrán resultados esencialmente diferentes, sin embargo se pueden plantear estrategias de reducción para reducir un término de manera sistemática. Las estrategias de reducción son útiles, por ejemplo, para demostrar que un término no tiene forma normal \cite[p.~324]{Barendregt:Bible}.

\begin{defn}[Estrategia de reducción]
  Una estrategia de \( R \)-reducción es una función \( F \colon Λ \to Λ \) tal que para toda \( M \)
  \[ M \reduce{R} F(M) \]

  Una estrategia de \( R \)-contracción es una estrategia de \( R \)-reducción, tal que para toda \( M \) que no esté en \( R \)-forma normal
  \[ M \contract{R} F(M) \]
\end{defn}

En este trabajo consideraremos tres estrategias de reducción para el cálculo lambda muy utilizadas en la especificación de lenguajes de programación \cite{Pierce:TypesAndPLangs}:

\begin{itemize}
\item Estrategia de \emph{orden normal};
\item Estrategia de \emph{llamada por nombre};
\item Estrategia de \emph{llamada por valor}.
\end{itemize}

Para referirse a un redex en particular, es usual referirse a los redex más al exterior, esto se refiere a los redex que no son subtérminos de otro redex excepto ellos mísmos. Por ejemplo, el término
\[ (λx.(λy.y\, y)x)z \]
tiene los siguientes redex
\begin{align*}
  \underline{(λx.(λy.\bs{I}\, y)x)z} \\
  (λx.\underline{(λy.\bs{I}\, y)x})z \\
  (λx.(λy.\underline{\bs{I}\, y})x)z
\end{align*}
El primer redex es el que está más al exterior y el último redex es el que está más al interior. También es usual referirse a redex a la derecha o a la izquierda, por ejemplo, el término
\[ ((((\bs{I}\, x)(\bs{I}\, y))(\bs{I}\, z))(\bs{I}\, w)) \]
tiene los redex
\begin{align*}
  (((\underline{(\bs{I}\, x)}(\bs{I}\, y))(\bs{I}\, z))(\bs{I}\, w)) \\
  ((((\bs{I}\, x)\underline{(\bs{I}\, y)})(\bs{I}\, z))(\bs{I}\, w)) \\
  ((((\bs{I}\, x)(\bs{I}\, y))\underline{(\bs{I}\, z)})(\bs{I}\, w)) \\
  ((((\bs{I}\, x)(\bs{I}\, y))(\bs{I}\, z))\underline{(\bs{I}\, w)})
\end{align*}
El redex más a la izquierda es \( (\bs{I}\, x) \) y el más a la derecha es \( (\bs{I}\, w) \).

\subsubsection{Orden normal}

Esta estrategia establece que el redex que esté más a la izquierda y más al exterior es el que se reduce. Utilizar esta estrategia garantiza que si un término \( M \) tiene una forma normal \( N \), entonces \( F(M) = N \).

Considerando el término lambda \( M \synteq \bs{I}(\bs{I}(λz.\bs{I}\, z)) \), su reducción bajo esta estrategia es

\begin{align*}
  \underline{\bs{I}(\bs{I}(λz.\bs{I}\, z))} &\contract{β} \bs{I}(λz.\bs{I}\, z) \\
  \underline{\bs{I}(λz.\bs{I}\, z)} &\contract{β} λz.\bs{I}\, z \\
  λz.\underline{\bs{I}\, z} &\contract{β} λz.z
\end{align*}

Una desventaja de utilizar esta estrategia es que los términos obtenidos al reducir pueden ser muy largos de escribir. Consideremos el término
\[ (λx.x\, x\, x)((λy.\bs{I}\, \bs{I}\, \bs{I}\, \bs{I}\, y)z) \]
Utilizando esta estrategia, en el primer paso se obtiene el término
\[ ((λy.\bs{I}\, \bs{I}\, \bs{I}\, \bs{I}\, y)z)((λy.\bs{I}\, \bs{I}\, \bs{I}\, \bs{I}\, y)z)((λy.\bs{I}\, \bs{I}\, \bs{I}\, \bs{I}\, y)z) \]
Por lo tanto, las reducciones realizadas sobre \( ((λy.\bs{I}\, \bs{I}\, \bs{I}\, \bs{I}\, y)z) \) se repetirán dos veces para obtener el término final.

\subsubsection{Llamada por nombre}

Esta estrategia es similar a la de orden normal, sin embargo, no se reducen apariciones de redex dentro de abstracciones.

Variantes de esta estrategia han sido utilizados en algunos lenguajes de programación populares como \texttt{Algol-60} y \texttt{Haskell}.

Considerando el término lambda \( M \synteq \bs{I}(\bs{I}(λz.\bs{I}\, z)) \), su reducción bajo esta estrategia es

\begin{align*}
  \underline{\bs{I}(\bs{I}(λz.\bs{I}\, z))} &\contract{β} \bs{I}(λz.\bs{I}\, z) \\
  \underline{\bs{I}(λz.\bs{I}\, z)} &\contract{β} λz.\bs{I}\, z
\end{align*}

Con la estrategia llamada por nombre, algunos términos que no son formas normales no serán reducidos, por ejemplo el término
\[ (λy.(λx.x\, x)(λx.x\, x)) \]
No es reducido siguiendo esta estrategia. De cierta manera, una abstracción \( (λx.M) \) ``suspende'' la reducción de \( M \) hasta que sea aplicada a algún término que no esté dentro de otra abstracción. Por este motivo, hay términos con forma normal que no pueden ser encontrados con llamada por nombre.

\subsubsection{Llamada por valor}

Esta estrategia solo reduce los redex más al exterior del término lambda y un redex es reducido únicamente cuando los redex a su derecha estén en forma normal.

Variantes de esta estrategia han sido utilizadas en algunos lenguajes de programación populares como \texttt{C} y \texttt{Java}. Si consideramos que un redex es una llamada a función, esta estrategia establece que antes de reducir la función, se reducen todos sus argumentos, de derecha a izquierda, de tal manera que al ``entrar'' al cuerpo de la función, todos los valores son conocidos.

Considerando el término lambda \( M \synteq \bs{I}(\bs{I}(λz.\bs{I}\, z)) \), su reducción bajo esta estrategia es

\begin{align*}
  \bs{I}(\underline{\bs{I}(λz.\bs{I}\, z)}) &\contract{β} \bs{I}(λz.\bs{I}\, z) \\
  \underline{\bs{I}(λz.\bs{I}\, z)} &\contract{β} λx.\bs{I}\, z
\end{align*}

Con esta estrategia se pueden obtener términos bastante cortos, considerando el término
\[ (λx.x\, x\, x)((λy.\bs{I}\, \bs{I}\, \bs{I}\, \bs{I}\, y)z) \]
Primero se reduce \( (λy.\bs{I}\, \bs{I}\, \bs{I}\, \bs{I}\, y)z \) a \( z \) y posteriormente se reduce \( (λx.x\, x\, x)z \), por lo que en este ejemplo no se presenta la duplicación de reducciones como en el caso de orden normal.

Una grán desventaja de esta estrategia es que hay términos con formas normales a las que no se puede reducir. Consideremos el término
\[ (λx.y)((λx.x\, x)(λx.x\, x)) \]
Es fácil notar que este término tiene forma normal \( y \), sin embargo, siguiendo la estrategia de llamada por nombre, el término \( (λx.x\, x)(λx.x\, x) \) será reducido hasta llegar a su forma normal, pero este redex no tiene forma normal y por consiguiente nunca se obtendrá el resultado.

Esta desventaja es resuelta por los lenguajes de programación basados en llamada por nombre forzando el orden de evaluación de ciertas expresiones.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
