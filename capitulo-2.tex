La noción de \emph{generalización} es de suma importancia en el estudio general de funciones, operaciones o transformaciones. Los predicados en la lógica de primer orden, las funciones en la matemática clásica, los algoritmos en la computación y las abstracciones en el cálculo lambda pueden ser considerados como implementaciones del concepto de generalización para los sistemas de los que forman parte y en algunos casos son la motivación original para el desarrollo de las teorías que los fundamentan.

El estudio de las propiedades generales de las funciones es una de las motivaciones originales del cálculo lambda, sin embargo, este cálculo se formuló de tal manera que es posible abstraer de su propósito original y ser tratado meramente como un sistema formal \cite{Church:LambdaConversion}.

El presente capítulo tiene el objetivo de formalizar las ideas presentadas en el capítulo \ref{ch:nocion-informal}. La formalización del cálculo lambda se realiza desde dos perspectivas:

\begin{enumerate}
\item Construyendo una \emph{teoría formal}, en donde un conjunto de axiomas y reglas de inferencia permiten plantear razonamientos lógicos para demostrar propiedades del cálculo lambda.
\item Formulando nociones de \emph{reducción}, de tal manera que mediante procedimientos de transformación de expresiones del cálculo lambda, se puedan estudiar sus propiedades.
\end{enumerate}

Independientemente de la perspectiva de la formalización, los conceptos son similares, se describe la misma idea general del cálculo lambda y ambos trabajan con el lenguaje formal de sus expresiones.

De acuerdo a Barendregt \cite[p.~22]{Barendregt:Bible}, el objeto de estudio del cálculo lambda es el conjunto de términos lambda módulo convertibilidad. Estos conceptos serán presentados a lo largo de este capítulo.

El contenido de este capítulo está basado en los primeros cuatro capítulos del libro \emph{The Lambda Calculus, Its Syntax and Semantics} de H.P. Barendregt \cite{Barendregt:Bible} y los capítulos 1, 3, 6, 7 y 8 del libro \emph{Lambda Calculus and Combinators, an Introduction} de J.R. Hindley y J.P. Seldin \cite{HindleySeldin:LambdaCalculusAndCombinators} así como el artículo \emph{A Set of Postulates for the Foundation of Logic} y la monografía \emph{The Calculi of Lambda-Conversion} de Alonzo Church \cite{Church:FoundationsLogic,Church:LambdaConversion}.

\section{Términos lambda}
\label{sec:terminos-lambda}

Esta subsección está basada principalmente en el capítulo 2 de \cite{Barendregt:Bible}.

Los \emph{términos lambda} son la formalización de las expresiones descritas en la sección \ref{sec:expresiones}. El conjunto de todos los términos lambda es un lenguaje formal \( Λ \) en donde sus elementos son cadenas compuestas de símbolos de un alfabeto \cite{Hopcroft:Automata}.

El lenguaje \( Λ \) se puede definir de diferentes maneras, a continuación se presenta una definición inductiva y posteriormente una definición basada en una gramática libre de contexto.

\begin{rem}[Notación]\
  \begin{itemize}
  \item El símbolo \( \implies \) denota una implicación lógica, \( P \implies Q \) se lee ``Si \( P \), entonces \( Q \)''.
  \item El símbolo \( \, \longrightarrow\, \) denota una producción en una gramática, \( P \longrightarrow Q \) se lee ``\( P \) produce \( Q \)''.
  \item El símbolo \( \, \Rightarrow\, \) denota un paso en la derivación de una cadena.
  \end{itemize}
\end{rem}

\begin{defn}[Términos lambda]
  El conjunto \( Λ \) tiene elementos que son cadenas conformadas por símbolos en el alfabeto \( Σ=\{\mathtt{(},\ \mathtt{)},\ \mathtt{.},\ λ\} \cup V \), donde \( V \) es un conjunto infinito \( \{v_{0},\ v_{00},\ ... \} \) de variables. \( Λ \) es el conjunto más pequeño que satisface:
  \label{defn:terminos}
  \begin{subequations}
    \begin{align}
      \label{terminos:atomos} \tag{a}
      x \in V & \implies x \in Λ \\
      \label{terminos:abstracciones} \tag{b}
      M \in Λ,\ x \in V & \implies (λx.M) \in Λ \\
      \label{terminos:aplicaciones} \tag{c}
      M,\ N \in Λ & \implies (M\, N) \in Λ
    \end{align}
  \end{subequations}
\end{defn}

Cada uno de estos tres incisos corresponde a las tres clases de términos lambda:

\begin{description}
\item[\eqref{terminos:atomos}] establece que todo elemento de \( V \) es un término lambda a los cuales se les llama \emph{átomos};
\item[\eqref{terminos:abstracciones}] establece que las cadenas de la forma \( (λx.M) \) son términos lambda, donde \( x \) es un átomo y \( M \) es cualquier término lambda, a estos términos se les llama \emph{abstracciones};
\item[\eqref{terminos:aplicaciones}] establece que las cadenas de la forma \( (M\, N) \) son términos lambda, donde \( M \) y \( N \) son términos lambda cualesquiera, a estos términos se les llama \emph{aplicaciones}.
\end{description}

En el estudio usual de lenguajes formales \cite{Hopcroft:Automata}, \( Λ \) pertenece a la clase de lenguajes libres de contexto y puede ser definido de la siguiente manera:

\begin{defn}[Términos lambda]
  \label{defn:terminos-cfg}
  El conjunto de términos lambda es el lenguaje generado por la gramática libre de contexto \( G \) conformado por

  \begin{description}
  \item[categorías sintácticas] \( T \), \( E \), \( F \) y \( A \), las cuales denotan las reglas para derivar términos lambda, aplicaciones, abstracciones y átomos respectivamente;
  \item[símbolos terminales] \( \{\mathtt{(},\ \mathtt{)},\ \mathtt{.},\ λ,\ v,\ {}_{0}\} \), los cuales son los símbolos que conforman a las cadenas en \( Λ \);
  \item[símbolo inicial] \( T \), el cual es el símbolo del que se derivan todos los términos lambda;
  \item[reglas de producción]
    \begin{subequations}
    \begin{align}
      \label{terminos-cfg:terminos} \tag{a}
      T & \rightarrow E\ \mid\ F\ \mid\ A \\
      \label{terminos-cfg:atomos} \tag{b}
      A & \rightarrow \mathtt{v}_{0}\ \mid\ A {}_{0} \\
      \label{terminos-cfg:abstracciones} \tag{c}
      F & \rightarrow \mathtt{(} λ\ A\ \mathtt{.}\ T\ \mathtt{)} \\
      \label{terminos-cfg:aplicaciones} \tag{d}
      E & \rightarrow \mathtt{(}\ T\ T\ \mathtt{)}
    \end{align}
  \end{subequations}
  \end{description}
\end{defn}

Dada una secuencia de símbolos \( M \), se pueden utilizar estas dos definiciones para verificar si \( M \) es o no un término lambda. En el caso de la definición inductiva, se debe presentar un razonamiento que pruebe que las partes de la cadena satisface la definición \ref{defn:terminos}. En el caso de la gramática libre de contexto \ref{defn:terminos-cfg} se debe presentar una derivación de la cadena a partir de la categoría sintáctica \( T \).

\begin{exmp} Sea \( M = (λv_{0}.(v_{00} (λv_{00}.v_{000}))) \), la cadena \( M \) es un término lambda ya que

  \begin{description}
  \item[Por definición inductiva]
    \begin{align*}
      v_{000} \in V &\implies v_{000} \in Λ; \\
      v_{00} \in V,\ v_{000} \in Λ &\implies (λv_{00}.v_{000}) \in Λ,\ v_{00} \in Λ; \\
      v_{00},\ (λv_{00}.v_{000}) \in Λ &\implies (v_{00} (λv_{00}.v_{000})) \in Λ; \\
      v_{0} \in V,\ (v_{00} (λv_{00}.v_{000})) \in Λ &\implies (λv_{0}.(v_{00} (λv_{00}.v_{000}))).
    \end{align*}
  \item[Por gramática] Se mantienen los espacios en los lados derechos de las producciones de la gramática para ser consistentes, sin embargo, el espacio en blanco no es un símbolo terminal, por lo tanto pueden ser omitidos.
    \begin{align*}
      T &\Rightarrow F \Rightarrow (\ λ\ A\ .\ T\ ) \Rightarrow (\ λ\ v_{0}\ .\ T\ ) \Rightarrow (\ λ\ v_{0}\ .\ E\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ T\ T\ )\ ) \\
        &\Rightarrow (\ λ\ v_{0}\ .\ (\ A\ T\ )\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ A_{0}\ T\ )\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ T\ )\ ) \\
        &\Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ F\ )\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ A\ .\ T\ )\ )\ ) \\
        &\Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ A_{0}\ .\ T\ )\ )\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ v_{00}\ .\ T\ )\ )\ ) \\
        &\Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ v_{00}\ .\ A\ )\ )\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ v_{00}\ .\ A_{0}\ )\ )\ ) \\
        &\Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ v_{00}\ .\ A_{00}\ )\ )\ ) \Rightarrow (\ λ\ v_{0}\ .\ (\ v_{00}\ (\ λ\ v_{00}\ .\ v_{000}\ )\ )\ ).
    \end{align*}
  \end{description}
\end{exmp}

\begin{exmp} Sea \( N = ((λv_{00}.v_{0}\, v_{00}) v_{0}) \), la cadena \( N \) no es un término lambda ya que

  \begin{description}
  \item[Por definición inductiva] Ya que \( Λ \) se definió como el \emph{conjunto más pequeño}, se demuestra que \( N \not\in Λ \) de la siguiente manera
    \begin{align*}
      (λv_{00}.v_{0}\, v_{00}), v_{0} \in Λ &\implies ((λv_{00}.v_{0}\, v_{00}) v_{0}) \in Λ; \\
      v_{00} \in V,\ v_{0}\, v_{00} \in Λ &\implies (λv_{00}.v_{0}\, v_{00}) \in Λ; \\
      v_{0}\, v_{00} \not\in Λ &\therefore ((λv_{00}.v_{0}\, v_{00}) v_{0}) \not\in Λ.
    \end{align*}
  \item[Por gramática] La gramática no es ambigua, realizando una derivación por la izquierda
    \begin{align*}
      T &\Rightarrow E \Rightarrow (\ T\ T\ ) \Rightarrow (\ F\ T\ ) \Rightarrow (\ (\ λ\ A\ .\ T\ )\ T\ ) \\
        &\Rightarrow (\ (\ λ\ A_{0}\ .\ T\ )\ T\ ) \Rightarrow (\ (\ λ\ v_{00}\ .\ T\ )\ T\ ) \\
        &\nRightarrow (\ (\ λ\ A\ .\ v_{0}\, v_{00}\ )\ T\ ).
    \end{align*}
  \end{description}
\end{exmp}

La sintaxis del cálculo lambda es uniforme, lo cual permite identificar su estructura con facilidad y evitar ambigüedades, sin embargo, suele ser tedioso escribir términos largos debido al extenso uso de paréntesis. Es por esto que en este trabajo se hacen las siguientes consideraciones sobre la notación:

\begin{enumerate}
\item \label{enum:notacion:1} El símbolo \( \synteq \) denota la equivalencia sintáctica entre dos términos lambda, esta equivalencia contempla las consideraciones de este listado.
\item \label{enum:notacion:2} Cuando se hace referencia a \emph{cualquier} término lambda se utilizan las letras mayúsculas \( M \), \( N \), \( P \), etc. Es importante establecer que si en un ejemplo, explicación, teorema o demostración se hace referencia a un término lambda con una letra mayúscula, cualquier otra aparición de esta letra hace referencia a este mismo término dentro de ese contexto.
\item \label{enum:notacion:3} Cuando se hace referencia a \emph{cualquier} átomo se utilizan las letras minúsculas \( x \), \( y \), \( z \), etc. Al igual que en el punto anterior, la aparición de una letra minúscula en un ejemplo, explicación, teorema o demostración hace referencia al mismo átomo.
\item \label{enum:notacion:4} Los paréntesis son omitidos de acuerdo a las siguientes equivalencias sintácticas:
  \begin{enumerate}
  \item \label{enum:notacion:4a} \( ((M\, N) P) \synteq M\, N\, P\), en general, se considera la aplicación de términos lambda con asociación a la izquierda. Se tiene que tener cuidado con respetar esta regla, por ejemplo \( (M(N(O\, P))) \synteq M(N(O\, P)) \not\synteq M\, N\, O\, P \).
  \item \label{enum:notacion:4b} \( (λx.(M N)) \synteq λx.(M N) \), en general, se puede escribir una abstracción omitiendo los paréntesis externos. Es necesario escribir de manera explícita los paréntesis en algunos casos, por ejemplo \( ((λx.(M\, N)) O) \synteq (λx.(M\, N)) O \not\synteq λx.(M\, N)O \) ya que el lado derecho de la equivalencia es sintácticamente equivalente a \( (λx.((M\, N)O)) \).
  \item \label{enum:notacion:4c} \( (λx.(λy.(λz.M))) \synteq (λx\, y\, z.M) \), en general, si el cuerpo de una abstracción es también una abstracción, se pueden agrupar las variables ligadas y enlazadas. Éste abuso de notación es consistente con la representación de funciones de varias variables usada por Schönfinkel \cite{Schonfinkel:Varargs}.
  \end{enumerate}
\item \label{enum:notacion:5} Para hacer referencia a una secuencia con una cantidad arbitraria de términos lambda se usa la notación \( \vec{x}=x_{1},...,x_{n} \) cuando es secuencia de átomos y \( \vec{M}=M_{1},...,M_{n} \) cuando es secuencia de términos lambda en general. Con esta notación se puede abreviar la consideración de \ref{enum:notacion:4a} como
  \[ ((\, ...\, ((M_{1}\, M_{2}) M_{3})\, ...\, ) M_{n}) \synteq \vec{M} \]
  y la consideración de \ref{enum:notacion:4c} como
  \[ (λx_{1}.(λx_{2}.(λx_{3}.\, ...\, (λx_{n}.M)\, ...\, ))) \synteq (λ\vec{x}.M) \]
  Ya que la notación no indica la cantidad de términos en la secuencia, se suele decir que \( \vec{M} \) cabe en \( \vec{N} \) cuando son secuencias con la misma cantidad de elementos.
\item Al escribir términos lambda con repetición de aplicaciones suele ser conveniente utilizar una notación más compacta. Cuando se aplica \( n \) veces un término \( F \) por la izquierda a otro término \( M \) se denota \( F^{n}\, M \). Cuando se aplica \( n \) veces un término \( M \) por la derecha a otro término \( F \) se denota \( F\, M^{\sim n}\). Por ejemplo, el término \( (f(f(f(f\, x)))) \) se puede denotar como \( (f^{4}\, x) \) y el término \( (f\, x\, x\, x\, x) \) se puede denotar como \( (f\, x^{\sim 4}) \). La definición inductiva de esta notación es:
  \begin{align}
    \label{eq:abuso:F}
    \begin{split}
      F^{n+1}\, M & \synteq F (F^{n}\, M) \\
      F^{0}\, M & \synteq M
    \end{split}
  \end{align}
  \begin{align}
    \label{eq:abuso:M}
    \begin{split}
      F\, M^{\sim n+1} & \synteq (F\, M^{\sim n}) M \\
      F\, M^{\sim 0} & \synteq F
    \end{split}
  \end{align}
\end{enumerate}

Inicialmente, estos abusos de notación pueden resultar confusos, sin embargo, al escribir términos lambda complejos resulta conveniente acortarlos. A continuación se muestran ejemplos de términos lambda asociados a términos sintácticamente equivalentes pero escritos con abuso de notación:

\begin{exmp}
  \label{exmp:notacion}
  \begin{align*}
    (((x\, y)z) (y\, x)) & \synteq x\, y\, z (y\, x) \\
    (λx.((u\, x)y)) & \synteq λx.u\, x\, y \\
    (λy.(u(λx.y))) & \synteq λy.u(λx.y) \\
    (((λy.((v\, u)u))z)y) & \synteq (λy.v\, u\, u) z\, y \\
    (((u\, x)(y\, z))(λv.(v\, y))) & \synteq u\, x(y\, z)(λv.v\, y) \\
    ((((λx.(λy.(λz.((x\, z) (y\, z))))) u) v) w) & \synteq (λx\, y\, z.x\, z(y\, z)) u\, v\, w
  \end{align*}
\end{exmp}

\subsection{Estructura}

Dado un término lambda \( M \) es deseable poder cuantificar algunas propiedades de acuerdo a su estructura, la medida más común es la de \emph{longitud}. Esta propiedad resulta importante en los razonamientos inductivos, por ejemplo, al plantear una demostración se suele usar la expresión ``por inducción sobre \( M \)'' la cual técnicamente se refiere a una inducción sobre la longitud de \( M \).

\begin{defn}[Longitud]
  La longitud de un término lambda \( M \), denotada como \( \| M \| \), es la cantidad de \emph{apariciones} de átomos en \( M \), se determina a partir de la estructura del término lambda como:
  \label{defn:longitud}
  \begin{align*}
    \|x\| & = 1 \\
    \|M\, N\| & = \|M\| + \|N\| \\
    \|λx.M\| & = 1 + \|M\|
  \end{align*}
\end{defn}

Debido a que la definición considera la cantidad de átomos en \( M \) y la longitud de un átomo es \( 1 \), se infiere que para cualquier término lambda \( M \), su longitud será estrictamente mayor a cero. Una implicación de esta observación es que al ``desbaratar'' la longitud de un término lambda de acuerdo a su estructura, en el caso de que \( M \) sea una aplicación o una abstracción, la longitud de sus partes es estríctamente menor a su longitud.

\begin{exmp} A continuación se presenta el procedimiento para calcular la longitud del término \( M \synteq (x(λy.y\, u\, x)) \) siguiendo la definición \ref{defn:longitud}
  \begin{align*}
    \| M \| &= \| (x(λy.y\, u\, x)) \| = \| (x (λy.((y\, u) x))) \\
            &= \| x \| + \| (λy.((y\, u) x)) \| = 1 + \| (λy.((y\, u) x)) \| \\
            &= 1 + ( 1 + \| ((y\, u) x) \|  ) = 2 + \| ((y\, u) x) \| \\
            &= 2 + \| (y\, u) \| + \| x \| = 2 + \| (y\, u) \| + 1 = 3 + \| (y\, u) \| \\
            &= 3 + \| y \| + \| u \| = 3 + 1 + 1 \\
            &= 5
  \end{align*}
\end{exmp}

Una cuestión importante al momento de demostrar un teorema o definir un concepto por inducción sobre un término lambda es que usualmente la inducción matemática relaciona proposiciones con números naturales. Sin embargo es posible tener dos términos diferentes \( M \) y \( N \) tal que \( \|M\| = \|N\| \), por ejemplo \( (λx.x) \) y \( (z\, z) \) tienen longitud \( 2 \).

La inducción sobre la longitud de un término lambda considera también la estructura del término, de tal manera que para una proposición \( P \) sobre un término lambda \( M \), los casos base de la inducción son aquellos en donde la estructura no es compuesta (en átomos cuya longitud siempre es \( 1 \)) y la hipótesis de inducción considera que \( P \) se cumple para los subtérminos de \( M \) cuya longitud siempre es estrictamente menor que \( \|M\| \).

En la definición de longitud se menciona de la cantidad de \emph{apariciones} de átomos en \( M \), el concepto de aparición de \( M \) en \( N \) para cualesquiera \( M \) y \( N \) se formaliza a partir del concepto de \emph{subtérmino}.

\begin{defn}[Subtérmino]
  \( M \) es un subtérmino de \( N \), denotado \( M \subset N \) si \( M \in \Sub(N) \), donde \( \Sub(N) \) es la colección de subtérminos de \( N \) definida de manera inductiva como
  \label{defn:subtermino}
  \begin{align*}
    \Sub(x) & = \{ x \} \\
    \Sub(λx.M) & = \Sub(M) \cup \{ λx.M \} \\
    \Sub(M\, N) & = \Sub(M) \cup \Sub(N) \cup \{ M\, N \}
  \end{align*}
\end{defn}

\begin{defn}[Aparición]
  La aparición de \( M \) en \( N \) implica que \( M \subset N \) o que \( M \) es \emph{el} argumento de una abstracción en \( N \).
  \label{defn:aparicion}
\end{defn}

Usualmente se habla de la aparición de \( M \) en \( N \) para referirse a una subtérmino en particular en \( N \), sin embargo, un subtérmino pude \emph{aparecer} varias veces en un término. Algunas clasificaciones de subtérminos son:

\begin{itemize}
\item Si \( M_{1} \) y \( M_{2} \) son subtérminos de \( N \) y no tienen átomos en común, se dice que son términos \emph{disjuntos} de \( N \), ya que si esta condición se cumple \( \Sub(M_{1}) \cap \Sub(M_{2}) = \emptyset \);
\item Si \( M \subset N \) y \( (M\, Z) \subset N \) se dice que \( M \) es un término \emph{activo} en \( N \), de lo contrario, se le llama \emph{pasivo};
\item Si \( M \subset N \) y \( (λx.M) \subset N \), se dice que la aparición \( M \) es el \emph{alcance} de la aparición del átomo \( x \) que acompaña a la \( λ \).
\end{itemize}

\begin{exmp}
  Sea \( M \synteq λx.x\, y (λz.y) \):
  \label{exmp:subterminos-apariciones}
  \begin{itemize}
  \item el término \( (x\, y) \subset M \);
  \item el átomo \( z \not\subset M \) pero si aparece en \( M \), debido a que \( z \) acompaña a una \( λ \);
  \item el término \( y(λz.y) \) a pesar de parecer ser un subtérmino de \( M \) no lo es, esto se puede corroborar escribiendo los términos sin el abuso de notación: \( y(λz.y) \synteq (y(λz.y)) \) y \( M \synteq λx.x y(λz.y) \synteq (λx.((x\, y)(λz.y))) \), en este caso, la clave está en observar la estructura de la aplicación \( (x\, y(λz.y)) \).
  \item Las apariciones de \( x \) y \( (λz.y) \) en \( M \) son disjuntas.
  \item Los términos \( x \) y \( (x\, y) \) son subtérminos activos de \( M \), mientras que \( y \) y \( (λz.y) \) son subtérminos pasivos.
  \end{itemize}
\end{exmp}

Los conceptos de longitud y de subtérmino nos permiten razonar de manera clara sobre la estructura de los términos lambda y con la clasificación de los subtérminos se puede caracterizar el rol que juegan las partes de un término en la estructura general.

\subsection{Clasificación}

A continuación se presentan algunos criterios para clasificar partes de los términos lambda y las propiedades que tienen los términos de acuerdo a su clasificación.

Al considerar las apariciones de átomos en un término lambda, es conveniente diferenciar a los átomos sintácticamente iguales dependiendo de el papel que juegan en el término.

\begin{defn}[Clasificación de variables]\label{defn:clasifvar}
  La aparición de un átomo \( x \) en un término \( P \) es llamada:
  \begin{itemize}
  \item \emph{variable ligada} si es un subtérmino de \( M \) en una abstracción \( (λx.M) \) en \( P \);
  \item \emph{variable enlazada} si y sólo si es la \( x \) que acompaña la \( λ \) de \( (λx.M) \) en \( P \);
  \item \emph{variable libre} en otro caso.
  \end{itemize}
\end{defn}

La diferencia entre un átomo \( x \subset M \) y una aparición de \( x \) en \( M \) es que la aparición se refiere a una variable en particular nombrada \( x \) en una parte específica de la estructura de \( M \). Por ejemplo, en el término lambda \( ((λx.x) x) \) la primera aparición del átomo \( x \) es una variable enlazada, la segunda aparición es una variable ligada y la tercera aparición es una variable libre.

Cuando se abordó el concepto de reducción en la sección \ref{sec:op-reduccion} la distinción entre una variable libre y una ligada era importante ya que las variables libres nunca son sustituídas en una reducción ya que el procedimiento relacionaba únicamente a las variables ligadas en el alcance de una abstracción activa.

\begin{exmp}
  Sea \( M \synteq x(λy.x\, y) \):
  \label{exmp:clasifvar}
  \begin{itemize}
  \item El átomo \( x \) aparece como variable libre dos veces en \( M \);
  \item El átomo \( y \) aparece como variable ligada en \( M \);
  \item El átomo \( y \) aparece como la variable enlazada de la abstracción.
  \end{itemize}
\end{exmp}

En la definición formal de algunos conceptos es conveniente hacer referencia a todas las variables libres de un término lambda.

\begin{defn}[Variables libres]
  El conjunto de variables libres de un término lambda \( M \) se denota \( \FV(M) \) y se define de manera inductiva como:
  \label{defn:varlib}
  \begin{align*}
    \FV(x) & = \{ x \} \\
    \FV(λx.M) & = \FV(M) \setminus \{ x \} \\
    \FV(M\, N) & = \FV(M) \cup \FV(N)
  \end{align*}
  Cuando \( \FV(M)=\emptyset \) se dice que \( M \) es un \emph{combinador} o \emph{término cerrado}.
\end{defn}

\begin{exmp}
  Consideremos los términos \( (x(λx.x\, y\, z)) \), \( (λx\, y\, z.y) \) y \( ((λy.x)λx.y) \).
  \label{exmp:varlib}
  \begin{itemize}
  \item \( \FV(x(λx.x\, y\, z)) = \{x,\ y,\ z\} \);
  \item \( \FV(λx\, y\, z.y)=\emptyset \), por lo tanto es un combinador;
  \item \( \FV((λy.x)λx.y)=\{ x,\ y \} \).
  \end{itemize}
\end{exmp}

En ocaciones es importante distinguir los términos lambda cerrados de aquellos que contienen variables libres, para ello se identifica el subconjunto de \( Λ \) que contiene a todos los términos cerrados:

\begin{defn}[Términos cerrados]
  Se denota como \( Λ^{0} \) al conjunto
  \label{defn:termcerr}
  \[ \{ M \in Λ \mid M \text{ es un término cerrado} \} \]
\end{defn}

La notación \( Λ^{0} \) se puede generalizar para identificar diferentes subconjuntos de \( Λ \) a partir de las variables libres de los términos lambda:

\[ Λ^{0}(\vec{x})=\{ M \in Λ \mid \FV(M) \subseteq \{ \vec{x} \} \} \]

De tal manera que:

\[ Λ^{0}=Λ^{0}(\emptyset) \]

Si consideramos un término \( M \) con variables libres, se puede encontrar otro término \( N \in Λ^{0} \) similar a \( M \), al cual se le llama clausura de \( M \).

\begin{defn}[Clausura] \label{defn:clausura}
  La clausura de un término lambda \( M \) con \( \FV(M) \not= \emptyset \) es un término lambda
  \[ (λ\vec{x}.M) \]
  con \( \vec{x}=\FV(M) \)
\end{defn}

\begin{exmp} \label{exmp:clausura}
  Sea \( M \synteq λz.x\, y\, z \)
  \begin{itemize}
  \item \( (λx\, y.λz.x\, y\, z) \) es una clausura de \( M \);
  \item \( (λy\, x\, z.x\, y\, z) \) es una clausura de \( M \);
  \item \( (λz\, x\, y.λz.x\, y\, z) \) no es una clausura de \( M \).
  \end{itemize}
\end{exmp}

\subsection{Sustitución de términos}
\paragraph{Pendiente explicar el resto de la sección}

\begin{defn}[Sustitución]
  \label{defn:sustitucion}
  Para cualesquiera términos lambda \( M \), \( N \) y \( x \), se define \( M[x:=N] \) como el resultado de sustituir cada aparición libre de \( x \) por \( N \) en \( M \) de acuerdo a las siguientes reglas:
  \begin{align*}
    x[x:=N] & \synteq N; \\
    a[x:=N] & \synteq a && a \not \synteq x; \\
    (P\, Q)[x:=N] & \synteq P[x:=N]\, Q[x:=N]; \\
    (λx.P)[x:=N] & \synteq λx.P; \\
    (λy.P)[x:=N] & \synteq λy.P && x \not\synteq y,\ x \not\in \FV(P); \\
    (λy.P)[x:=N] & \synteq λy.P[x:=N] && x \not\synteq y,\ x \in \FV(P),\ y \not\in \FV(N); \\
    (λy.P)[x:=N] & \synteq λz.P[y:=z][x:=N] && x \not\synteq y,\ x \in \FV(P),\ y \in \FV(N),\ z \not\in \FV(N P).
  \end{align*}
\end{defn}

\begin{exmp} \label{exmp:sustitucion}
  Procedimientos de sustituciones para cada uno de los casos de la definición \ref{defn:sustitucion}:
  \begin{itemize}
  \item Caso \( x[x:=N] \)
    \begin{align*}
      y[y:=λx.x] \synteq λx.x
    \end{align*}
  \item Caso \( a[x:=N] \), donde \( a \not\synteq x \)
    \begin{align*}
      z[w:=x\, x] \synteq z
    \end{align*}
  \item Caso \( (P\, Q)[x:=N] \)
    \begin{align*}
      (y\, x\, x)[x:=y] & \synteq ((y\, x) x)[x:=y] \\
                        & \synteq (y\, x)[x:=y]\, x[x:=y] \\
                        & \synteq (y[x:=y]\, x[x:=y]) y \\
                        & \synteq y\, y\, y
    \end{align*}
  \item Caso \( (λx.P)[x:=N] \)
    \begin{align*}
      (λf\, x.f\, f\, x)[f:=g] \synteq λf\, x.f\, f\, x
    \end{align*}
  \item Caso \( (λy.P)[x:=N] \), donde  \( x \not\synteq y \), \( x \not\in \FV(P) \)
    \begin{align*}
      (λf\, x.f\, f\, x)[f:=g] \synteq λf\, x.f\, f\, x
    \end{align*}
  \item Caso \( (λy.P)[x:=N] \), donde \( x \not\synteq y \), \( x \in \FV(P) \), \( y \not\in \FV(N) \)
    \begin{align*}
      (λf.x\, λx.f\, f\, x)[x:=y] & \synteq λf.(x\, λx.f\, f\, x)[x:=y] \\
                                  & \synteq λf.x[x:=y]\, (λx.f\, f\, x)[x:=y] \\
                                  & \synteq λf.y\, λx.f\, f\, x
    \end{align*}
  \item Caso \( (λy.P)[x:=N] \), donde \( x \not\synteq y \), \( x \in \FV(P) \), \( y \in \FV(N) \) y \( z \not\in \FV(N P) \)
    \begin{align*}
      (λf.x\, λx.f\, f\, x)[x:=f] & \synteq λg.(x\, λx.f\, f\, x)[f:=g][x:=f] \\
                                  & \synteq λg.(x[f:=g](λx.f\, f\, x)[f:=g])[x:=f] \\
                                  & \synteq λg.(x\, λx.(f\, f\, x)[f:=g])[x:=f] \\
                                  & \synteq λg.(x\, λx.((f\, f)[f:=g] x[f:=g]))[x:=f] \\
                                  & \synteq λg.(x\, λx.((f[f:=g]\, f[f:=g]) x))[x:=f] \\
                                  & \synteq λg.(x\, λx.g\, g\, x)[x:=f] \\
                                  & \synteq λg.x[x:=f] (λx.g\, g\, x)[x:=f] \\
                                  & \synteq λg.f\, λx.g\, g\, x
    \end{align*}
  \end{itemize}
\end{exmp}

En el último caso es importante observar que las apariciones ligadas de \( x \) no se sustituyen.

\begin{lem}
  Si \( (y\, x) \not\in \FV(L) \) y \( x \not\synteq y \), entonces
  \[ M[x:=N][y:=L] \synteq M[y:=L][x:=N[y:=L]] \]
\end{lem}

En contraste a la operación de sustitución en donde no se permite introducir o quitar referencias a variables enlazadas, el \emph{contexto} es un término con ``hoyos'':

\begin{defn}[Contexto]
  \label{defn:contexto}
  Un contexto es un término lambda denotado \( C[\quad] \) definido de manera inductiva:
  \begin{itemize}
  \item \( x \) es un contexto;
  \item \( [\quad] \) es un contexto;
  \item Si \( C_{1}[\quad] \) y \( C_{2}[\quad] \) son contextos, entonces \( C_{1}[\quad]\, C_{2}[\quad] \) y \( λx.C_{1}[\quad] \) también lo son.
  \end{itemize}
\end{defn}

Si \( C[\quad] \) es un contexto y \( M \in Λ \), entonces \( C[M] \) denota el resultado de reemplazar por \( M \) los hoyos de \( C[\quad] \). Al realizar esto, las variables libres de \( M \) pueden convertirse en variables ligadas de \( C[M] \).

\begin{exmp}
  Consideremos el contexto \( C[\quad] \synteq λx.x\, λy.[\quad] \) y el término lambda \( M \synteq (x y) \).
  
  \begin{align*}
    C[M] & \synteq (λx.x\, λy.[\quad])[(x\, y)] \\
         & \synteq (λx.x\, λy.(x\, y))
  \end{align*}
  
  El caso análogo con la sustitución es

  \begin{align*}
    (λx.x\, λy.w)[w:=(x\, y)] & \synteq λz.(x\, λy.w)[x:=z][w:=(x\, y)] \\
                              & \synteq λz.(x[x:=z] (λy.w)[x:=z])[w:=(x\, y)] \\
                              & \synteq λz.(z\, λy.w)[w:=(x y)] \\
                              & \synteq λz.z[w:=(x\, y)] (λy.w)[w:=(x\, y)] \\
                              & \synteq λz.z\, λv.w[w:=(x\, y)] \\
                              & \synteq λz.z\, λv.(x\, y)
  \end{align*}
\end{exmp}

\section{Los cálculos de la conversión lambda}
\label{sec:conversion-lambda}

El objetivo principal de esta subsección es presentar una formalización del cálculo lambda descrito en el capítulo \ref{ch:nocion-informal} desde el punto de vista de \emph{teorías formales}. El nombre técnico de la teoría formal principal de este trabajo es \( \bs{λKβ} \), se pueden realizar modificaciones y extensiones a esta teoría y los siguientes conceptos permiten estudiar las implicaciones de estos cambios.

\subsection{Teorías formales}
\label{sec:teorias-formales}

Una \emph{teoría formal} \( \mathcal{T} \) es una tripleta \( (\mathcal{F},\mathcal{A},\mathcal{R}) \) donde

\begin{itemize}
\item \( \mathcal{F} \) es el conjunto de todas las \emph{fórmulas} \( X = Y \) con \( X \) y \( Y \) elementos de un lenguaje formal;
\item \( \mathcal{A} \) es un conjunto de \emph{axiomas} y \( \mathcal{A} \subseteq \mathcal{F} \);
\item \( \mathcal{R} \) es un conjunto de \emph{reglas}.
\end{itemize}

Una regla es una función \( φ \colon \mathcal{F}^{n} \to \mathcal{F} \) con \( n \geq 1 \). Si se consideran \( n \) fórmulas \( A_{1},\ ...\ ,\ A_{n} \) tal que

\[ φ(A_{1},\ ...\ ,\ A_{n})=B \]

Se dice que la secuencia \( \langle A_{1},\ ...\ ,\ A_{n},\ B \rangle \) es una \emph{instancia} de la regla \( φ \). Las primeras \( n \) fórmulas de una instancia son llamadas \emph{premisas} y la última fórmula es llamada \emph{conclusión}. Para escribir una instancia de una regla se utiliza la notación

\[ \infer{B}{A_{1} & ... & A_{n}} \]

\begin{rem}
  En la literatura se pueden encuentrar diferentes maneras de trabajar con teorías formales, dependiendo de su ``estilo'' y definición, por ejemplo en \cite{Troelstra:ProofTheory} las reglas se definen como conjuntos de secuencias \( \langle A_{1},...,A_{n+1} \rangle \) con \( n \) premisas y una conclusión, en donde los axiomas se definen como elementos de \( \mathcal{R} \) con cero premisas. La definición de teoría formal presentada en este trabajo es del estilo Hilbert y está basada en \cite[pp.~69--70]{HindleySeldin:LambdaCalculusAndCombinators}.
\end{rem}

Si consideramos un conjunto de \emph{suposiciones} \( Γ \subseteq \mathcal{F} \), una \emph{deducción} de una fórmula \( B \) desde \( Γ \) es un árbol dirigido de fórmulas en donde los vértices de un extremo son elementos de \( \mathcal{A} \) o \( Γ \), los vértices intermedios son deducidos a partir de los vértices que inciden en ellos a partir de una regla y el vértice de el otro extremo siendo \( B \). Si y solo si existe una deducción para una fórmula \( B \), se dice que \( B \) es \emph{demostrable} en \( \mathcal{T} \) suponiendo \( Γ \), denotado

\[ \mathcal{T},Γ \vdash B \]

En caso que la deducción no tenga suposiciones, se dice que es una \emph{demostración} y que \( B \) es un \emph{teorema}. Cuando una deducción no tiene suposiciones, es decir, \( Γ = \emptyset \) se denota

\[ \mathcal{T} \vdash B \]

La relación binaria \( = \) en las fórmulas de una teoría es una relación de equivalencia, la cual por definición es \emph{reflexiva}, \emph{simétrica} y \emph{transitiva}. La \emph{clase de equivalencia} de un objeto \( x \) con respecto a \( = \) de una teoría formal \( \mc{T} \), denotado \( [x]_{\mc{T}} \), es el conjunto de todos los objetos \( y \) tal que \( x = y \) es una fórmula de \( \mc{T} \).

En el contexto de las teorias que formalizan los cálculos lambda, los objetos que se relacionan son términos lambda. La frase ``módulo convertibilidad'' se refiere al conjunto de todas las clases de equivalencia de \( Λ \) considerando la relación de equivalencia de la teoría formal con la que se esté trabajando.

Que este conjunto sea el objeto de estudio de una teoría \( \bs{λ} \) del cálculo lambda significa que cada elemento de \( Λ \) módulo convertibilidad, denotado \( Λ/\!=_{\bs{λ}} \), es distinto y representa una clase de términos lambda considerados en la teoría \( \bs{λ} \) como equivalentes. Cuando \( \bs{λ} \vdash M = N \) se dice que \( M \) y \( N \) son términos \emph{convertibles}, también denotado \( M =_{\bs{λ}} N \).

Habiendo definido una teoría \( \bs{λ} \), el interés de estudiarla es

\begin{itemize}
\item determinar los términos que son convertibles en \( \bs{λ} \);
\item estudiar las propiedades que comparten dos términos convertibles;
\item modificar a \( \bs{λ} \) y comparar la teoría modificada con la original.
\end{itemize}

La comparación entre teorías usualmente consiste en partir de una teoría \( \bs{λ} \), modificar sus fórmulas, axiomas o reglas para obtener otra teoría \( \bs{λ}^{\prime} \) y determinar si \( \bs{λ} \) y \( \bs{λ}^{\prime} \) son equivalentes. Para poder realizar esto, se debe definir formalmente cómo se modifica una teoría y cómo se demuestra que dos teorías son equivalentes.

Modificar una teoría \( \bs{λ} \) puede implicar cambiar la definición de sus términos, es decir, utilizar un lenguaje formal diferente al de \( \bs{λ} \) para expresar las fórmulas \( M=N \). Hacer cambios al lenguaje formal suele requerir modificar al conjunto \( \mc{F} \), \( \mc{A} \) y \( \mc{R} \) de la teoría.

La modificación al lenguaje formal puede ser únicamente de relevancia sintáctica, por ejemplo modificar una teoría \( \bs{λ} \) cuyo lenguaje de términos es el conjunto \( Λ^{0} \) para que los términos sean escritos con el índice de DeBruijn mostrado en \ref{exmp:debrujn} no tendría implicaciones fuertes en la convertibilidad de la teoría, ya que hay una correspondencia uno a uno entre estas dos notaciones. Por otro lado, modificar una teoría \( \bs{λ} \) con términos \( Λ \) de tal manera que se consideren únicamente los términos cerrados \( Λ^{0} \) si puede tener fuertes implicaciones en la convertibilidad de la teoría ya que habrá términos lambda no admitidos en fórmulas.

Otra manera de modificar una teoría \( \bs{λ} \) es añadir o quitar axiomas y reglas de inferencia. Para abordar la modificación de estas dos componentes de una teoría consideramos que los axiomas son reglas sin premisas.

Cuando se considera extender una teoría \( \bs{λ} \) con una nueva regla \( φ \) lo primero que se debe estudiar es si \( φ \) es \emph{derivable} en \( \bs{λ} \), es decir, si para cada instancia de \( φ \), su conclusión es deducible en \( \bs{λ} \) considerando sus premisas como suposiciones. Formalmente, para cada instancia \( \langle A_{1},\ ...\ ,\ A_{n},\ B \rangle \) de \( φ \), \( φ \) es derivable en \( \bs{λ} \) si y sólo si

\begin{equation}
  \label{eq:teorias-derivable}
  \bs{λ},\ \{ A_{1},\ ...\ ,\ A_{n} \} \vdash B
\end{equation}

Cuando añadir una regla \( φ \) a una teoría \( \bs{λ} \) no cambia el conjunto de teoremas se dice que la regla es \emph{admisible}, por ejemplo si \( φ \) es utilizada en la demostración de un teorema, pero este teorema se puede demostrar sin suponer las premisas de \( φ \), entonces añadir a \( φ \) no afecta el hecho de que el teorema exista en la teoría.

Otra manera de verificar si una regla \( φ \) es admisible en \( \bs{λ} \) es demostrando que la regla es \emph{correcta}. Una regla se dice ser correcta en una teoría \( \bs{λ} \) si y sólo si, para cada instancia \( \langle A_{1},\ ...\ ,\ A_{n},\ B \rangle \) de \( φ \):

\begin{equation}
  \label{eq:teorias-correcta}
  (\bs{λ} \vdash A_{1}),\ ...\ ,\ (\bs{λ} \vdash A_{n}) \implies (\bs{λ} \vdash B)
\end{equation}

Si una regla es derivable, entonces es admisible, sin embargo, una regla admisible no siempre es derivable. Consideremos una instancia \( \mc{r} \) de una regla admisible en \( \bs{λ} \) tal que ni las premisas, ni la conclusión de \( \mc{r} \) son demostrables en la teoría, entonces la implicación \eqref{eq:teorias-correcta} es verdadera para \( \mc{r} \), sin embargo esto no implica que se pueda demostrar la conclusión suponiendo las premisas. Por otro lado, si consideramos una instancia \( \mc{r} \) de una regla derivable en \( \bs{λ} \), entonces ya que la conclusión es demostrable suponiendo las premisas, demostrar las premisas asegura que se puede demostrar la conclusión.

Con estos conceptos se pueden definir dos criterios de equivalencia entre teorías: \emph{equivalentes en teoremas} y \emph{equivalentes en reglas}.

\begin{defn}[Equivalencia de teorías] \label{defn:teorias-equivalentes}
  Sean \( \bs{λ} \) y \( \bs{λ}^{\prime} \) dos teorías formales con el mismo conjunto de fórmulas.

  Se dice que las teorías son \emph{equivalentes en teoremas} cuando cada regla y axioma de \( \bs{λ} \) es admisible en \( \bs{λ}^{\prime} \) y viceversa.

  Se dice que las teorías son \emph{equivalentes en reglas} cuando cada regla y axioma de \( \bs{λ} \) es derivable en \( \bs{λ}^{\prime} \) y viceversa.

  La equivalencia en teoremas es una equivalencia más débil que la equivalencia en reglas.
\end{defn}

\subsection{Teoría \( \bs{λKβ} \)}
\label{sec:teorialambda}

La teoría \( \bs{λKβ} \) es la formalización del cálculo lambda que se ha tratado desde el inicio de este trabajo. Ya que es la teoría principal, a partir de este punto cuando se hable de \emph{la} teoría \( \bs{λ} \) se estará refiriendo a la teoría \( \bs{λKβ} \) y cuando se hable de \emph{las} teorías \( \bs{λ} \) se estará refiriendo a la familia de teorías que formalicen los cálculos lambda.

\begin{defn}[Teoría \( \bs{λKβ} \)]
  \label{defn:teorialambda}

  El conjunto de fórmulas \( \mc{F} \) en \( \bs{λKβ} \) tiene como elementos ecuaciones de la forma:

  \begin{align*}
    M = N & & \forall M,N \in Λ \text{ (de la definición~\ref{defn:terminos})}
  \end{align*}
  
  Los axiomas \( \mc{A} \) de \( \bs{λKβ} \) son:

  \begin{subequations}
    \begin{align}
      \label{teorialambda:alpha} \tag{\( α \)}
      λx.M & = λy.M[x:=y] & &  \forall y \not\in \FV(M) \\
      \label{teorialambda:beta} \tag{\( β \)}
      (λx.M)N & = M[x:=N] \\
      \label{teorialambda:rho} \tag{\( ρ \)}
      M & = M
    \end{align}
  \end{subequations}

  Las reglas \( \mc{R} \) de \( \bs{λKβ} \) son:

  \begin{equation}
    \label{teorialambda:mu} \tag{\( μ \)}
    \infer{Z\, M = Z\, N}{M = N}
  \end{equation}
  \begin{equation}
    \label{teorialambda:nu} \tag{\( ν \)}
    \infer{M\, Z = N\, Z}{M = N}
  \end{equation}
  \begin{equation}
    \label{teorialambda:xi} \tag{\( ξ \)}
    \infer{λx.M = λx.N}{M = N}
  \end{equation}
  \begin{equation}
    \label{teorialambda:tau} \tag{\( τ \)}
    \infer{M = P}{M = N & N = P}
  \end{equation}
  \begin{equation}
    \label{teorialambda:sigma} \tag{\( σ \)}
    \infer{N = M}{M = N}
  \end{equation}
  
\end{defn}

Consideremos la convertibilidad en \( \bs{λKβ} \) de los términos lambda
\begin{align*}
  M &\synteq (λf.x((λy.y\, f) λz.z))w \\
  N &\synteq x\, w
\end{align*}

Se demuestra que \( M=_{\bs{λKβ}}N \) construyendo un árbol de deducción como el de la figura \ref{fig:demostrabilidad}.

\begin{figure}
  \centering
  \begin{tikzpicture}[
    equat/.style={rectangle,draw},grow=up,edge from parent/.style={draw,latex-},
    level 1/.style={sibling distance=20em, level distance=5em},
    level 2/.style={sibling distance=40em},
    level 3/.style={sibling distance=20em},
    level 4/.style={sibling distance=10em}
    ]
    \node [equat] (foo1) {\( (λf.x((λy.y\, f) λz.z))w = x\, w \)}
    child {
      node [equat] (foo3) {\( (λf.x\, f)w = x\, w \)}
    }
    child {
      node [equat] (foo5) {\( (λf.x((λy.y\, f) λz.z))w = (λf.x\, f)w \)}
      child {
        node [equat] (foo7) {\( λf.x((λy.y\, f) λz.z) = λf.x\, f \)}
        child {
          node [equat] (foo9) {\( x((λy.y\, f) λz.z) = x\, f \)}
          child {
            node [equat] (foo11) {\( (λy.y\, f)λz.z = f \)}
            child {
              node [equat] (foo13) {\( (λz.z)f = f \)}
            }
            child {
              node [equat] (foo14) {\( (λy.y\, f)λz.z = (λz.z) f \)}
            }
            edge from parent [] node [right] {\( (μ) \)}
          }
          edge from parent [] node [right] {\( (ξ) \)}
        }
        edge from parent [] node [right] {\( (ν) \)}
      }
    };
    \node [above=0em of foo13] (bar1) {\( (β) \)};
    \node [above=0em of foo14] (bar2) {\( (β) \)};
    \node [above=0em of foo11] (bar3) {\( (τ) \)};
    \node [above=0em of foo1] (bar4) {\( (τ) \)};
    \node [above=0em of foo3] (bar5) {\( (β) \)};
  \end{tikzpicture}
  \caption{Árbol de deducción para demostrar la convertibilidad entre dos términos}
  \label{fig:demostrabilidad}
\end{figure}

\subsection{Combinadores \( \bs{SKI} \)}
\label{sec:combinadores-ski}

\begin{defn}[Combinadores SKI]
  \label{defn:ski}
  Tres términos lambda de suma importancia son
  \begin{align*}
    \bs{I} & \synteq λx.x \\
    \bs{K} & \synteq λx\, y.x \\
    \bs{S} & \synteq λx\, y\, z.x\, z(y\, z)
  \end{align*}
\end{defn}

\begin{cor}
  \label{cor:ski}
  Para todo término \( M,N,L \in Λ \)

  \begin{align*}
    \bs{I}\, M & =_{\bs{λ}} M \\
    \bs{K}\, M\, N & =_{\bs{λ}} M \\
    \bs{S}\, M\, N\, L & =_{\bs{λ}} M\, L (N\, L)
  \end{align*}
\end{cor}

Estos tres combinadores generan en la teoría \( \bs{λ} \) al conjunto \( Λ^{0} \) con combinaciones de aplicaciones. Debido a que \( \bs{SKK} =_{\bs{λ}} \bs{I} \), sólo es necesario combinar con aplicaciones a \( \bs{K} \) y a \( \bs{S} \) para generar cualquier término cerrado.

\begin{defn}[Bases]
  \label{defn:bases}
  \begin{enumerate}
  \item Sea \( \mathcal{X} \subset Λ \). El conjunto de términos \emph{generado} por \( \mathcal{X} \), denotado \( \mathcal{X}^{+} \), es el conjunto mas pequeño tal que
    \begin{enumerate}
    \item \( \mathcal{X} \subseteq \mathcal{X}^{+} \),
    \item \( M, N \in \mathcal{X}^{+} \implies (M N) \in \mathcal{X}^{+} \).
    \end{enumerate}
  \item Sea \( \mathcal{P} \subset Λ \). \( \mathcal{X} \subset Λ \) es una \emph{base} para \( \mathcal{P} \) si para toda \( M \in \mathcal{P} \) existe \( N \in \mathcal{X}^{+} \) tal que \( N = M \).
  \item \( \mathcal{X} \) es llamada una \emph{base} si \( \mathcal{X} \) es una base para \( Λ^{0} \).
  \end{enumerate}
\end{defn}

\begin{lem}
  \label{lem:ski}
  Sea \( λx.M \) una abstracción tal que \( \Sub(M) \) no contiene abstracciones

  \begin{enumerate}
  \item Si \( M = x \), entonces \( λx.M = \bs{I} \);
  \item Si \( x \not\in \FV(M) \), entonces \( λx.M = (\bs{K} M) \);
  \item Si \( M = P\, Q \), entonces \( λx.M = \bs{S}(λx.P)(λx.Q) \).
  \end{enumerate}
\end{lem}

\begin{proof}
  Ver \ref{defn:ski} y \ref{cor:ski}
  \begin{enumerate}
  \item
    \begin{align*}
      (\bs{I}\, N) &= N \\
                   &= ((λx.x) N) \\
                   &= ((λx.M) N)
    \end{align*}
  \item
    \begin{align*}
      ((\bs{K}\, M) N) &= (λx\, y.x)M\, N \\
                       &= (λy.M)N \\
                       &= ((λx.M)N)
    \end{align*}
  \item
    \begin{align*}
      \bs{S}(λx.P)(λx.Q) &= (λabc.(a\, c)(b\, c))(λx.P)(λx.Q) \\
                         &= λc.((λx.P)c)((λx.Q)c) \\
                         &= λc.P[x:=c]Q[x:=c] \\
                         &= λc.(P\, Q)[x:=c] \\
                         &= λx.P\, Q \\
                         &= λx.M
    \end{align*}
  \end{enumerate}
\end{proof}

\begin{prop}
  \label{prop:ski}
  \( \{ \bs{S}, \bs{K}, \bs{I} \} \) es una base, es decir, para todo término \( M \in Λ^{0} \), existe un término \( M' \) compuesto de aplicaciones de \( \bs{S} \), \( \bs{K} \) e \( \bs{I} \) tal que \( M = M' \).
\end{prop}

La demostración de la proposición \ref{prop:ski} consiste en la construcción de un algoritmo para transformar \( M \) a \( M' \).

\begin{proof}
  \label{proof:ski}
  Sea \( M \in Λ^{0} \), se construye un término \( M' \in \{ \bs{S},\bs{K},\bs{I} \}^{+} \) tal que \( M' = M \) enumerando los subtérminos en \( M \) que sean abstracciones de menor a mayor longitud.

  Sea \( λx.N \) la abstracción con menor longitud en \( M \), según la estructura de \( N \) se aplican las siguientes transformaciones:

  \begin{enumerate}
  \item Si \( N = a \)
    \begin{enumerate}
    \item \label{item:ski:1a} Si \( a = x \) se transforma \( λx.N \) a \( \bs{I} \) en \( M \).
    \item \label{item:ski:1b}Si \( a \not= x \) se transforma \( λx.N \) a \( (\bs{K}\, a) \) en \( M \).
    \end{enumerate}
  \item \( N = (P\, Q) \)
    \begin{enumerate}
    \item \label{item:ski:2a} Si \( x \not\in \FV(P) \) y \( x \not\in \FV(Q) \) se transforma \( λx.P\, Q \) a \( \bs{S} (\bs{K}\, P) (\bs{K}\, Q) \) en \( M \).
    \item \label{item:ski:2b} Si \( x \not\in \FV(P) \) y \( x \in \FV(Q) \) se transforma \( λx.P\, Q \) a \( \bs{S} (\bs{K}\, P) (λx.Q) \) en \( M \).
    \item \label{item:ski:2c} Si \( x \in \FV(P) \) y \( x \not\in \FV(Q) \) se transforma \( λx.P\, Q \) a \( \bs{S} (λx.P) (\bs{K}\, Q) \) en \( M \).
    \item \label{item:ski:2d} Si \( x \in \FV(P) \) y \( x \in \FV(Q) \) se transforma \( λx.P\, Q \) a \( \bs{S} (λx.P) (λx.Q) \) en  \( M \).
    \end{enumerate}
  \end{enumerate}

  En los casos \ref{item:ski:2a}, \ref{item:ski:2b}, \ref{item:ski:2c}, \ref{item:ski:2d} se forman abstracciones con longitud menor a \( λx.N \), por lo tanto serán las que se transformarán después. Ya que la longitud de estas abstracciones es estrictamente menor a \( λx.N \) y los casos base \ref{item:ski:1a} y \ref{item:ski:1b} de la transformación no introducen abstracciones, en una cantidad finita de pasos el término \( M \) transformado no tendrá abstracciones de la forma \( λx.N \).

  Para un término \( M \) con sólo una abstracción, \( \mathit{a} \) aplicaciones y \( \mathit{v} \) variables ligadas (no enlazadas) una cota superior para la máxima cantidad de pasos se calcula considerando que para los términos de la forma \( λx.a \) se cumple el caso \ref{item:ski:1b} (el cual aumenta la cantidad de aplicaciones en 1) y que para los términos de la forma \( λx.P\, Q \) se cumple el caso \ref{item:ski:2d} (el cual aumenta la cantidad de aplicaciones en 2) ya que en estos casos se produce el término con mas aplicaciones, las cuales determinan la cantidad de veces que se repite el algoritmo por cada abstracción en \( M \). Para calcular la cota superior de la cantidad de aplicaciones \( a' \) que produce el algoritmo para un término con \( n \) abstracciones se plantea la siguiente relación de recurrencia:

  \begin{align*}
    \mathit{a}'_{0} &= \mathit{a} \\
    \mathit{a}'_{n} &= 2 \times \mathit{a}'_{n-1} + \mathit{v}
  \end{align*}

  Esta recurrencia describe la función \( \mathit{a}' \colon \mathbb{N} \to \mathbb{N} \):

  \[ \mathit{a}'(n) = 2^{n} \times \mathit{a} + (2^{n}-1) \times \mathit{v} \]

  Para la cota superior de la cantidad de pasos realizados por el algoritmo para un término \( M \) con \( n \) abstracciones, se plantea la siguiente relación de recurrencia basada en \( \mathit{a}' \) y en el hecho de que la cantidad de variables ligadas y no enlazadas no aumenta en los pasos del algoritmo:

  \begin{align*}
    \mathit{p}_{0} &= 0 \\
    \mathit{p}_{n} &= \mathit{p}_{n-1} + \mathit{a}'(n-1) + \mathit{v}
  \end{align*}

  Esta recurrencia describe la función \( \mathit{p} \colon \mathbb{N} \to \mathbb{N} \):

  \begin{align*}
    \mathit{p}(n) &= (\mathit{a} + \mathit{v}) \times \sum_{i=0}^{n-1} 2^{i} \\
                  &= (\mathit{a} + \mathit{v}) \times (2^{n}-1)
  \end{align*}
  
\end{proof}

\paragraph{Algoritmo para compilar \( Λ^{0} \bs{\mapsto} \{ \bs{S},\ \bs{K},\ \bs{I} \}^{+} \)}

\begin{algorithm}
  \caption{SKI}
  \begin{algorithmic}
    \REQUIRE \( M \in Λ^{0} \)
    \ENSURE \( M' \in \{ \bs{S},\ \bs{K},\ \bs{I} \} \)
    
    \STATE \( M' \leftarrow M \)
    \STATE \( \mathcal{L} \leftarrow \{ A \in \Sub(M') \mid A \synteq λx.N \} \)
    
    \WHILE{\( \mathcal{L} \not= \emptyset \)}
    
    \STATE \( A \leftarrow λx.N \in \mathcal{L} \mid \| λx.N \| \leq A', \forall A' \in \mathcal{L} \)
    
    \IF{\( A \synteq λx.a \)}
    \IF{\( a \synteq x \)}
    \STATE \( M'[A] \leftarrow \bs{I} \)
    \ELSIF{\( a \not\synteq x \)}
    \STATE \( M'[A] \leftarrow \bs{K}\, a \)
    \ENDIF
    \ELSIF{\( A \synteq λx.P\, Q \)}
    \IF{\( x \not\in \FV(P) \land x \not\in \FV(Q) \)}
    \STATE \( M'[A] \leftarrow \bs{S} (\bs{K}\, P) (\bs{K}\, Q) \)
    \ELSIF{\( x \not\in \FV(P) \land x \in \FV(Q) \)}
    \STATE \( M'[A] \leftarrow \bs{S} (\bs{K}\, P) (λx.Q) \)
    \ELSIF{\( x \in \FV(P) \land x \not\in \FV(Q) \)}
    \STATE \( M'[A] \leftarrow \bs{S} (λx.P) (\bs{K}\, Q) \)
    \ELSIF{\( x \in FV(P) \land x \in \FV(Q) \)}
    \STATE \( M'[A] \leftarrow \bs{S} (λx.P) (λx.Q) \)
    \ENDIF
    \STATE \( M'[A] \leftarrow \mathrm{SKI}(\ M'[A]\ ) \)
    \ENDIF
    
    \STATE \( \mathcal{L} \leftarrow \mathcal{L} \setminus \{ A \} \)
    
    \ENDWHILE
    \RETURN \( M' \)
  \end{algorithmic}
\end{algorithm}

\subsection{Teoría \( \bs{λIβ} \)}
\label{sec:lambda-i-beta}

En el artículo \cite{Church:LambdaConversion}, Alonzo Church presenta una definición del cálculo lambda con un conjunto restringido de términos lambda. A la teoría que considera a este conjunto restringido de términos lambda (denotado \( Λ_{I} \)) y los axiomas y reglas de inferencia de la teoría \( \bs{λ} \) cambiando \( Λ \) por \( Λ_{I} \) se le conoce como teoría \( \bs{λIβ} \) (o el cálculo \( λI \)).

\begin{defn}[Términos en \( Λ_{I} \)]
  \label{defn:lambdaI}
  \begin{align*}
    x \in V & \implies x \in Λ_{I} \\
    M \in Λ_{I},\ x \in \FV{M} & \implies λx.M \in Λ_{I} \\
    M, N \in Λ_{I} & \implies M\, N \in Λ_{I}
  \end{align*}
\end{defn}

La diferencia fundamental entre las teorías \( \bs{λKβ} \) y \( \bs{λIβ} \) es el término lambda \( \bs{K} \), ya que \( \bs{K} \in Λ \setminus Λ_{I} \) pero \( \bs{K} \not\in Λ_{I} \). Esto es debido a que el subtérmino \( λy.x \) en \( \bs{K} \) de la definición \ref{defn:ski} no puede existir en \( Λ_{I} \) debido a que \( y \not\in \FV(x) \).

\subsection{Extensionalidad}
\label{sec:extensionalidad}

El concepto de igualdad de funciones usado en la mayoría de las ramas de la matemática es lo que se conoce como ``extensional'', esta propiedad de las relaciones de equivalencia hace referencia a las características externas de los objetos que compara, en el caso de las funciones, se incluye la suposición de que para funciones \( f \) y \( g \) con el mismo dominio

\[ \forall x [ f(x)=g(x) ] \implies f=g \]

Contraria a esta suposición, en la computación, el tema central son los procedimientos y procesos que describen los programas o algoritmos, cuyas igualdades ``intensional'', es decir, si dos programas computan la misma función matemática, no necesariamente se dice que son el mismo programa ya que uno pudiera ser mas eficiente que otro (la característica de eficiencia es interna a cada algorítmo).

La teoría \( \bs{λ} \) también es intensional: existen dos términos lambda \( F \) y \( G \) tales que para tódo término \( X \)

\[ \bs{λ} \vdash F\, X = G\, X \]

Pero no \( \bs{λ} \vdash F=G \). Por ejemplo, \( F \synteq y \) y \( G \synteq λx.y\, x \)

Cuando se plantea formalizar un cálculo lambda que sea extensional, surge la pregunta, ¿Qué es demostrable en el sistema extensional que no es demostrable en \( \bs{λ} \). A continuación se presentan tres diferentes agregados a la teoría \( \bs{λ} \) las cuales incluyen la propiedad de extensionalidad y que han sido propuestas en la literatura \cite{HindleySeldin:LambdaCalculusAndCombinators,Barendregt:Bible}. Las teorías extendidas son llamadas \( \bs{λζ} \), \( \bs{λ+ext} \) y \( \bs{λη} \) de acuerdo a la regla que se añade a la definición \ref{defn:teorialambda}.

\begin{defn}[Reglas de extensionalidad]
  \label{defn:extensionalidad}
  Cada una de las siguientes reglas nos permite añadir a \( \bs{λ} \) la propiedad de extensionalidad.
  \begin{description}
  \item[Reglas de inferencia]
    \begin{subequations}
      \begin{align}
        \label{extensionalidad:zeta} \tag{\( ζ \)}
        \infer{M = N}{M\, x = N\, x} & & \text{si \( x \not\in \FV(M\, N) \)} \\
        \label{extensionalidad:ext} \tag{ext}
        \infer{M = N}{M\, P = N\, P} & & \forall P \in Λ
      \end{align}
    \end{subequations}
  \item[Axiomas]
    \begin{align}
      \label{extensionalidad:eta} \tag{\( η \)}
      λx.M\, x = M & & \text{si \( x \not\in \FV(M) \)}
    \end{align}
  \end{description}
\end{defn}

La regla \eqref{extensionalidad:zeta} dice, de manera informal, que si \( M \) y \( N \) tienen el mismo efecto sobre un objeto no especificado \( x \), entonces \( M = N \). La regla \eqref{extensionalidad:ext} tiene una infinidad de premisas, una por cada término lambda \( P \), por lo tanto, las deducciones en donde se involucre esta regla serán árboles infinitos.

\paragraph{Pendiente} Comparación entre teorías formales, énfasis en \( η \) contra \( ζ \) contra \( ext \).

\section{Teoría de reducción}
\label{sec:teoriareduccion}

1.14 y 2.9

\subsection{Contracciones}
\label{sec:contracciones}

Transformaciones de términos con un paso.

\begin{defn}[Contracciones Hindley y Seldin]
  \label{defn:contraccion}
  Dado un término lambda \( X \), una \emph{contracción} en \( X \) es una tripleta \( \langle X,R,Y \rangle \), denotada \( X \contract{R} Y \), donde \( R \) es una aparición de un \emph{redex} en \( X \) y \( Y \) es el resultado de contraer \( R \) en \( X \).
\end{defn}

\begin{exmp}
  \begin{align*}
    (λx.(λy.y\, x)z)v &\contract{(λx.(λy.y\, x)z)v} (λy.y\, v)z ,\\
    (λx.(λy.y\, x)z)v &\contract{(λy.y\, x)z} (λx.z\, x)v.
  \end{align*}
\end{exmp}

\subsection{Reducciones}
\label{sec:reducciones}

Reducciones basadas en contracciones, de Barendregt

\begin{defn}[Relación compatible]
  \label{defn:compatible}
  Si dice que una relación binaria \( \bs{R} \) sobre \( Λ \) es:
  \begin{enumerate}
  \item Una \emph{relación compatible} cuando
    \[ (M,M') \in \bs{R} \implies (Z\, M,Z\, M') \in \bs{R},\ (M\, Z,M'\, Z) \in \bs{R},\ (λx.M,λx.M') \in \bs{R} \]
    para toda \( M, M', Z \in Λ \).
  \item Una \emph{relación de congruencia} cuando \( \bs{R} \) es compatible, reflexiva, transitiva y simétrica.
  \item Una \emph{relación de reducción} cuando \( \bs{R} \) es compatible, reflexiva y transitiva.
  \end{enumerate}
  \emph{compatible} cuando

\end{defn}

\begin{note}
  Una relación \( \bs{R} \subseteq Λ^{2} \) es compatible cuando

  \[ (M,M') \in \bs{R} \implies (C[M],C[M']) \in \bs{R} \]

  para toda \( M, M' \in Λ \) y todo contexto \( C[\quad] \), con un hoyo.
\end{note}

\begin{defn}
  \label{defn:nocion-reduccion}
  Una \emph{noción de reducción} en \( Λ \) es una relación binaria \( \bs{R} \) en \( Λ \).
\end{defn}

Sean \( \bs{R}_{1} \) y \( \bs{R}_{2} \) nociones de reducción, la relación \( \bs{R}_{1} \cup \bs{R}_{2} \) se denota \( \bs{R}_{1}\bs{R}_{2} \).


\begin{defn}[Reducción \( \bs{β} \)]
  La regla \eqref{teorialambda:beta} en la teoría \( \bs{λ} \) se puede definir como la reducción:
  
  \[ \bs{β} = \{ ((λx.M)N,M[x:=N]) : M, N \in Λ \} \]
\end{defn}

\begin{defn}
  Sea \( \bs{R} \) una noción de reducción en \( Λ \), \( \bs{R} \) introduce las relaciones binarias:

  \begin{itemize}
  \item R-reducción en un paso, denotada \( \contract{R} \) y definida de manera inductiva como:
    \begin{align*}
      \text{(1)} && (M,N) \in \bs{R} &\implies M \contract{R} N \\
      \text{(2)} && M \contract{R} N &\implies Z\, M \contract{R} Z\, N \\
      \text{(3)} && M \contract{R} N &\implies M\, Z \contract{R} N\, Z \\ 
      \text{(4)} && M \contract{R} N &\implies λx.M \contract{R} λx.N
    \end{align*}
  \item R-reducción, denotada \( \reduce{R} \) y definida de manera inductiva como:
    \begin{align*}
      \text{(1)} && M \contract{R} N &\implies M \reduce{R} N \\
      \text{(2)} && M \reduce{R} M \\
      \text{(3)} && M \reduce{R} N,\ N \reduce{R} L &\implies M \reduce{R} L
    \end{align*}
  \item R-convertibilidad, denotada \( \convertible{R} \) y definida de manera inductiva como:
    \begin{align*}
      \text{(1)} && M \reduce{R} N &\implies M \convertible{R} N \\
      \text{(2)} && M \convertible{R} N &\implies N \convertible{R} M \\
      \text{(3)} && M \convertible{R} N,\ N \convertible{R} L &\implies M \convertible{R} L
    \end{align*}
  \end{itemize}
\end{defn}

\begin{lem}
  Las relaciones \( \contract{R} \), \( \reduce{R} \) y \( \convertible{R} \) son compatibles. Por lo tanto \( \reduce{R} \) es una relación de reducción y \( \convertible{R} \) es una relación de congruencia.
\end{lem}

\begin{proof}
  
\end{proof}

Usualmente una noción de reducción se introduce de la siguiente manera: ``Sea \( \bs{R} \) definida por las siguientes \emph{reglas de contracción} \ \( \bs{R} \colon M \contract{} N \text{ dado que } ... \)''.

Esto significa que \( \bs{R} = \{ (M,N) : ... \} \), por ejemplo, \( \bs{β} \) pudo haber sido introducida por la siguiente regla de contracción

\[ \bs{β} : (λx.M)N \contract{} M[x:=N] \]

\begin{defn}
  \begin{enumerate}
  \item Un \( R \)-redex es un término \( M \) tal que \( (M,N) \in R \) para algún término \( N \). En este caso \( N \) es llamado un \( R \)-contractum de \( M \).
  \item Un término \( M \) es llamado una forma normal de \( R \), denotado \( R-fn \), si \( M \) no contiene algún \( R \)-redex.
  \item Un término \( N \) es una \( R-fn \) de \( M \) (o \( M \) tiene la \( R-fn \) \( N \)) si \( N \) es una \( R-fn \) y \( M \convertible{R} N \).
  \end{enumerate}
\end{defn}

El proceso de pasar de un redex a su contractum es llamado \emph{contracción}. En lugar de escribir ``\( M \) es una \( R-fn \)'' usualmente se escribe ``\( M \) está en \( R-fn \)'', pensando en una máquina que ha llegado a su estado final.

\begin{exmp}
  \( (λx.x\, x)λy.y \) es un \( β \)-redex. Por lo tanto \( (λx.x\, x)(λy.y)z \) no está en \( β-fn \); sin embargo este término tiene la \( β-fn \) \( z \).
\end{exmp}

Plantear las ideas para pasar del concepto de contracción al de reducción y posteriormente al de convertibilidad.

Gráficas de reducción.

Teorema de Church-Rosser y toda la magia necesaria para abordarlo y la magia que valga la pena mencionar en la que CR es importante va aquí.

Probablemente es buena idea separar la sección ``Noción informal del cálculo lambda'' y ``Formalización del cálculo lambda'' en dos capítulos diferentes. ¿Valdrá la pena abordar árboles de Böhm?


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
