
\section{Álgebra Booleana}
\label{sec:algebra-booleana}

El álgebra booleana es una rama del álgebra en donde las expresiones tienen asociado un valor de \emph{falso} o \emph{verdadero}. Estas expresiones son fundamentales en el estudio de circuitos y programas escritos en lenguajes de programación.

Los términos lambda no tienen asignados un valor de verdad y las operaciones que se plantearon en los primeros dos capítulos involucraron el concepto de falso y verdadero únicamente en el metalenguaje y asociando estos valores no a los términos lambda en sí, si no a propiedades de estos, por ejemplo, es falso que \( \| λx.x \| = 5 \) y es verdadero que \( (\bs{K}\, x) \reduce{β} (λx.y) \). Sin embargo es posible codificar los valores de verdad como elementos de \( Λ \) y construir abstracciones que emulen las propiedades de las operaciones booleanas bajo la \( β \)-reducción. De esta manera se pueden escribir términos que, de acuerdo con la codificación establecida, representen expresiones booleanas y términos lambda al mismo tiempo.

En los lenguajes de programación usualmente se mezclan las expresiones booleanas con otras expresiones y objetos a partir de \emph{predicados}, éstos son funciones con algún dominio \( X \) y codominio \( \{ \mathrm{falso},\ \mathrm{verdadero} \} \). Por ejemplo, al escribir un programa en donde se necesite tomar una desición a partir de si un número \( n \) es positivo o negativo se escribiría (en pseudocódigo):

\begin{algorithmic}
  \IF{esPositivo(\( n \))}
  \STATE \( ... \)
  \ELSE
  \STATE \( ... \)
  \ENDIF
\end{algorithmic}

En este ejemplo <<esPositivo>> es un predicado que es evaluado a falso si \verb!n! no es positivo y a verdadero si lo es.

La codificación de valores de verdad y operaciones booleanas es común incluso en lenguajes de programación populares, por ejemplo en C, el tipo \texttt{bool} es codificado como un entero, en donde falso es 0 y verdadero cualquier otro entero, a su vez, los enteros son codificados usualmente como secuencias de 32 bits en complemento a dos. Por lo tanto, si <<esPositivo>> fuera una función de C: <<esPositivo(8)>> sería evaluado a 1 y <<esPositivo(-8)>> sería evaluado a 0.

Al igual que el cálculo lambda, otras teorías que fundamentan las ciencias de la computación también carecen de expresiones y operaciones booleanas. En el caso de la máquina de Turing los cambios de estado en la ejecución de un programa se determinan a partir de su función de transición y predicados simples de igualdad entre símbolos del alfabeto de cinta se realizan en un paso, sin embargo, predicados mas complejos requieren ser codificados con estados, transiciones y anotaciones en su cinta.

\subsection{Valores de verdad}
\label{sec:valores-de-verdad}

En el álgebra booleana, los valores de las expresiones son falso y verdadero. El nombre de estos valores no es de relevancia y usualmente falso se representa como 0 y verdadero como 1. El aspecto importante de estos valores es que son distintos y si un valor \( x \) no es uno, entonces es el otro.

\paragraph{Revisar} Me parece que suena confusa la analogía, el objetivo es plantear la idea de no codificar falso y verdadero como un valor en particular, si no como una desición.

Podemos ignorar la representación concreta de estos valores y pensar en una situación hipotética: Una persona omnisciente y muda llamada \( P \) puede decirme si una oración que le digo es falsa o verdadera dándole una manzana y una pera; si me regresa la manzana significa que la oración es verdadera y si me regresa la pera significa que la oración es falsa. En este planteamiento irreal e hipotético, no fué necesario conocer la estructura de la verdad y la falsedad, solo fué necesario tener a alguien que tomara una desición (en este caso \( P \)) y proveer dos objetos que podemos distinguir entre sí (en este caso la manzana y la pera). Las desiciones de esta persona pueden ser los conceptos de falso y verdadero si nunca podemos conocer los valores booleanos.

Detrás del concepto de falso y verdadero, está el concepto de \emph{desición}, la codificación que se desarrolla está basada en este concepto y aparece en \cite[p.~133]{Barendregt:Bible}.

Supongamos que \( P \) es un término lambda el cual puede ser aplicado a una oración \( O \), al \( β \)-reducir \( (P\, O) \) se obtiene una decisión \( D \) la cual al ser aplicada a dos términos lambda \( M \) y \( N \) se \( β \)-reduce a \( M \) si la oración \( O \) es verdadera y a \( M \) si es falsa:

\[ P\, O \reduce{β} D, \]
\[ D\, M\, N \reduce{β} \begin{cases} M & \text{si \( O \) es verdadera}\\ N & \text{si \( O \) es falsa}\end{cases} .\]

Para fines prácticos no es necesario saber cómo es \( P \) ni \( O \), lo importante es que cuando \( O \) es cierta, \( D \) eligirá \( M \) y si \( O \) es falsa, eligirá \( N \). Por lo tanto, \( (P\, O) = D \) es un término lambda de la forma

\[ λx\, y.Q \]

Si \( D \) es una desición tomada por que \( O \) es verdadera, podemos asegurar que \( (D\, M\, N) = M \), por lo tanto:

\[ D \synteq λx\, y.x \]

Si \( D \) es una desición tomada por que \( O \) es falsa, podemos asegurar que \( (D\, M\, N) = N \), por lo tanto:

\[ D \synteq λx\, y.y \]

Teniendo los términos lambda que representan la desición de \( P \) ante una oración falsa y ante una oración verdadera, se puede considerar que estos términos representan el concepto de falso y verdadero.

\begin{defn}[Valores de verdad]
  \label{defn:valores-verdad}
  El concepto de falso y verdadero es codificado en el cálculo lambda como los términos \( \bs{T} \) y \( \bs{F} \) respectivamente.
  \begin{align*}
    \bs{T} &\synteq λx\, y.x & \bs{F} &\synteq λx\, y.y
  \end{align*}
\end{defn}

Utilizar \( \bs{T} \) y \( \bs{F} \) en términos lambda es similar a imitar a \( P \) y determinar cuando \( O \) es verdadera o falsa. Esto es debido a que se pueden plantear predicados que sean conceptualmente ilógicos, por ejemplo, si <<esPositivo>> se define de tal manera que sin importar en que valor sea evaluado siempre resulte en falso, los programas que se escriban no van a funcionar suponiendo que <<esPositivo>> calcula lo que debe de calcular, sin embargo lo importante de codificar el álgebra booleana es poder manipular los valores de falso y verdadero, no representar un término \( P \) que determine verdades absolutas.

\subsection{Expresiones booleanas}

Las expresiones booleanas se conforman de operaciones y valores de verdad. Las operaciones más básicas son la conjunción, la disyunción y la negación, también llamadas \( AND \), \( OR \), \( NOT \) y denotadas \( \land \), \( \lor \) y \( \lnot \) respectivamente.

La conjunción y la disyunción son operaciones binarias definidas en

\[ \{ \mathrm{falso},\ \mathrm{verdadero} \}^{2} \to \{ \mathrm{falso},\ \mathrm{verdadero} \} \]

y la negación es una operación unaria definida en

\[ \{ \mathrm{falso},\ \mathrm{verdadero} \} \to \{ \mathrm{falso},\ \mathrm{verdadero} \}. \]

Las tablas de verdad en el cuadro \ref{tab:and-or-not} establecen los resultados de estas tres operaciones para cada valor en su dominio.

\begin{table}[h!]
  \centering
  \small
  \begin{tabular}{|c|c|c|c|}
    \hline
    \( x \) & \( y \) & \( x \land y \) & \( x \lor y \) \\ [0.5ex]
    \hline\hline
    falso & falso & falso & falso \\
    falso & verdadero & falso & verdadero \\
    verdadero & falso & falso & verdadero \\
    verdadero & verdadero & verdadero & verdadero \\
    \hline
  \end{tabular}
  \hfill
  \begin{tabular}{|c|c|}
    \hline
    \( x \) & \( \lnot x \) \\ [0.5ex]
    \hline\hline
    falso & verdadero  \\
    verdadero & falso \\
    \hline
  \end{tabular}
  \caption{Tablas de verdad para \( \land \), \( \lor \) y \( \lnot \)}
  \label{tab:and-or-not}
\end{table}

En el álgebra booleana, las expresiones se escriben en notación de infijo, utilizan paréntesis para agrupar expresiones y cuando los paréntesis son omitidos la negación tiene mayor presedencia que la conjunción y la conjunción tiene mayor presedencia que la disyunción, por ejemplo:

\[ \mathrm{verdadero} \land \mathrm{falso} \lor \lnot \mathrm{falso} \]
\[ \lnot (\mathrm{falso} \lor \mathrm{falso}) \]
\[ \mathrm{verdadero} \land (\mathrm{falso} \lor \mathrm{falso}) \]

Esta notación es conveniente para escribir expresiones booleanas de manera concisa, pero es únicamente una conveniencia sintáctica del álgebra booleana. La codificación que se desarrolla de las operaciones seguirá las convenciones sintácticas del cálculo lambda, por ejemplo, suponiendo que \( \bs{\land} \), \( \bs{\lor} \), \( \bs{\lnot} \) son términos lambda, las expresiones mencionadas escribirían con notación de prefijo:

\[ \bs{\lor} (\bs{\land}\, \bs{T}\, \bs{F}) \bs{F} \]
\[ \bs{\lnot} (\bs{\lor}\, \bs{F}\, \bs{F}) \]
\[ \bs{\land}\, \bs{T} (\bs{\lor}\, \bs{F}\, \bs{F}) \]

Al igual que los valores de verdad, las operaciones básicas son codificadas como abstracciones del cálculo lambda. Hay varias metodologías para derivar términos lambda para las operaciones booleanas a partir de \( \bs{T} \) y \( \bs{F} \), en esta sección se abordarán dos:

\begin{itemize}
\item Combinando valores de verdad
\item Programando las operaciones
\end{itemize}

La primer metodología parte de la observación de que la codificación de falso y verdadero son abstracciones, por lo tanto, es posible \( β \)-reducirlas al aplicarlas a otros términos; se explora la clase de términos lambda en \( \{ \bs{T},\ \bs{F} \}^{+} \).

La segunda metodología presenta la construcción del operador condicional, a partir del cual se derivan las operaciones booleanas como si fueran programas de computadora.

\subsubsection{Combinaciones de valores de verdad}
\label{sec:combinacion-valores}

Una manera de obtener términos lambda a partir de \( \bs{F} \) y \( \bs{T} \) es \( β \)-reducir combinaciones de aplicaciones entre estos valores. En el cuadro \ref{tab:verdad-pares} se muestran los términos obtenidos al reducir combinaciones de dos valores de verdad.

\begin{table}[h!]
  \centering
  \begin{tabular}{|c||l|}
    \hline
    \( \bs{F}\, \bs{F} \) & \( (λx\, y.y)\bs{F} \reduce{β} λy.y \synteq \bs{I} \) \\
    \hline
    \( \bs{F}\, \bs{T} \) & \( (λx\, y.y)\bs{T} \reduce{β} λy.y \synteq \bs{I} \) \\
    \hline
    \( \bs{T}\, \bs{F} \) & \( (λx\, y.x)\bs{F} \reduce{β} λy.\bs{F} \synteq \bs{K}\, \bs{F} \) \\
    \hline
    \( \bs{T}\, \bs{T} \) & \( (λx\, y.x)\bs{T} \reduce{β} λy.\bs{T} \synteq \bs{K}\, \bs{T} \) \\
    \hline
  \end{tabular}
  \caption{Posibles combinaciones de valores de verdad por pares.}
  \label{tab:verdad-pares}
\end{table}

En las reducciones de \ref{tab:verdad-pares} se pueden observar cuatro términos, a partir de estos se puede descubrir la operación de negación:

\begin{itemize}
\item \( (\bs{F}\, \bs{F}) \) se reduce a la abstracción identidad, esto significa que para cualquier término \( M \in Λ \)
  \[ \bs{λ} \vdash (\bs{F}\, \bs{F}\, M) = M \]
\item Al igual que la primer reducción \( (\bs{F}\, \bs{T}) \) se reduce a \( \bs{I} \), por lo tanto se concluye que para cualesquiera términos \( M \in Λ \), \( N \in \{ \bs{F},\ \bs{T} \} \)
  \[ \bs{λ} \vdash (\bs{F}\, N\, M) = M \]
\item \( (\bs{T}\, \bs{F}) \) se reduce a la abstracción constante de \( \bs{F} \), esto significa que para cualquier término \( M \in Λ \)
  \[ \bs{λ} \vdash (\bs{T}\, \bs{F}\, M) = \bs{F} \]
\item Al igual que la tercer reducción \( (\bs{T}\, \bs{T}) \) se reduce a \( (\bs{K}\, \bs{T}) \), por lo tanto se concluye que para cualesquiera términos \( M \in Λ \), \( N \in \{ \bs{F},\ \bs{T} \} \)
  \[ \bs{λ} \vdash (\bs{T}\, N\, M) = N \]
\end{itemize}

Debido a las reducciones mostradas en el cuadro \ref{tab:verdad-pares} se puede analizar que a partir de un témino \( \bs{F} \), se puede obtener \( \bs{T} \) al reducir \( (\bs{F}\, N\, \bs{T}) \) y que a partir de un término \( \bs{T} \), se puede obtener \( \bs{F} \) al reducir \( (\bs{T}\, \bs{F}\, M) \). Considerando que \( N \synteq \bs{F} \) y \( M \synteq \bs{T} \) las reducciones serían:

\[ \bs{F}\, \bs{F}\, \bs{T} \reduce{β} \bs{T} \]
\[ \bs{T}\, \bs{F}\, \bs{T} \reduce{β} \bs{F} \]

Si se considera que \( P \in \{ \bs{F},\ \bs{T} \} \)

\[ P\, \bs{F}\, \bs{T} \reduce{β} \bs{\lnot}\, P \]

\begin{rem}[Sobre la \( β \)-reducción]
  En el tratamiento de la codificación del álgebra booleana en el cálculo lambda, cuando se \( β \)-reducen términos lambda que tienen como subtérminos valores que suponemos son \( \bs{F} \) o \( \bs{T} \) se extiende la teoría \( \bs{λ} \) con la siguiente ecuación:

  \begin{align*}
    P\, \bs{T}\, \bs{F} &= P && \text{si \( P \in \{ \bs{F},\ \bs{T} \} \)}
  \end{align*}
\end{rem}

\begin{defn}[Operación de negación]
  \label{defn:negacion}
  El término lambda \( \bs{\lnot} \synteq (λp.p\, \bs{F}\, \bs{T}) \) se reduce a \( \bs{T} \) cuando es aplicado a \( \bs{F} \) y viceversa

  \begin{align*}
    \bs{\lnot}\, \bs{F} &\synteq (λp.p\, \bs{F}\, \bs{T}) \bs{F} \\
                        &\contract{β} \bs{F}\, \bs{F}\, \bs{T} \\
                        &\reduce{β} \bs{T}
  \end{align*}
  \begin{align*}
    \bs{\lnot}\, \bs{T} &\synteq (λp.p\, \bs{F}\, \bs{T}) \bs{T} \\
                        &\contract{β} \bs{T}\, \bs{F}\, \bs{T} \\
                        &\reduce{β} \bs{F}
  \end{align*}
\end{defn}

Las reducciones del cuadro \ref{tab:verdad-pares} se pueden aplicar a \( \bs{F} \) y \( \bs{T} \) para obtener todas las posibles combinaciones de aplicaciones de valores de verdad de la forma \( ((P\, M) N) \), en el cuadro \ref{tab:verdad-tripletas} se muestran las reducciones de las nuevas aplicaciones.

\begin{table}[h!]
  \centering
  \begin{tabular}{|c||l|}
    \hline
    \( \bs{F}\, \bs{F}\, \bs{F} \) & \( \bs{I}\, \bs{F} \reduce{β} \bs{F} \) \\
    \hline
    \( \bs{F}\, \bs{F}\, \bs{T} \) & \( \bs{I}\, \bs{T} \reduce{β} \bs{T} \) \\
    \hline
    \( \bs{F}\, \bs{T}\, \bs{F} \) & \( \bs{I}\, \bs{F} \reduce{β} \bs{F} \) \\
    \hline
    \( \bs{F}\, \bs{T}\, \bs{T} \) & \( \bs{I}\, \bs{T} \reduce{β} \bs{T} \) \\
    \hline
    \( \bs{T}\, \bs{F}\, \bs{F} \) & \( \bs{K}\, \bs{F}\, \bs{F} \reduce{β} \bs{F} \) \\
    \hline
    \( \bs{T}\, \bs{F}\, \bs{T} \) & \( \bs{K}\, \bs{F}\, \bs{T} \reduce{β} \bs{F} \) \\
    \hline
    \( \bs{T}\, \bs{T}\, \bs{F} \) & \( \bs{K}\, \bs{T}\, \bs{F} \reduce{β} \bs{T} \) \\
    \hline
    \( \bs{T}\, \bs{T}\, \bs{T} \) & \( \bs{K}\, \bs{T}\, \bs{T} \reduce{β} \bs{T} \) \\
    \hline
  \end{tabular}
  \caption{Posibles combinaciones de valores de verdad con asociación a la izquierda.}
  \label{tab:verdad-tripletas}
\end{table}

Al observar el cuadro \ref{tab:verdad-tripletas}, se distinguen algúnos patrones en los resultados de las reducciones, por ejemplo, si \( P \) es un valor de verdad cualquiera, \( (P\, \bs{F}\, \bs{F}) \) se reduce a \( \bs{F} \) y \( (P\, \bs{T}\, \bs{T}) \) se reduce a \( \bs{T} \), las combinaciones mas interesantes se presentan en los renglones 2, 3, 6 y 7.

En búsqueda de las operaciones binarias de conjunción y disyunción se desarrollan tablas de verdad con las posibles combinaciones de dos términos \( P, Q \in \{ \bs{F},\ \bs{T} \} \). La cantidad de combinaciones de estos valores es \( 2 \times \binom 3 2 = 2 \times \frac{3!}{2!} = 6 \) y son \( (P\, Q\, \bs{F}) ,\ (P\, Q\, \bs{T}) ,\ (P\, \bs{F}\, Q) ,\ (P\, \bs{T}\, Q) ,\ (\bs{F}\, P\, Q) ,\ (\bs{T}\, P\, Q) \). Las tablas de verdad de estas combinaciones intercambiando las posiciones de \( P \) y \( Q \) serían las mismas ya que ambos términos toman los valores de falso y verdadero en las tablas de verdad. En el cuadro \ref{tab:verdad-pq} se muestran estas tablas.

\begin{table}[h!]
  \centering
  \begin{tabular}{|c|c||c|c|c|c|c|c|}
    \hline
    \( P \) & \( Q \) & \( P\, Q\, \bs{F} \) & \( P\, Q\, \bs{T} \) & \( P\, \bs{F}\, Q \) & \( P\, \bs{T}\, Q \) & \( \bs{F}\, P\, Q \) & \( \bs{T}\, P\, Q \) \\ [0.5ex]
    \hline
    \hline
    \( \bs{F} \) & \( \bs{F} \) & \( \bs{F} \) & \( \bs{T} \) & \( \bs{F} \) & \( \bs{F} \) & \( \bs{F} \) & \( \bs{F} \) \\
    \( \bs{F} \) & \( \bs{T} \) & \( \bs{F} \) & \( \bs{T} \) & \( \bs{T} \) & \( \bs{T} \) & \( \bs{T} \) & \( \bs{F} \) \\
    \( \bs{T} \) & \( \bs{F} \) & \( \bs{F} \) & \( \bs{F} \) & \( \bs{F} \) & \( \bs{T} \) & \( \bs{F} \) & \( \bs{T} \) \\
    \( \bs{T} \) & \( \bs{T} \) & \( \bs{T} \) & \( \bs{T} \) & \( \bs{F} \) & \( \bs{T} \) & \( \bs{T} \) & \( \bs{T} \) \\
    \hline
  \end{tabular}
  \caption{Tablas de verdad considerando dos variables \( P \) y \( Q \) en aplicaciones de tres términos}
  \label{tab:verdad-pq}
\end{table}

Las columnas de la combinación \( (P\, Q\, \bs{F}) \) y \( (P\, \bs{T}\, Q) \) del cuadro \ref{tab:verdad-pq} corresponden a la operación de conjunción y disyunción respectivamente, como aparecen en el cuadro \ref{tab:and-or-not}. Las otras combinaciones corresponden a operaciones no básicas del álgebra booleana: \( (P\, Q\, \bs{T}) \) es la implicación material; \( (P\, \bs{F}\, Q) \) es la no implicación inversa; \( (\bs{F}\, P\, Q) \) es la proyección de \( Q \); y \( (\bs{T}\, P\, Q) \) es la proyección de \( P \).

Ya que  \( \bs{λ} \vdash (P\, Q\, \bs{F}) = (\bs{\land}\, P\, Q) \) y \( \bs{λ} \vdash (P\, \bs{T}\, Q) = (\bs{\lor}\, P\, Q) \), se construyen los términos \( \bs{\land} \) y \( \bs{\lor} \) abstrayendo a \( P \) y \( Q \) de las igualdades.

\begin{defn}[Operación de conjunción]
  \label{defn:conjuncion}
  El término lambda que representa la conjunción es

  \[ \bs{\land} \synteq λp\, q.p\, q\, \bs{F} \]

  y cumple las siguientes propiedades de \( β \)-reducción al ser aplicada a valores de verdad:

  \begin{align*}
    \bs{\land}\, \bs{F}\, \bs{F} &\synteq (λp\, q.p\, q\, \bs{F}) \bs{F}\, \bs{F} \\
                                 &\reduce{β} \bs{F}\, \bs{F}\, \bs{F} \\
                                 &\reduce{β} \bs{F}
  \end{align*}

  \begin{align*}
    \bs{\land}\, \bs{F}\, \bs{T} &\synteq (λp\, q.p\, q\, \bs{F}) \bs{F}\, \bs{T} \\
                                 &\reduce{β} \bs{F}\, \bs{T}\, \bs{F} \\
                                 &\reduce{β} \bs{F}
  \end{align*}

  \begin{align*}
    \bs{\land}\, \bs{T}\, \bs{F} &\synteq (λp\, q.p\, q\, \bs{F}) \bs{T}\, \bs{F} \\
                                 &\reduce{β} \bs{T}\, \bs{F}\, \bs{F} \\
                                 &\reduce{β} \bs{F}
  \end{align*}

  \begin{align*}
    \bs{\land}\, \bs{T}\, \bs{T} &\synteq (λp\, q.p\, q\, \bs{F}) \bs{T}\, \bs{T} \\
                                 &\reduce{β} \bs{T}\, \bs{T}\, \bs{F} \\
                                 &\reduce{β} \bs{T}
  \end{align*}
\end{defn}

\begin{defn}[Operación de disyunción]
  \label{defn:disyuncion}
  El término lambda que representa la disyunción es

  \[ \bs{\lor} \synteq λp\, q.p\, \bs{T}\, q \]

  y cumple las siguientes propiedades de \( β \)-reducción al ser aplicada a valores de verdad:

  \begin{align*}
    \bs{\lor}\, \bs{F}\, \bs{F} &\synteq (λp\, q.p\, \bs{T}\, q) \bs{F}\, \bs{F} \\
                                &\reduce{β} \bs{F}\, \bs{T}\, \bs{F} \\
                                &\reduce{β} \bs{F}
  \end{align*}

  \begin{align*}
    \bs{\lor}\, \bs{F}\, \bs{T} &\synteq (λp\, q.p\, \bs{T}\, q) \bs{F}\, \bs{T} \\
                                &\reduce{β} \bs{F}\, \bs{T}\, \bs{T} \\
                                &\reduce{β} \bs{T}
  \end{align*}

  \begin{align*}
    \bs{\lor}\, \bs{T}\, \bs{F} &\synteq (λp\, q.p\, \bs{T}\, q) \bs{T}\, \bs{F} \\
                                &\reduce{β} \bs{T}\, \bs{T}\, \bs{F} \\
                                &\reduce{β} \bs{T}
  \end{align*}

  \begin{align*}
    \bs{\lor}\, \bs{T}\, \bs{T} &\synteq (λp\, q.p\, \bs{T}\, q) \bs{T}\, \bs{T} \\
                                &\reduce{β} \bs{T}\, \bs{T}\, \bs{T} \\
                                &\reduce{β} \bs{T}
  \end{align*}
\end{defn}

Esta metodología para encontrar operaciones del álgebra booleana, aplicando los términos codificados de los valores de verdad, es tediosa pero hasta cierto grado efectiva. Como en los casos de las operaciones no básicas mostradas en el cuadro \ref{tab:verdad-pq}, operaciones del álgebra booleana pueden ser ``descubiertas'' y no construídas. Ya que la negación, la conjunción y la disyunción fueron descubiertas con este método, cualquier operación booleana eventualmente será encontrada como combinación de valores de verdad. Sin embargo, descubrir la codificación de una operación booleana complicada utilizando este método es un proceso muy tardado.

\subsubsection{Programación de operaciones booleanas}
\label{sec:programacion-operaciones}

Otra metodología que permite construír las operaciones booleanas como términos lambda es la de partir de un algorítmo que las describa. Usualmente las operaciones booleanas no son definidas como procedimientos, si no como operaciones primitivas del lenguaje utilizado para describirlos.

Consideremos dos términos \( M \) y \( N \). Ya que \( (\bs{T}\, M\, N) \reduce{β} M \) y \( (\bs{F}\, M\, N) \reduce{β} N \), si \( M \reduce{β} M' \) y \( N \reduce{β} N' \), entonces

\[ \bs{T}\, M\, N \reduce{β} M' \]

\[ \bs{F}\, M\, N \reduce{β} N' \]

Es decir, si \( P \in \{ \bs{F},\ \bs{T} \} \):

\[ P\, M\, N \reduce{β} \begin{cases} M' & P \synteq \bs{T} \\ N' & P \synteq \bs{F} \end{cases} \]

Esta aplicación de un valor de verdad a dos términos lambda cualquiera permite capturar el concepto de una expresión o sentencia condicional, usualmente llamada en los lenguajes de programación como sentencia \texttt{if-then-else}.

\begin{defn}[Expresión condicional]
  \label{defn:condicional}
  El término lambda que representa a la expresión condicional es

  \[ \bs{\prec} \synteq λp\, m\, n.p\, m\, n \]

  Y si \( P \) es un valor de verdad, entonces

  \begin{align*}
    \bs{\prec}\, P\, M\, N &\synteq (λp\, m\, n.p\, m\, n)P\, M\, N \\
                           &\reduce{β} P\, M\, N
  \end{align*}

  Un programa de la forma

  \begin{algorithmic}
    \IF{\( P \)}
    \STATE \( M \)
    \ELSE
    \STATE \( M \)
    \ENDIF
  \end{algorithmic}

  Puede ser traducido a \( (\bs{\prec}\, P\, M\, N) \)
\end{defn}

Consideremos la siguiente definición en pseudocódigo de la operación de negación:

\begin{algorithm}
  \caption{Negación de \( p \)}
  \label{alg:negacion}
  \begin{algorithmic}
    \REQUIRE \( p \in \{ \mathrm{falso},\ \mathrm{verdadero} \} \)
    \ENSURE \( \lnot p \)
    \IF{\( p \)}
    \RETURN falso
    \ELSE
    \RETURN verdadero
    \ENDIF
  \end{algorithmic}
\end{algorithm}

El pseudocódigo se traduce al cálculo lambda como

\[ \bs{\lnot} \synteq λp.\bs{\prec}\, p\, \bs{F}\, \bs{T} \]

El cuerpo de la abstracción puede ser \( β \)-reducido para obtener el término de la definición \ref{defn:negacion}

\begin{align*}
  λp.\bs{\prec}\, p\, \bs{F}\, \bs{T} &\synteq λp.(λp\, m\, n.p\, m\, n) p\, \bs{F}\, \bs{T} \\
                                      &\reduce{β} λp.p\, \bs{F}\, \bs{T}
\end{align*}

Para la operación de conjunción, se considera el siguiente pseudocódigo:

\begin{algorithm}
  \caption{Conjunción de \( p_{1} \) y \( p_{2} \)}
  \label{alg:conjuncion}
  \begin{algorithmic}
    \REQUIRE \( p_{1}, p_{2} \in \{ \mathrm{falso},\ \mathrm{verdadero} \} \)
    \ENSURE \( p_{1} \land p_{2} \)
    \IF{\( p_{1} \)}
    \IF{\( p_{2} \)}
    \RETURN verdadero
    \ELSE
    \RETURN false
    \ENDIF
    \ELSE
    \RETURN falso
    \ENDIF
  \end{algorithmic}
\end{algorithm}

Traducido al cálculo lambda como

\[ \bs{\land} \synteq λp_{1}\, p_{2}.\bs{\prec}\, p_{1} (\bs{\prec}\, p_{2}\, \bs{T}\, \bs{F}) \bs{F} \]

Al \( β \)-reducir el cuerpo de la abstracción se obtiene el término de la definición \ref{defn:conjuncion}

\begin{align*}
  λp_{1}\, p_{2}.\bs{\prec}\, p_{1} (\bs{\prec}\, p_{2}\, \bs{T}\, \bs{F}) \bs{F}
  &\synteq λp_{1}\, p_{2}.(λp\, m\, n.p\, m\, n) p_{1} ((λp\, m\, n.p\, m\, n) p_{2}\, \bs{T}\, \bs{F}) \bs{F} \\
  &\reduce{β} λp_{1}\, p_{2}.p_{1} ((λp\, m\, n.p\, m\, n) p_{2}\, \bs{T}\, \bs{F}) \bs{F} \\
  &\reduce{β} λp_{1}\, p_{2}.p_{1} (p_{2}\, \bs{T}\, \bs{F}) \bs{F} \\
  &=_{\bs{λ}} λp_{1}\, p_{2}.p_{1}\, p_{2}\, \bs{F}
\end{align*}

De igual manera, considerando el siguiente pseudocódigo de la operación de disyunción:

\begin{algorithm}
  \caption{Disyunción de \( p_{1} \) y \( p_{2} \)}
  \label{alg:disyuncion}
  \begin{algorithmic}
    \REQUIRE \( p_{1}, p_{2} \in \{ \mathrm{falso},\ \mathrm{verdadero} \} \)
    \ENSURE \( p_{1} \lor p_{2} \)
    \IF{\( p_{1} \)}
    \RETURN verdadero
    \ELSE
    \IF{\( p_{2} \)}
    \RETURN verdadero
    \ELSE
    \RETURN falso
    \ENDIF
    \ENDIF
  \end{algorithmic}
\end{algorithm}

Se traduce al cálculo lambda como

\[ \bs{\lor} \synteq λp_{1}\, p_{2}.\bs{\prec}\, p_{1}\, \bs{T} (\bs{\prec}\, p_{2}\, \bs{T}\, \bs{F}) \]

Y al \( β \)-reducir el cuerpo de la abstracción se obtiene el término de la definición \ref{defn:disyuncion}

\begin{align*}
  λp_{1}\, p_{2}.\bs{\prec}\, p_{1}\, \bs{T} (\bs{\prec}\, p_{2}\, \bs{T}\, \bs{F})
  &\synteq λp_{1}\, p_{2}.(λp\, m\, n.p\, m\, n) p_{1}\, \bs{T} ((λp\, m\, n.p\, m\, n) p_{2}\, \bs{T}\, \bs{F}) \\
  &\reduce{β} λp_{1}\, p_{2}.p_{1}\, \bs{T} ((λp\, m\, n.p\, m\, n) p_{2}\, \bs{T}\, \bs{F}) \\
  &\reduce{β} λp_{1}\, p_{2}.p_{1}\, \bs{T} (p_{2}\, \bs{T}\, \bs{F}) \\
  &=_{\bs{λ}} λp_{1}\, p_{2}.p_{1}\, \bs{T}\, p_{2}
\end{align*}

Utilizando esta técnica, se puede obtener el término lambda para una operación a partir del pseudocódigo basado en valores de verdad y la sentencia \verb!if-then-else!. Teniendo estos resultados resulta natural, generalizar el pseudocódigo para construír un término lambda que a partir de la tabla de verdad de una operación booleana binaria, resulte en la abstracción que codifica la operación.


\begin{defn}[Traducción de operaciones booleanas binarias]
  \label{defn:op-bool-bin-lambda}
  Sea \( \bs{\odot} \) una operación booleana binaria con la siguiente tabla de verdad

  \begin{center}
    \begin{tabular}{|c|c||c|}
      \hline
      \( P \) & \( Q \) & \( P \bs{\odot} Q \) \\ [0.5ex]
      \hline\hline
      \( \bs{F} \) & \( \bs{F} \) & \( x_{1} \) \\
      \hline
      \( \bs{F} \) & \( \bs{T} \) & \( x_{2} \) \\
      \hline
      \( \bs{T} \) & \( \bs{F} \) & \( x_{3} \) \\
      \hline
      \( \bs{T} \) & \( \bs{T} \) & \( x_{4} \) \\
      \hline
    \end{tabular}
  \end{center}

  El procedimiento generalizado es

  \begin{algorithm}
    \caption{Operación booleana \( \odot \) dado \( x_{1} \), \( x_{2} \), \( x_{3} \), \( x_{3} \)}
    \label{alg:bool-bin-gen}
    \begin{algorithmic}
      \REQUIRE \( p_{1}, p_{2} \in \{ \mathrm{falso},\ \mathrm{verdadero} \} \)
      \ENSURE Valor \( x_{i} \) de la tabla de verdad
      \IF{\( p_{1} \)}
      \IF{\( p_{2} \)}
      \RETURN \( x_{4} \)
      \ELSE
      \RETURN \( x_{3} \)
      \ENDIF
      \ELSE
      \IF{\( p_{2} \)}
      \RETURN \( x_{2} \)
      \ELSE
      \RETURN \( x_{1} \)
      \ENDIF
      \ENDIF
    \end{algorithmic}
  \end{algorithm}

  Y la traducción al cálculo lambda es
  \[ λx_{1}\, x_{2}\, x_{3}\, x_{4}.(λp_{1}\, p_{2}.(\bs{\prec}\, p_{1} (\bs{\prec}\, p_{2}\, x_{4}\, x_{3}) (\bs{\prec}\, p_{2}\, x_{2}\, x_{1}))) \]
  
\end{defn}

\begin{exmp}[Operaciones \emph{NAND} y \emph{NOR}]
  \label{ejmp:nand-nor}
  Estas operaciones booleanas binarias conforman los conjuntos unitarios \( \{ \mathrm{NAND} \} \) y \( \{ \mathrm{NOR} \} \) los cuales son conjuntos funcionalmene completos, es decir, únicamente con la operación NAND se puede emular cualquier operación booleana y únicamente con la operación NOR se puede emular cualquier operación booleana.
  
  La operación \emph{NAND} se denota \( P \uparrow Q \) y tiene la siguiente tabla de verdad

  \begin{center}
    \begin{tabular}{|c|c||c|}
      \hline
      \( P \) & \( Q \) & \( P \uparrow Q \) \\ [0.5ex]
      \hline\hline
      \( \bs{F} \) & \( \bs{F} \) & \( \bs{T} \) \\
      \hline
      \( \bs{F} \) & \( \bs{T} \) & \( \bs{T} \) \\
      \hline
      \( \bs{T} \) & \( \bs{F} \) & \( \bs{T} \) \\
      \hline
      \( \bs{T} \) & \( \bs{T} \) & \( \bs{F} \) \\
      \hline
    \end{tabular}
  \end{center}

  Con el proceso de traducción mostrado en la definición \ref{defn:op-bool-bin-lambda}, el término lambda \( \bs{\uparrow} \) que codifica la operación NAND sería
  
  \begin{align*}
    \bs{\uparrow}
    &\synteq λp_{1}\, p_{2}. \bs{\prec}\, p_{1} (\bs{\prec}\, p_{2}\, \bs{F}\, \bs{T}) (\bs{\prec}\, p_{2}\, \bs{T}\, \bs{T}) \\
    &\reduce{β} λp_{1}\, p_{2}.p_{1} (p_{2}\, \bs{F}\, \bs{T}) \bs{T}
  \end{align*}

  La operación \emph{NOR} se denota \( P \downarrow Q \) y tiene la siguiente tabla de verdad

  \begin{center}
    \begin{tabular}{|c|c||c|}
      \hline
      \( P \) & \( Q \) & \( P \downarrow Q \) \\ [0.5ex]
      \hline\hline
      \( \bs{F} \) & \( \bs{F} \) & \( \bs{T} \) \\
      \hline
      \( \bs{F} \) & \( \bs{T} \) & \( \bs{F} \) \\
      \hline
      \( \bs{T} \) & \( \bs{F} \) & \( \bs{F} \) \\
      \hline
      \( \bs{T} \) & \( \bs{T} \) & \( \bs{F} \) \\
      \hline
    \end{tabular}
  \end{center}

  Usando el mismo proceso de traducción que con la operación NAND, se obtiene

  \begin{align*}
    \bs{\downarrow}
    &\synteq λp_{1}\, p_{2}. \bs{\prec}\, p_{1} (\bs{\prec}\, p_{2}\, \bs{F}\, \bs{F}) (\bs{\prec}\, p_{2}\, \bs{F}\, \bs{T}) \\
    &\reduce{β} λp_{1}\, p_{2}.p_{1}\, \bs{F} (p_{2}\, \bs{F}\, \bs{T})
  \end{align*}

\end{exmp}

Cuando se generaliza el método de traducción de \ref{defn:op-bool-bin-lambda} a operaciones booleanas \( n \)-árias, se obtiene un término bosquejado de la siguiente manera

\begin{center}
  \begin{tikzpicture}[level/.style={sibling distance=100mm/#1, level distance=10mm}]
    \node (args1) {\( λx_{1}\, ...\, x_{2^{n}} \)}
    child {
      node (args2) {\( λp_{1}\, ...\, p_{n} \)}
      child {
        node (p1) {\( \bs{\prec}\, p_{1} \)}
        child {
          node (p2a) {\( \bs{\prec}\, p_{2} \)}
          child {
            node (dots1) {\( ... \)}
            child {
              node (pna) {\( \bs{\prec}\, p_{n} \)}
              child {
                node (x2n) {\( x_{2^{n}} \)}
              }
              child {
                node (x2n1) {\( x_{2^{n}-1} \)}
              }
            }
            child {
              node (dots3) {\( ... \)}
            }
          }
          child {
            node (dots2) {\( ... \)}
          }
        }
        child {
          node (p2b) {\( \bs{\prec}\, p_{2} \)}
          child {
            node (dots4) {\( ... \)}
          }
          child {
            node (dots5) {\( ... \)}
            child {
              node (dots6) {\( ... \)}
            }
            child {
              node (pnb) {\( \bs{\prec}\, p_{n} \)}
              child {
                node (x2) {\( x_{2} \)}
              }
              child {
                node (x1) {\( x_{1} \)}
              }
            }
          }
        }
      }
    };
  \end{tikzpicture}
\end{center}

\subsection{Extensiones al álgebra booleana}
\label{sec:boolean-extensiones}

Conociendo el proceso de codificación del álgebra booleana en el cálculo lambda, resulta simple adaptar la codificación.

Consideremos el caso en donde, además de tener los valores de falso y verdadero, se desea incorporar un valor ``desconocido'' utilizado para representar un valor que no es ni falso, ni verdadero. La interpretación de estos valores es similar a \ref{defn:valores-verdad}, pero en lugar de decidir sobre dos términos, se decide sobre tres.

\begin{defn}[Valores de álgebra trivalente]
  La codificación en términos lambda de los valores de ésta álgebra trivalente son

  \begin{align*}
    \bs{T} &\synteq λx\, y\, z.x \\
    \bs{F} &\synteq λx\, y\, z.y \\
    \bs{U} &\synteq λx\, y\, z.z 
  \end{align*}
\end{defn}

Al igual que en la codificación bivalente, se puede codificar un término \( \bs{\prec_{3}} \), similar a \( \bs{\prec} \) de la definición \ref{defn:condicional} pero con tres ramificaciones

\begin{defn}[Condicional trivalente]
  \[ \bs{\prec_{3}} \synteq λp\, m\, n\, o.p\, m\, n\, o \]

  De tal manera que, si \( P \in \{ \bs{T},\ \bs{F},\ \bs{U} \} \)

  \[ (\bs{\prec_{3}}\, P\, M\, N\, O) \reduce{β} \begin{cases} M & P \synteq \bs{T}; \\ N & P \synteq \bs{F}; \\ O & P \synteq \bs{U}. \end{cases} \]
\end{defn}

Sea \( \odot \) una operación trivalente binaria con la siguiente tabla de valores

\begin{center}
  \begin{tabular}{|c|c||c|}
    \hline
    \( P \) & \( Q \) & \( P \odot Q \) \\ [0.5ex] \hline\hline
    \( \bs{T} \) & \( \bs{T} \) & \( x_{1} \) \\ \hline
    \( \bs{T} \) & \( \bs{F} \) & \( x_{2} \) \\ \hline
    \( \bs{T} \) & \( \bs{U} \) & \( x_{3} \) \\ \hline
    \( \bs{F} \) & \( \bs{T} \) & \( x_{4} \) \\ \hline
    \( \bs{F} \) & \( \bs{F} \) & \( x_{5} \) \\ \hline
    \( \bs{F} \) & \( \bs{U} \) & \( x_{6} \) \\ \hline
    \( \bs{U} \) & \( \bs{T} \) & \( x_{7} \) \\ \hline
    \( \bs{U} \) & \( \bs{F} \) & \( x_{8} \) \\ \hline
    \( \bs{U} \) & \( \bs{U} \) & \( x_{9} \) \\ \hline
  \end{tabular}
\end{center}

El procedimiento en pseudocódigo que la describe es:

\begin{algorithm}
  \caption{Operación booleana \( \odot \) dado \( x_{1} \), \( x_{2} \), ... , \( x_{9} \)}
  \label{alg:op-bin-gen-2}
  \begin{algorithmic}
    \REQUIRE \( p_{1}, p_{2} \in \{ \mathrm{verdadero},\ \mathrm{falso},\ \mathrm{desconocido} \} \)
    \ENSURE Valor \( x_{i} \) de la tabla de verdad
    \IF{\( p_{1} = \mathrm{verdadero} \)}
    \IF{\( p_{2} = \mathrm{verdadero} \)}
    \RETURN \( x_{1} \)
    \ELSIF{\( p_{2} = \mathrm{falso} \)}
    \RETURN \( x_{2} \)
    \ELSIF{\( p_{2} = \mathrm{desconocido} \)}
    \RETURN \( x_{3} \)
    \ENDIF
    \ELSIF{\( p_{1} = \mathrm{falso} \)}
    \IF{\( p_{2} = \mathrm{verdadero} \)}
    \RETURN \( x_{4} \)
    \ELSIF{\( p_{2} = \mathrm{falso} \)}
    \RETURN \( x_{5} \)
    \ELSIF{\( p_{2} = \mathrm{desconocido} \)}
    \RETURN \( x_{6} \)
    \ENDIF
    \ELSIF{\( p_{1} = \mathrm{desconocido} \)}
    \IF{\( p_{2} = \mathrm{verdadero} \)}
    \RETURN \( x_{7} \)
    \ELSIF{\( p_{2} = \mathrm{falso} \)}
    \RETURN \( x_{8} \)
    \ELSIF{\( p_{2} = \mathrm{desconocido} \)}
    \RETURN \( x_{9} \)
    \ENDIF
    \ENDIF
  \end{algorithmic}
\end{algorithm}

Traducido al cálculo lambda como
\[ λx_{1}\, x_{2}\, x_{3}\, x_{4}\, x_{5}\, x_{6}\, x_{7}\, x_{8}\, x_{9}.(λp_{1}\, p_{2}.(\bs{\prec_{3}}\, p_{1}\, R_{1}\, R_{2}\, R_{3})) \]

Donde

\begin{align*}
  R_{1} &\synteq (\bs{\prec_{3}}\, p_{2}\, x_{1}\, x_{2}\, x_{3}) \\
  R_{2} &\synteq (\bs{\prec_{3}}\,  p_{2}\, x_{4}\, x_{5}\, x_{6}) \\
  R_{3} &\synteq (\bs{\prec_{3}}\, p_{2}\, x_{7}\, x_{8}\, x_{9})
\end{align*}

\subsection{Lógica en el cálculo lambda}
\label{sec:logica-lambda}

En esta sección se abordó la codificación de valores de verdad y operaciones como la conjunción, disyunción y negación. Usualmente en las ciencias de la computación y las matemáticas, estos objetos se abordan desde la perspectiva algebraica y desde la perspectiva lógica.

En el cálculo lambda se distinguen las dos perspectivas por el lenguaje en el que se manejan los objetos, en el caso del álgebra booleana, los valores de verdad y las operaciones booleanas se codifican como términos lambda y pueden ser combinados con otros términos lambda que no forman parte del álgebra booleana. Por otra parte, la lógica proposicional estudia proposiciones, las cuales son enunciados matemáticos a los cuales se les puede atribuír el valor de falso o verdadero y que, a partir de conectivos lógicos como \( \lnot \), \( \land \) y \( \lor \), se infieren verdades sobre los enunciados.

El cálculo lambda se puede extender de tal manera que nos permita inferir verdades sobre sus términos, en esta subsección se abordan los cálculos lambda aumentados con nociones \emph{ilativas}, denotados \( \mathit{i}\bs{λ} \). El tratamiento de esta extensión está basado en el apéndice B ``Lógica combinatoria ilativa'' de \cite[pp.~573--576]{Barendregt:Bible}.

\begin{defn}[Términos \( \mathit{i}\bs{λ} \)]
  \label{defn:ilativo-terminos}
  Los términos de la teoría \( \mathit{i}\bs{λ} \), denotados \( \mathit{i}Λ \) se definen sobre el alfabeto de \( Λ \) extendido con un conjunto \( C \) de \emph{constantes lógicas}.

  \begin{align*}
    M \in Λ &\implies M \in \mathit{i}Λ \\
    c \in C &\implies c \in \mathit{i}Λ \\
    M, N \in \mathit{i}Λ &\implies (M\, N) \in \mathit{i}Λ
  \end{align*}
\end{defn}

\begin{defn}[Fórmulas en \( \mathit{i}\bs{λ} \)]
  \label{defn:ilativo-formulas}
  Las fórmulas de la teoría \( \mathit{i}\bs{λ} \) se definen de la siguiente manera
  
  \begin{itemize}
  \item Si \( M, N \in \mathit{i}Λ \), entonces \( M = N \) es una fórmula.
  \item Si \( M \in \mathit{i}Λ \), entonces \( M \) es una fórmula.
  \end{itemize}

  En el estudio de teorías ilativas, la interpretación de \( \mathit{i}\bs{λ} \vdash M \) y \( \mathit{i}\bs{λ} \vdash M = N \) es ``La fórmula \( M \) es verdadera'' y ``La fórmula \( M = N \) es verdadera'' respectivamente.
\end{defn}

\paragraph{Revisar} La sección será muy extensa si desarrollo todos los pendientes planteados, sería conveniente no plantear la paradoja de Kleene-Rosser y considerar solo la de Curry, mostrar que cualquier término puede ser inferido, omitir la definibilidad de las constantes en términos de \( \bs{Q} \) y \( \bs{Ξ} \) y mencionar la compensación entre expresibilidad e inconsistencia, enlazando las ideas de computabilidad y teoría de tipos.

\subsubsection{Teoría \( \mathit{i}\bs{λ}_{KR} \)}

Constantes \( C = \{ \bs{N} \} \) con la interpretación \( \lnot\, M \) es \( (\bs{N}\, M) \)

Paradoja de Kleene-Rosser

\[ X \synteq λx.\bs{N} (x\, x) \]

\[ X\, X = (λx.\bs{N} (x\, x)) X = \bs{N} (X\, X) \]

Se puede derivar que una fórmula \( X\, X = \lnot (X\, X) \), es decir, en \( \mathit{i}\bs{λ}_{KR} \) se pueden derivar contradicciones.

\subsubsection{Teoría \( \mathit{i}\bs{λ}_{0} \)}

Constantes \( C = \{ \bs{F},\ \bs{Q},\ \bs{E},\ \bs{Ξ},\ \bs{Π},\ \bs{P} \} \) con las siguientes interpretaciones

\begin{itemize}
\item \( M \in N \) es \( N\, M \)
\item \( M \implies N \) es \( \bs{P}\, M\, N \)
\item \( M \subseteq N \) es \( \bs{Ξ}\, M\, N \)
\item \( N^{M} \) es \( \bs{F}\, M\, N \)
\item \( \forall x\ M \) es \( \bs{Ξ} (λx.M) \)
\end{itemize}

\subsubsection*{Pendientes}

\begin{itemize}
\item Definibilidad de \( \bs{E} \), \( \bs{F} \), \( \bs{P} \) y \( \bs{Π} \) a partir de \( \bs{Q} \), \( \bs{Ξ} \).
\item Inconsistencia de \( \mathit{i}\bs{λ}_{0} \) por la paradoja de Curry ``Una teoría lambda ilativa es inconsistente si cada \( M \) puede ser derivada'' (la paradoja de Kleene-Rosser es una consecuencia de la paradoja de Curry).
\item Mencionar la técnica utilizada por Church para ``escapar'' de la paradoja de Curry y presentar el ``tradeoff'' de tener un sistema suficientemente poderoso: Equivalencia \( \bs{λ} \) y máquina de Turing \emph{vs.} separar la noción ilativa de la abstracción.
\end{itemize}

\section{Aritmética}
\label{sec:aritmetica}

La aritmética es una de las ramas mas antiguas de las matemáticas. Consiste en el estudio de los números y de las operaciones elementales como la suma y la multiplicación. El manejo de expresiones aritméticas es ubicuo en la vida cotidiana y es una parte fundamental de la formación básica en matemáticas.

En el cálculo lambda, los números naturales no son términos lambda, sin embargo, desde el metalenguaje se pueden manejan números naturales y expresiones aritméticas como por ejemplo en la definición de longitud \ref{defn:longitud}. Al igual que el álgebra boolena, las expresiones aritméticas pueden ser codificadas como términos lambda.

En los lenguajes de programación los números naturales y las operaciones aritméticas son de los objetos más utilizados para expresar la mayoría de los cómputos. Virtualmente todo programa no trivial ejecutable en una computadora hace uso de números y operaciones sobre ellos. Como se menciona al inicio de la sección anterior, el concepto de número es codificado usualmente como una secuencia de bits de longitud fija y las operaciones aritméticas terminan siendo traducidas a instrucciones ejecutadas por la unidad aritmética lógica de la computadora.

En esta sección se plantea la codificación de expresiones aritméticas en el lenguaje del cálculo lambda de manera similar a como se abordó en \ref{sec:algebra-booleana}, también se aborda la representación de la noción de iteración y aglunos mecanismos que nos permiten abstaer el cómputo de las operaciones elementales.

\subsection{Numerales de Church}
\label{sec:numerales}

Los números naturales son los objetos más básicos para representar expresiones aritméticas. En este trabajo se considera que \( \mathbb{N} \) contiene el número 0, por lo que el conjunto de números naturales es

\[ \mathbb{N} = \left\{ 0,\ 1,\ 2,\ 3,\ ... \right\} \]

En la codificación del álgebra booleana se presenta la representación de valores de verdad como una desición entre dos valores dados. En \ref{sec:boolean-extensiones} se extende la representación de la desición a tres valores y siguiendo el mismo procedimiento se puede extender a \( n \) valores. Esta representación no es útil al tratar con los números naturales ya que no se tiene un conjunto finito de valores, sin embargo, si se establece una cota superior para la cantidad de números naturales representables es posible utilizar esta codificación.

Por cuestiones de eficiencia, en las computadoras se limita la cantidad de naturales representables a valores entre 0 y \( 2^{64}-1 \), por lo tanto, es posible representar números en este rango como abstracciones de \( 2^{64} \) variables enlazadas. Utilizar esta codificación no es conveniente ya que las operaciones deberán ser definidas para cada posible combinación de naturales.

La codificación más utilizada para números naturales es la de \emph{numerales de Church}, esta codificación fue propuesta por Alonzo Church en 1941 \cite[p.~28]{Church:LambdaConversion}.

\begin{defn}[Numerales de Church]
  \label{defn:numerales-church}
  El numeral de Church, denotado \( \cn{n} \), asociado al número natural \( n \) es

  \begin{equation}
    \label{eq:numeral}
    \cn{n} \synteq (λx\, y.x^{n}\, y)
  \end{equation}
\end{defn}

\begin{exmp} Los primeros 5 numerales son:
  \begin{align*}
    \cn{0} &\synteq λx\, y.x^{0}\, y \synteq λx\, y.y \\
    \cn{1} &\synteq λx\, y.x^{1}\, y \synteq λx\, y.x\, y \\
    \cn{2} &\synteq λx\, y.x^{2}\, y \synteq λx\, y.x(x\, y) \\
    \cn{3} &\synteq λx\, y.x^{3}\, y \synteq λx\, y.x(x(x\, y)) \\
    \cn{4} &\synteq λx\, y.x^{4}\, y \synteq λx\, y.x(x(x(x\, y)))
  \end{align*}
\end{exmp}

Al manipular numerales de Church, se debe tener cuidado en la manera en que se reducen aplicaciones con otros términos. Con la codificación de valores de verdad es relativamente sencillo experimentar con la manera en la que \( \bs{T} \) y \( \bs{F} \) se combinan y corroborar manualmente que una combinación se reduce a otra. Sin embargo, al aplicar un numeral de Church \( \cn{n} \) a un término cualquiera \( M \), el término resultante de la contracción de dicha aplicación tendría aproximadamente una longitud de \( \| M \|\times n \), lo cual resulta inconveniente de escribir en cada paso de una reducción.

Para facilitar el desarrollo de reducciones se muestran algunas propiedades de los numerales de Church y reducciones que involucran términos de la forma \( (P^{n}\, Q) \).

Consideremos un numeral \( \cn{n} \) y términos cualesquiera \( P \) y \( Q \).

\begin{equation}
  \label{eq:numeral:P}
  \cn{n}\, P \contract{β} λx.P^{n}\, x
\end{equation}

\begin{equation}
  \label{eq:numeral:PQ}
  \cn{n}\, P\, Q \contract{β} (λx.P^{n}\, x) Q \contract{β} P^{n}\, Q
\end{equation}

Sea \( \cn{n} \) un numeral de Church, \( P \), \( Q \) y \( R \) términos cualesquiera y \( m \) un número natural. Se aborda la reducción de las aplicaciones \( ((\cn{n}\, P\, Q)^{m} R) \), \( ((\cn{n}\, P)^{m} Q) \) y \( (\cn{n}^{m}\, P) \), las cuales corresponden a la aplicación \( (F^{m}\, X) \) donde \( F \) es el término de las ecuaciones \eqref{eq:numeral:PQ}, \eqref{eq:numeral:P} y \eqref{eq:numeral}.

\begin{align}
  \label{eq:numeral:PQm}
  (\cn{n}\, P\, Q)^{m} R &\reduce{β} (P^{n}\, Q)^{m} R &\text{Por \eqref{eq:numeral:PQ}}
\end{align}

Ya que no se hicieron suposiciones adicionales sobre \( P \) y \( Q \) no podemos asegurar que el término final de la reducción \eqref{eq:numeral:PQm} pueda ser reducido más.

\begin{align}
  \label{eq:numeral:PmQ}
  (\cn{n}\, P)^{m} Q \synteq &(\cn{n}\, P)^{m-1} (\cn{n}\, P\, Q) &\text{Por \eqref{eq:abuso:F}} \\
                 \reduce{β} &(\cn{n}\, P)^{m-1} (P^{n}\, Q) &\text{Por \eqref{eq:numeral:PQ}} \nonumber \\
                    \synteq &(\cn{n}\, P)^{m-2} (\cn{n}\, P (P^{n}\, Q)) &\text{Por \eqref{eq:abuso:F}} \nonumber \\
                 \reduce{β} &(\cn{n}\, P)^{m-2} (P^{n} (P^{n}\, Q)) &\text{Por \eqref{eq:numeral:PQ}} \nonumber \\
                    \synteq &(\cn{n}\, P)^{m-2} (P^{2\times n}\, Q) \nonumber \\
                            &... &\text{Repitiendo para \( m-3, ..., m-m \)} \nonumber \\
                  \reduce{β} &(\cn{n}\, P)^{m-m} (P^{m\times n}\, Q) \nonumber \\
                     \synteq &P^{m\times n}\, Q &\text{Por \eqref{eq:abuso:F}} \nonumber
\end{align}

\begin{align}
  \label{eq:numeral:mP}
  \cn{n}^{m}\, P \synteq &\cn{n}^{m-1} (\cn{n}\, P) &\text{Por \eqref{eq:abuso:F}} \\
                \synteq &\cn{n}^{m-2} (\cn{n} (\cn{n}\, P)) &\text{Por \eqref{eq:abuso:F}} \nonumber \\
           \contract{β} &\cn{n}^{m-2} (λx.(\cn{n}\, P)^{n} x) &\text{Por \eqref{eq:numeral:P}} \nonumber \\
             \reduce{β} &\cn{n}^{m-2} (λx.P^{n\times n}\, x) &\text{Por \eqref{eq:numeral:PmQ}} \nonumber \\
                \synteq &\cn{n}^{m-2} (\cn{n\times n}\, P) &\text{Por \eqref{eq:numeral:P}} \nonumber \\
                        &... &\text{Repitiendo para \( m-3, ..., m-m \)} \nonumber \\
             \reduce{β} &\cn{n}^{m-m} (\cn{n^{m}}\, P) \nonumber \\
                \synteq &(\cn{n^{m}}\, P) &\text{Por \eqref{eq:abuso:F}} \nonumber
\end{align}

Consideremos ahora la reducción de aplicaciones de numerales de la forma \( (\cn{n}\, \cn{m}) \).

Cuando \( \cn{n} \synteq \cn{0} \) se tienen términos \( (\cn{0}\, \cn{m}) \), por la definición \eqref{eq:numeral} se tiene que \( \cn{0} \) y \( \bf{F} \) son sintácticamente equivalentes, en el cuadro \ref{tab:verdad-pares} se mostró que \( (\bs{F}\, M) \reduce{β} \bs{I} \) para todo término \( M \), por lo tanto, se asegura que en general \( (\cn{0}\, M) \reduce{β} \bs{I} \).

Cuando \( \cn{n} \synteq \cn{1} \) los pasos de la reducción con \( \cn{m} \in \{ \cn{0},\ \cn{1},\ \cn{2} \} \) son:

Consideremos la reducción de una aplicación de numerales \( (\cn{n}\, \cn{m}) \). Cuando \( \cn{n} \synteq \cn{0} \) se tiene que para todo natural \( m \), \( (\cn{0}\, \cn{m}) \reduce{β} \bs{I} \) debido a que \( \cn{0} \synteq \bs{F} \) y \( (\bs{F}\, M) \reduce{β} \bs{I} \). Cuando \( \cn{n} \synteq \cn{1} \) las reducciones siguen siendo manejables, para los casos donde \( \cn{m} \synteq \cn{0}, \cn{1}, \cn{2} \) se obtienen las siguientes reducciones:

\begin{align*}
  \cn{1}\, \cn{0} &\contract{β} (λx.\cn{0}^{1}\, x) &\text{Por \eqref{eq:numeral:P}} \\
                  &\reduce{β} (λx.\cn{0^{1}}\, x) &\text{Por \eqref{eq:numeral:mP}} \\
                  &\contract{β} (λx\, y.x^{0}\, y) &\text{Por \eqref{eq:numeral:P}} \\
                  &\synteq \cn{0} \\
  \cn{1}\, \cn{1} &\contract{β} (λx.\cn{1}^{1}\, x) &\text{Por \eqref{eq:numeral:P}} \\
                  &\reduce{β} (λx.\cn{1^{1}}\, x) &\text{Por \eqref{eq:numeral:mP}} \\
                  &\contract{β} (λx\, y.x^{1}\, y) &\text{Por \eqref{eq:numeral:P}} \\
                  &\synteq \cn{1} \\
  \cn{1}\, \cn{2} &\contract{β} (λx.\cn{2}^{1}\, x) &\text{Por \eqref{eq:numeral:P}} \\
                  &\reduce{β} (λx.\cn{2^{1}}\, x) &\text{Por \eqref{eq:numeral:mP}} \\
                  &\contract{β} (λx\, y.x^{2}\, y) &\text{Por \eqref{eq:numeral:P}} \\
                  &\synteq \cn{2} \\
\end{align*}

Para cualquier numeral \( \cn{m} \):

\begin{align*}
  \cn{1}\, \cn{m} \contract{β} λx.\cn{m}^{1}\, x \reduce{β} λx.\cn{m^{1}}\, x \contract{β} λx\, y.x^{m}\, y \synteq \cn{m}
\end{align*}

Cuando se considera \( \cn{n} \synteq \cn{2} \) las reducciones siguen los mismos pasos que en el caso anterior:

\begin{align*}
  \cn{2}\, \cn{m} &\contract{β} λx.\cn{m}^{2}\, x \reduce{β} λx.\cn{m^{2}}\, x \contract{β} λx\, y.x^{m^{2}}\, y \synteq \cn{m^{2}}
\end{align*}

Lo cual nos lleva a concluír que en el caso general, para cualesquiera numerales \( \cn{n} \) y \( \cn{m} \):

\begin{equation}
  \label{eq:numeral:nm}
  \cn{n}\, \cn{m} \contract{β} λx.\cn{m}^{n}\, x \reduce{β} λx.\cn{m^{n}}\, x \contract{β} λx\, y.x^{m^{n}}\, y \synteq \cn{m^{n}}
\end{equation}

Es curioso observar como la reducción de una aplicación sencilla entre dos numerales nos permite computar una operación aritmética relativamente compleja como la exponenciación. Este resultado pudiera parecer también preocupante, si la codificación de la operación \( n^{m} \) es tan sencillo como reducir la aplicación \( (\cn{m}\, \cn{n}) \), ¿Cómo se implementan operaciones mas simples como la suma y la multiplicación?.

En lo que resta de la sección se presentan procedimientos sistemáticos para codificar las operaciones elementales de la aritmética.

\subsection{Operaciones elementales}
\label{sec:aritmetica-elemental}

En la ecuación \eqref{eq:numeral:nm} se muestra como la aplicación de dos numerales se relaciona directamente con la operación de exponenciación. La primera aproximación a la codificación de las operaciones aritméticas seguirá un procedimiento inverso a cómo se dió con este resultado.

Las operaciones que se codificarán son la suma, la multiplicación y la exponenciación. Estas tres operaciones son binarias, es decir, a partir de dos números calculan otro. Para comenzar a codificar este tipo de operaciones consideremos una operación aritmética binaria \( \odot \) que realiza algún cálculo.

La convención para nombrar numerales será utilizada para las operaciones aritméticas, por lo tanto \( m \odot n \) se codifica como \( (\cn{\odot}\, \cn{m}\, \cn{n}) \). Ya que \( \cn{\odot} \) es una abstracción que espera ser aplicada a dos numerales, se propone que la operación codificada tenga la forma \( \cn{\odot} \synteq (λ\cn{m}\, \cn{n}.M) \), donde \( M \) es un término que al reducir la aplicación \( (\cn{\odot}\, \cn{a}\, \cn{b}) \) es equivalente a \( (λx\, y.x^{a \odot b}\, y) \).

En el caso de la codificación de la exponenciación, denotada \( \cn{\uparrow} \), se tiene que \( (\cn{\uparrow}\, \cn{m}\, \cn{n}) \) debe reducirse a

\[ λx\, y.x^{m^{n}}\, y \]

Se puede derivar el término \( \cn{\uparrow} \) observando que

\begin{align*}
  λx\, y.x^{m^{n}}\, y &\synteq \cn{m^{n}} &\text{Por \eqref{eq:numeral}} \\
                       &\convertible{β} \cn{n}\, \cn{m} &\text{Por \eqref{eq:numeral:nm}} \\
                       &\convertible{β} λx\, y.\cn{n}\, \cn{m}\, x\, y
\end{align*}

Por lo tanto, la codificación de la exponenciación es

\begin{equation}
  \label{eq:numeral:exp1}
  \cn{\uparrow} \synteq λm\, n.λx\, y.n\, m\, x\, y
\end{equation}

En el caso de la codificación de la multiplicación, denotada \( \cn{\times} \), se tiene que \( (\cn{\times}\, \cn{m}\, \cn{n}) \) debe reducirse a

\[ λx\, y.x^{n\times m}\, y \]

Para derivar el término \( \cn{\times} \) se observa que

\begin{align*}
  λx\, y.x^{n\times m}\, y &\convertible{β} λx\, y.(\cn{m}\, x)^{n}\, y &\text{Por \eqref{eq:numeral:PmQ}} \\
                           &\convertible{β} λx\, y.\cn{n} (\cn{m}\, x) y &\text{Por \eqref{eq:numeral:PQ}}
\end{align*}

Por lo tanto, la codificación de la multiplicación es

\begin{equation}
  \label{eq:numeral:mul1}
  \cn{\times} \synteq λm\, n.λx\, y.n(m\, x)y
\end{equation}

Finalmente, con la operación de adición, denotada \( \cn{+} \), se tiene que \( (\cn{+}\, \cn{m}\, \cn{n}) \) debe reducirse a

\[ λx\, y.x^{n+m}\, y \]

Para derivar el término \( \cn{+} \) se observa que

\begin{align*}
  λx\, y.x^{n+m}\, y &\synteq λx\, y.x^{n} (x^{m}\, y) &\text{Por \eqref{eq:abuso:F}} \\
                     &\convertible{β} λx\, y.x^{n} (\cn{m}\, x\, y) &\text{Por \eqref{eq:numeral:PQ}} \\
                     &\convertible{β} λx\, y.\cn{n}\, x (\cn{m}\, x\, y) &\text{Por \eqref{eq:numeral:PQ}}
\end{align*}

Por lo tanto, la codificación de la adición es

\begin{equation}
  \label{eq:numeral:sum1}
  \cn{+} \synteq λm\, n.λx\, y.n\, x (m\, x\, y)
\end{equation}

Las codificaciones \eqref{eq:numeral:exp1}, \eqref{eq:numeral:mul1} y \eqref{eq:numeral:sum1} fueron construídas a partir de las reducciones mostradas en \eqref{eq:numeral:PmQ}, \eqref{eq:numeral:mP} y \eqref{eq:numeral:nm}, las cuales a su vez fueron obtenidas a partir del abuso de notación definido en \eqref{eq:abuso:F} el cual refleja la estructura de los numerales de Church, por lo tanto, las codificaciones mostradas se basan únicamente en la estructura de los numerales. Sin embargo, las operaciones de adición, multiplicación y exponenciación no son únicamente cálculos independientes que permiten expresar expresiones aritméticas. Estas tres operaciones se encuentran conceptualmente relacionadas.

\begin{figure}[h!]
  \begin{align*}
    \cn{+} & &\synteq& & \mathcolor{gray}{λm\, n.λx\, y.}\mathcolor{red}{n}\, x (\mathcolor{blue}{m}\, x\, y) & &\synteq& & \mathcolor{gray}{(λm.(λn.(λx.(λy.}((n\, x)\mathcolor{magenta}{((m\, x)y)})\mathcolor{gray}{))))} \\
    \cn{\times} & &\synteq& & \mathcolor{gray}{λm\, n.λx\, y.}\mathcolor{red}{n}(\mathcolor{blue}{m}\, x)y & &\synteq& & \mathcolor{gray}{(λm.(λn.(λx.(λy.}((n\mathcolor{magenta}{(m\, x)})y)\mathcolor{gray}{))))} \\
    \cn{\uparrow} & &\synteq& &\mathcolor{gray}{λm\, n.λx\, y.}\mathcolor{red}{n}\, \mathcolor{blue}{m}\, x\, y & &\synteq& & \mathcolor{gray}{(λm.(λn.(λx.(λy.}(((n\, \mathcolor{magenta}{m})x)y)\mathcolor{gray}{))))}
  \end{align*}
  \caption{Codificaciones de adición, multiplicación y exponenciación}
  \label{fig:numeral:cod1comp}
\end{figure}

En la figura \ref{fig:numeral:cod1comp} se puede apreciar la diferencia estructural entre las codificaciones definidas, las similitudes se encuentran coloreadas en gris.

La segunda columna muestra las tres codificaciones escritas de manera compacta, se observa que en los tres casos, la aparición de \( n \) se encuentra antes que la aparición de \( m \). Debido a que los numerales de Church son abstracciones, al reducir la aplicación de una operación a dos numerales \( \cn{m} \) y \( \cn{n} \), la estructura del resultado en su forma normal se basará principalmente en la estructura de \( \cn{n} \). Esto no es muy relevante en el caso de \( \cn{+} \) y \( \cn{\times} \) ya que las operaciones son conmutativas, por lo tanto, no es importante si se intercambian las apariciones de \( n \) y \( m \), sin embargo, la exponenciación no es una operación conmutativa, el numeral base y el numeral exponente juegan papeles diferentes en la operación.

La tercera columna muestra las tres codificaciones escritas sin abuso de notación, se observa que la aparición de \( m \) se agrupa con las variables \( x \) y \( y \) de manera similar a las ecuaciones \eqref{eq:numeral}, \eqref{eq:numeral:P} y \eqref{eq:numeral:PQ}, las cuales fueron utilizadas en las ecuaciones \eqref{eq:numeral:PmQ}, \eqref{eq:numeral:mP} y \eqref{eq:numeral:nm}.

La figura nos permiten razonar sobre la manera en como se \( β \)-reduce la aplicación de las operaciones, sin embargo, las similitudes en la estructura de las codificaciones no refleja las similitudes de las operaciones, por lo que es difícil razonar sobre las operaciones a partir de su definición.

En la sección \ref{sec:algebra-booleana}, las codificaciones desarrolladas se basaron en una relación fundamental entre los valores de verdad y una desición, esto permitió construir abstracciones componibles que facilitaron codificar y razonar sobre las expresiones booleanas, a tal grado que se estableció una correspondencia directa entre las expreciones condicionales de los lenguajes de programación y las operaciones booleanas.

Para lograr este mismo efecto con la codificación de la aritmética, se deben hacer observaciones más fundamentales sobre la estructura de los numerales de Church y las nociones de las operaciones aritméticas.

Los números naturales nacieron a la par de la necesidad humana de \emph{contar}. De manera similar a la analogía presentada al inicio de la sección \ref{sec:valores-de-verdad} se plantea la siguiente situación hipotética:

Una persona omnisciente y muda llamada \( P \) puede decirme la cantidad de objetos en el mundo si le planteo una pregunta con una respuesta contable y le doy un martillo y un clavo; la cantidad de objetos va a corresponder a la cantidad de veces que \( P \) golpea el clavo con el martillo. En este planteamiento irreal e hipotético, no es necesario conocer la estructura del número, sólo es necesario tener a alguien que pueda contar y proveer dos objetos sabiendo que la persona va a realizar algo con el primero sobre el segundo (en este caso, golpear con el martillo al clavo). La cantidad de acciones que realiza esta persona pueden representar valores numéricos si nunca podemos conocer a los números naturales.

Detrás del concepto de número natural, está el concepto de \emph{repetición}, los numerales de Church se basan en este concepto.

Sea \( P \) un término lambda el cual puede ser aplicado a una pregunta \( Q \), al \( β \)-reducir \( (P\, Q) \) se obtiene una repetición \( R \) la cual al ser aplicada a una acción \( A \) y un objeto \( O \) se \( β \)-reduce a realizar la acción \( A \) sobre \( O \) y repetir el procedimiento con el resultado hasta haber realizado cierta cantidad de acciones:

\[ P\, Q \reduce{β} R, \]

\[ R\, A\, O \reduce{β} \underbrace{A(A(\ ...\ (A(A\, O))\ ...\ ))}_\text{\( n \) veces} \]

Para fines prácticos no es necesario conocer la estructura de \( P \) ni de \( Q \), lo importante es que \( A \) se realice cierta cantidad de veces sobre \( O \). Por lo tanto \( R \) es un término lambda de la forma

\[ λx\, y.x(x(\ ...\ (x(x\, y))\ ...\ )) \]

La cual corresponde a la estructura de los numerales de Church.

Teniendo una justificación conceptual e informal para considerar a los números como repeticiones podemos estudiar las operaciones aritméticas a partir de esta perspectiva.

Al inicio de esta sección se construyeron las codificaciones de las operaciones aritméticas en un orden peculiar. Primero la exponenciación, después la multiplicación y al final la adición. Esto es bastante raro debido a que la exponenciación suele ser considerada una operación más compleja que la multiplicación y a su vez esta más compleja que la adición, la estructura de las codificaciones parece aumentar en complejidad entre menos complejas son las operaciones que describen.

La persepción de complejidad de operaciones aritméticas se remonta a la manera en cómo se enseña la aritmética en la educación básica. Después de aprender a contar, se aprende a sumar y después a multiplicar. A pesar de ser en un inicio un proceso de memorización, el acto de sumar y multiplicar números pequeños termina siendo un acto trivial, empleando algoritmos y heurísticas de estimación cuando los números son grandes. En el caso de la exponenciación, los computólogos suelen adquirir esta misma capacidad cuando se trata de operaciones de la forma \( 2^{n} \) debido a la repetida utilización de números en base 2. Sin embargo, esta persepción tiene también una justificación algorítmica.

La operación de multiplicación puede ser definida en función de la operación de adición. Sean \( m \) y \( n \) dos números naturales, la operación \( m \times n \) es equivalente a sumar \( m \) consigo mismo \( n \) veces.

\begin{equation}
  \label{eq:numeral:muldef}
  m \times n = \underbrace{m + m + ... + m}_\text{\( n \) veces} = \sum_{i=1}^{n} m
\end{equation}

De manera análoga, la operación de exponenciación puede ser definida en función de la operación de multiplicación. Sean \( m \) y \( n \) dos números naturales, la operación \( m^{n} \) es equivalente a multiplicar \( m \) consigo mismo \( n \) veces.


\begin{equation}
  \label{eq:numeral:expdef}
  m^{n} = \underbrace{m \times m \times ... \times m}_\text{\( n \) veces} = \prod_{i=1}^{n} m
\end{equation}

De esta manera, una operación compleja como la exponenciación se define en términos de una operación más fundamental como la multiplicación. Esta observación trae a colación la pregunta, ¿Cuál es la operación aritmética más fundamental?.

La respuesta a esta pregunta no es fácil de encontrar, se pudiera pensar que la adición es la operación más fundamental, sin embargo, la adición puede ser definida en función de la operación unaria sucesor y esta a su vez es un caso particular de la adición. Sea \( +_{1} \) el operador unario sucesor

\[ m + n = \underbrace{+_{1} +_{1} ... {} +_{1}}_\text{\( n \) veces} m = \underbrace{1 + 1 + ... + 1}_\text{\( n \) veces}+m \]

En la segunda aproximación de las codificaciones, se considera que el operador de sucesor es más fundamental que la adición debido a que es fácil codificar la sucesión sin basarse en resultados previos.

La definición de la operación de sucesor consiste en ``añadir'' una variable \( x \) a un número, ya que

\[ \cn{n} \synteq λx\, y.\underbrace{x(x(\ ...\ (x\, y)))}_\text{\( n \) apariciones de \( x \)} \]

solo se necesita obtener el cuerpo del numeral con la aplicación \( (\cn{n}\, x\, y) \) y aplicar \( x \) al resultado de la reducción. La codificación del operador \( \cn{+_{1}} \) es

\begin{equation}
  \label{eq:numeral:suc2}
  \cn{+_{1}} \synteq λn.λx\, y.x(n\, x\, y)
\end{equation}

Para demostrar que esta definición es correcta, consideremos la reducción de la aplicación de \( \cn{+_{1}} \) en un numeral cualquiera \( \cn{n} \):

\begin{align}
  \label{eq:numeral:suc2dem}
  \cn{+_{1}}\, \cn{n} \synteq &(λn.λx\, y.x(n\, x\, y)) \cn{n} &\text{Por \eqref{eq:numeral:suc2}} \\
                \contract{β} &λx\, y.x(\cn{n}\, x\, y) \nonumber \\
                  \reduce{β} &λx\, y.x(x^{n}\, y) &\text{Por \eqref{eq:numeral:PQ}} \nonumber \\
                     \synteq &λx\, y.x^{n+1}\, y &\text{Por \eqref{eq:abuso:F}} \nonumber \\
                     \synteq &\cn{n+1} \nonumber
\end{align}

Ahora se debe plantear una manera de aplicar el concepto de repetición de sucesores para obtener la adición. La operación \( \cn{+} \) deberá tomar dos numerales \( \cn{m} \) y \( \cn{n} \) y repetir \( \cn{n} \) veces la operación de sucesor sobre \( \cn{m} \). Ya que la aplicación de \( \cn{+_{1}} \) a un numeral, resulta en un numeral basta con aplicar \( \cn{n} \) al operador \( \cn{+_{1}} \) y al numeral \( \cn{m} \). Por ejemplo

\begin{align*}
  (\cn{3}\, \cn{+_{1}}\, \cn{4}) \reduce{β} &\cn{+_{1}} (\cn{+_{1}} (\cn{+_{1}}\, \cn{4})) &\text{Por \eqref{eq:numeral:PQ}} \\
                                 \reduce{β} &\cn{+_{1}} (\cn{+_{1}}\, \cn{5}) &\text{Por \eqref{eq:numeral:suc2dem}} \\
                                 \reduce{β} &\cn{+_{1}}\, \cn{6} &\text{Por \eqref{eq:numeral:suc2dem}} \\
                                 \reduce{β} &\cn{7} &\text{Por \eqref{eq:numeral:suc2dem}}
\end{align*}

En general, para cualesquiera \( \cn{m} \) y \( \cn{n} \), la aplicación \( (\cn{n}\, \cn{+_{1}}\, \cn{m}) \) se reduce a:

\begin{align}
  \label{eq:numeral:sum2dem}
  \cn{n}\, \cn{+_{1}}\, \cn{m} \reduce{β} &\cn{+_{1}}^{n}\, \cn{m} &\text{Por \eqref{eq:numeral:PQ}} \\
                                 \synteq &\cn{+_{1}}^{n-1} (\cn{+_{1}}\, \cn{m}) &\text{Por \eqref{eq:abuso:F}} \nonumber \\
                              \reduce{β} &\cn{+_{1}}^{n-1}\, \cn{m+1} &\text{Por \eqref{eq:numeral:suc2dem}} \nonumber \\
                                      ...& \nonumber \\
                              \reduce{β} &\cn{+_{1}}^{n-n}\, \cn{m+n} \nonumber \\
                                 \synteq &\cn{m+n} &\text{Por \eqref{eq:abuso:F}} \nonumber
\end{align}

La codificación del operador \( \cn{+} \) es

\begin{equation}
  \label{eq:numeral:sum2}
  \cn{+} \synteq λm\, n.n\, \cn{+_{1}}\, m
\end{equation}

Para codificar la operación de multiplicación y exponenciación se puede seguir el mismo patrón: un numeral \( \cn{n} \) determina una cantidad de repeticiones, es aplicado a una operación unaria que será aplicada \( n \) veces a un término. Hay dos detalles importantes que considerar, primero, cómo convertir una codificación de una operación binaria a unaria y qué valor aplicar al final.

En el caso de la codificación de la multiplicación se debe convertir a \( \cn{+} \) en una operación unaria, por la definición de multiplicación \eqref{eq:numeral:muldef} se tiene que

\[ m + m + ... + m = m + m + ... + m + 0 = (m + (m + ... + (m + 0) ...)) \]

Esto es, se repite la aplicación de una abstracción que toma un numeral y computa la suma de el numeral y \( m \), cierta cantidad de veces, comenzando con el numeral \( \cn{0} \). Para construír la versión unaria de \( \cn{+} \) se puede plantear la abstracción:

\[ λn.(\cn{+}\, n\, \cn{m}) \]

Sin embargo hay una manera más conveniente de escribir esta abstracción. Si consideramos la definición \eqref{eq:numeral:sum2} y la aplicamos únicamente a un numeral, se reduce a

\[ \cn{+}\, \cn{m} \synteq (λm\, n.n\, \cn{+_{1}}\, m)\cn{m} \contract{β} λn.n\, \cn{+_{1}}\, \cn{m} \]

El cual al ser aplicado a algun numeral \( \cn{n} \) será reducido a un término \( β \)-convertible a \( (\cn{+}\, \cn{m}\, \cn{n}) \). Por lo tanto, la aplicación \( (\cn{n} (\cn{+}\, \cn{m}) \cn{0}) \) computa la multiplicación de \( \cn{m} \) y \( \cn{n} \). Por ejemplo

\begin{align*}
  \cn{3} (\cn{+}\, \cn{4}) \cn{0} \reduce{β} &(\cn{+}\, \cn{4})^{3} \cn{0} &\text{Por \eqref{eq:numeral:PQ}} \\
                                     \synteq &(\cn{+}\, \cn{4})^{2} (\cn{+}\, \cn{4}\, \cn{0}) &\text{Por \eqref{eq:abuso:F}} \\
                                  \reduce{β} &(\cn{+}\, \cn{4})^{2} \cn{4} &\text{Por \eqref{eq:numeral:sum2dem}} \\
                                     \synteq &(\cn{+}\, \cn{4}) (\cn{+}\, \cn{4}\, \cn{4}) &\text{Por \eqref{eq:abuso:F}} \\
                                  \reduce{β} &(\cn{+}\, \cn{4}) \cn{8} &\text{Por \eqref{eq:numeral:sum2dem}} \\
                                     \synteq &(\cn{+}\, \cn{4})^{0} (\cn{+}\, \cn{4}\, \cn{8}) &\text{Por \eqref{eq:abuso:F}} \\
                                  \reduce{β} &(\cn{+}\, \cn{4})^{0} \cn{12} &\text{Por \eqref{eq:numeral:sum2dem}} \\
                                     \synteq &\cn{12} &\text{Por \eqref{eq:abuso:F}}
\end{align*}

En general, para cualesquiera \( \cn{m} \) y \( \cn{n} \), la aplicación \( (\cn{n} (\cn{+}\, \cn{m}) \cn{0}) \) se reduce a:

\begin{align}
  \label{eq:numeral:mul2dem}
  \cn{n} (\cn{+}\, \cn{m}) \cn{0} \reduce{β}& (\cn{+}\, \cn{m})^{n} \cn{0} &\text{Por \eqref{eq:numeral:PQ}} \\
                                       \synteq& (\cn{+}\, \cn{m})^{n-1} (\cn{+}\, \cn{m}\, \cn{0}) &\text{Por \eqref{eq:abuso:F}} \nonumber \\
                                    \reduce{β}& (\cn{+}\, \cn{m})^{n-1} \cn{m+0} &\text{Por \eqref{eq:numeral:sum2dem}} \nonumber \\
                                       \synteq& (\cn{+}\, \cn{m})^{n-2} (\cn{+}\, \cn{m}\, \cn{m+0}) &\text{Por \eqref{eq:abuso:F}} \nonumber \\
                                    \reduce{β}& (\cn{+}\, \cn{m})^{n-2} \cn{m\times 2 + 0} &\text{Por \eqref{eq:numeral:sum2dem}} \nonumber \\
                                           ...& \nonumber \\
                                    \reduce{β}& (\cn{+}\, \cn{m})^{n-n} \cn{m\times n + 0} \nonumber \\
                                       \synteq& \cn{m\times n} &\text{Por \eqref{eq:abuso:F}} \nonumber
\end{align}

La codificación del operador \( \cn{\times} \) es

\begin{equation}
  \label{eq:numeral:mul2}
  \cn{\times} \synteq λm\, n.n (\cn{+}\, m) \cn{0}
\end{equation}

De manera análoga, se utiliza la definición de exponenciación \eqref{eq:numeral:expdef} para definir su codificación en función de \( \cn{\times} \). Sean \( \cn{m} \) y \( \cn{n} \) dos numerales cualesquiera, la aplicación \( (\cn{\uparrow}\, \cn{m}\, \cn{n}) \) debe repetir la multiplicación de la base \( \cn{m} \) una cantidad de veces determinada por el exponente \( \cn{n} \). La codificación es muy similar a la de multiplicación, sólo que utilizando como término final el numeral \( \cn{1} \) ya que \( \prod_{i=1}^{n} m = 1 \times \prod_{i=1}^{n} m \). Para corroborar que la aplicación \( (\cn{n} (\cn{\times}\, \cn{m}) \cn{1}) \) computa la exponenciación de \( \cn{m} \) a la \( \cn{n} \) se desarrolla el siguiente ejemplo

\begin{align*}
  \cn{3} (\cn{\times}\, \cn{4}) \cn{1} \reduce{β} &(\cn{\times}\, \cn{4})^{3} \cn{1} &\text{Por \eqref{eq:numeral:PQ}} \\
                                          \synteq &(\cn{\times}\, \cn{4})^{2} (\cn{\times}\, \cn{4}\, \cn{1}) &\text{Por \eqref{eq:abuso:F}} \\
                                       \reduce{β} &(\cn{\times}\, \cn{4})^{2} \cn{4} &\text{Por \eqref{eq:numeral:mul2dem}} \\
                                          \synteq &(\cn{\times}\, \cn{4})^{1} (\cn{\times}\, \cn{4}\, \cn{4}) &\text{Por \eqref{eq:abuso:F}} \\
                                       \reduce{β} &(\cn{\times}\, \cn{4})^{1} \cn{16} &\text{Por \eqref{eq:numeral:mul2dem}} \\
                                          \synteq &(\cn{\times}\, \cn{4})^{0} (\cn{\times}\, \cn{4}\, \cn{16}) &\text{Por \eqref{eq:abuso:F}} \\
                                       \reduce{β} &(\cn{\times}\, \cn{4})^{0} \cn{64} &\text{Por \eqref{eq:numeral:mul2dem}} \\
                                          \synteq &\cn{64}
\end{align*}

En general, para cualesquiera \( \cn{m} \) y \( \cn{n} \), la aplicación \( (\cn{n} (\cn{\times}\, \cn{m}) \cn{1}) \) se reduce a:

\begin{align}
  \label{eq:numeral:exp2dem}
  \cn{n} (\cn{\times}\, \cn{m}) \cn{1} \reduce{β} &(\cn{\times}\, \cn{m})^{n} \cn{1} &\text{Por \eqref{eq:numeral:PQ}} \\
                                          \synteq &(\cn{\times}\, \cn{m})^{n-1} (\cn{\times}\, \cn{m}\, \cn{1}) &\text{Por \eqref{eq:abuso:F}} \nonumber \\
                                       \reduce{β} &(\cn{\times}\, \cn{m})^{n-1} \cn{m\times 1} &\text{Por \eqref{eq:numeral:mul2dem}} \nonumber \\
                                          \synteq &(\cn{\times}\, \cn{m})^{n-2} (\cn{\times}\, \cn{m}\, \cn{m\times 1}) &\text{Por \eqref{eq:abuso:F}} \nonumber \\
                                       \reduce{β} &(\cn{\times}\, \cn{m})^{n-2} \cn{m^{2}\times 1} &\text{Por \eqref{eq:numeral:mul2dem}} \nonumber \\
                                              ... &\nonumber \\
                                       \reduce{β} &(\cn{\times}\, \cn{m})^{n-n} \cn{m^{n}\times 1} \nonumber \\
                                          \synteq &\cn{m^{n}} \nonumber
\end{align}

La codificación del operador \( \cn{\uparrow} \) es

\begin{equation}
  \label{eq:numeral:exp2}
  \cn{\uparrow} \synteq λm\, n.n(\cn{\times}\, m) \cn{1}
\end{equation}

Comparando esta segunda aproximación de las codicicaciones de \( \cn{+} \), \( \cn{\times} \) y \( \cn{\uparrow} \) se pueden observar relaciones tanto en estructura como en significado.

En la tabla \ref{fig:numeral:cod2comp} se puede apreciar la diferencia estrucural entre las codificaciones definidas, las similitudes menos importantes se encuentran coloreadas en gris.

\begin{figure}[h!]
  \begin{align*}
    \cn{+} &&\synteq&& \mathcolor{gray}{λm\, n.}\mathcolor{red}{n} \cn{+_{1}} \mathcolor{blue}{m}  &&\synteq&& \mathcolor{gray}{(λm.(λn.}((n\, \mathcolor{magenta}{\cn{+_{1}}}) m)\mathcolor{gray}{))} \\
    \cn{\times} &&\synteq&& \mathcolor{gray}{λm\, n.}\mathcolor{red}{n} (\cn{+}\, m) \mathcolor{blue}{\cn{0}}  &&\synteq&& \mathcolor{gray}{(λm.(λn.}((n \mathcolor{magenta}{(\cn{+}\, m)})\cn{0})\mathcolor{gray}{))} \\
    \cn{\uparrow} &&\synteq&& \mathcolor{gray}{λm\, n.}\mathcolor{red}{n} (\cn{\times}\, m) \mathcolor{blue}{\cn{1}}  &&\synteq&& \mathcolor{gray}{(λm.(λn.}((n \mathcolor{magenta}{(\cn{\times}\, m)})\cn{1})\mathcolor{gray}{))}
  \end{align*}
  \caption{Codificaciones de adición, multiplicación y exponenciación}
  \label{fig:numeral:cod2comp}
\end{figure}

La segunda columna muestra las tres codificaciones escritas de manera compacta, se observa que en los tres casos el átomo \( n \) corresponde al operando derecho de la operación y es el que determina la cantidad de veces que se aplicará un procedimiento. Coloreados con azúl se encuentran los valores iniciales a los que se aplica el procedimiento, estos corresponden al caso trivial de la operación, es decir, si \( n \) es cero, entonces el resultado de la suma es \( m \), el de la multiplicación es \( 0 \) y el de la exponenciación es \( 1 \).

En la tercer columna se encuentran las codificaciones escritas sin abuso de notación, coloreado en magenta están los términos a los que \( n \) es aplicado primero, esto es, los términos que serán aplicados una y otra vez. Estos términos se encuentran en función de la operación anterior (en orden de menor a mayor complejidad). Al ver las definiciones se puede saber que la expoenciación es repetición de multiplicaciones con caso base \( 1 \), la multiplicación es repetición de adiciones con caso base \( 0 \) y la adición es repetición de sucesiones con caso base \( m \).

Teniendo codificaciones definidas de manera compacta y elegante, solo queda preguntarnos cómo obtener el resto de las operaciones aritméticas elementales, es decir, la sustracción, la división y para completar las inversas, el logaritmo y la raíz.

Estas operaciones inversas pueden ser vistas de manera similar a la adición, multiplicación y exponenciación, solo que en lugar de añadir aplicaciones, eliminar aplicaciones. Esto se puede lograr con la operación \emph{predecesor}, definida como una operación unaria cerrada en los naturales como

\begin{align*}
  -_{1} 0 &= 0 \\
  -_{1} n &= n-1
\end{align*}

La estructura de los numerales de Church favorece los mecanismos que añaden aplicaciones. En la codificación del sucesor fué relativamente sencillo ``reenlazar'' las variables ligadas en \( \cn{n} \) de tal manera que sólo se necesitaba aplicar \( x \) a \( (x^{n}\, y) \) para obtener \( (x^{n+1}\, y) \). Sin embargo, para codificar el predecesor es necesario ``eliminar'' una \( x \) de la aplicación y no hay manera sencilla de lograr esto.

Henk Barendreght, en el artículo titulado ``The Impact of Lambda Calculus in Logic and Computer Science'' \cite{Barendregt:Impact}, menciona que la codificación del predecesor en el cálculo lambda fue un problema abierto. Alonzo Church pudo codificar la adición, la multiplicación y la exponenciación, sin embargo, la función predecesor resultaba ser extremadamente difícil de encontrar con sus numerales.

Stephen Kleene, estudiante de Alonzo Church, encontró la solución de la misteriosa codificación del predecesor. Sin embargo se tuvo que auxiliar de una representación alternativa para los números naturales. De acuerdo a \cite{Barendregt:Impact}, Kleene hizo uso de una codificación de pares de números \( \langle n-1,n \rangle \). Se inicia con \( \langle 0,0 \rangle \) y el sucesor de \( \langle a,b \rangle \) es \( \langle b,b+1 \rangle \). Cuando Kleene le llevó la propuesta a Church, este ya se había convencido que el cálculo lambda era un sistema demasiado débil para representar el predecesor; es entonces que Church, habiendo aprendido que el predecesor era definible en el cálculo lambda, se convenció de que todas las funciones que eran intuitivamente computables, eran definibles en el cálculo lambda.

Para definir la codificación del predecesor, no se hará uso de la técnica de Kleene, pero si se introducirá otra notación para los números naturales.

Lo que hace que la estructura de los numerales de Church no sea adecuada es que no se tiene una manera sencilla de remover aplicaciones. Sin embargo, podemos considerar una modificación a los numerales de Church, de tal manera que el mecanismo para quitar y añadir aplicaciones sea sencillo.

Sea \( \cn{n} \) un numeral de Church, su estructura \( (λx\, y.x^{n}\, y) \) se modifica para que una de las apariciones de \( x \) se enlace a una variable diferente, por ejemplo \( z \), de tal manera que la cantidad de \( x \) sumada a la cantidad de \( z \) sea el número representado. Consideremos que el numeral modificado \( \cn{n}' \) tiene la última \( x \) de \( \cn{n} \) como \( z \), su definición sería:

\[ \cn{n}^{\prime} \synteq λx\, y\, z.x^{n-1}(z\, y) \]

En esta nueva codificación, los primeros cinco números son codificados como

\begin{align*}
  \cn{0}^{\prime} &\synteq λx\, y\, z.y \\
  \cn{1}^{\prime} &\synteq λx\, y\, z.z\, y \\
  \cn{2}^{\prime} &\synteq λx\, y\, z.x(z\, y) \\
  \cn{3}^{\prime} &\synteq λx\, y\, z.x(x(z\, y)) \\
  \cn{4}^{\prime} &\synteq λx\, y\, z.x(x(x(z\, y)))
\end{align*}

La clave de utilizar esta representación modificada está en observar que es fácil pasar de \( \cn{n}^{\prime} \) a \( \cn{n-1} \). Sea \( \cn{n}^{\prime} \) un numeral en la codificación modificada, la reducción de la aplicación \( (\cn{n}^{\prime}\, x\, y\, \bs{I}) \) resulta en \( (x^{n-1}\, y) \).

\begin{align*}
  \cn{n}^{\prime}\, x\, y\, \bs{I} \synteq &(λx\, y\, z.x^{n-1}(z\, y)) x\, y\, \bs{I} \\
                              \reduce{β} &x^{n-1}(\bs{I}\, y) \\
                            \contract{β} &x^{n-1}\, y
\end{align*}

De tal manera que la definición del predecesor \( \cn{-_{1}} \) para la codificación de Church puede ser escrita

\[ \cn{-_{1}} \synteq λn.λx\, y.\mathcal{T}[n\mapsto n^{\prime}]\, x\, y\, \bs{I} \]

Donde \( \mathcal{T}[n\mapsto n^{\prime}] \) es una transformación que a partir de \( n \) obtiene el mísmo número pero con la codificación modificada. Con la cual es sencillo encontrar \( n-1 \).

Para construír el término \( \mathcal{T}[n\mapsto n^{\prime}] \) se debe encontrar una manera de contar desde \( 0 \) hasta \( n \) en la codificación modificada. Esto se puede lograr utilizando la interpretación de los numerales de Church como operadores de repetición. Si se construye una codificación del sucesor \( \cn{+_{1}}^{\prime} \) para los numerales modificados, entonces \( \mathcal{T}[n\mapsto n^{\prime}] \) puede ser definida como \( n \) aplicaciones de \( \cn{+}^{\prime} \) con el caso base \( \cn{0}^{\prime} \), es decir

\[ \mathcal{T}[n\mapsto n^{\prime}] \synteq n\, \cn{+_{1}}^{\prime}\, \cn{0}^{\prime} \]

El problema de codificar el predecesor se reduce ahora a la construcción del sucesor de un número con la codificación modificada. Esta construcción resulta ser casi tan sencilla como la codificación de \( \cn{+_{1}} \). Primero se analiza cómo cambia la estructura de la codificación de \( \cn{n}^{\prime} \) a \( \cn{n+1}^{\prime} \):

\begin{align*}
  \cn{+_{1}}^{\prime}\, \cn{0}^{\prime} && \synteq && \cn{+_{1}}^{\prime} (λx\, y\, z.y) && \reduce{β} && λx\, y\, z.z\, y \\
  \cn{+_{1}}^{\prime}\, \cn{1}^{\prime} && \synteq && \cn{+_{1}}^{\prime} (λx\, y\, z.z\, y) && \reduce{β} && λx\, y\, z.x(z\, y)\\
  \cn{+_{1}}^{\prime}\, \cn{2}^{\prime} && \synteq && \cn{+_{1}}^{\prime} (λx\, y\, z.x(z\, y)) && \reduce{β} && λx\, y\, z.x(x(z\, y))\\
  \cn{+_{1}}^{\prime}\, \cn{3}^{\prime} && \synteq && \cn{+_{1}}^{\prime} (λx\, y\, z.x(x(z\, y))) && \reduce{β} && λx\, y\, z.x(x(x(z\, y)))
\end{align*}

Cuando se computa el sucesor de \( \cn{0}^{\prime} \), la única variable enlazada es \( y \) y el resultado es \( z\, y \), por lo tanto, la \( y \) será sustituída por \( (z\, y) \) en el sucesor. Cuando se computa el sucesor de \( \cn{1}^{\prime} \), se tienen variables enlazadas \( z \) y \( y \), si \( y \) es sustituído por \( (z\, y) \), la \( z \) deberá ser sustituída por \( x \) en el sucesor. Cuando se computa el sucesor de \( \cn{2}^{\prime} \), se tienen variables enlazadas \( x \), \( z \) y \( y \), si se suponen las sustituciones de los otros dos casos, la \( x \) deberá ser sustituída por \( x \) en el sucesor. Para corroborar que estas sustituciones son correctas, se considera la aplicación \( (\cn{3}^{\prime}\, x\, (z\, y)\, x) \):

\begin{align*}
  \cn{3}^{\prime}\, x (z\, y) x &\reduce{β} x^{2}(x(z\, y)) \\
                                &\synteq x^{3}(z\, y)
\end{align*}

Y en general, aplicar estos términos a un numeral modificado \( \cn{n}^{\prime} \) se reduce a

\begin{align*}
  \cn{n}^{\prime}\, x (z\, y) x &\reduce{β} x^{n-1}(x(z\, y)) \\
                                &\synteq x^{n}(z\, y)
\end{align*}

Término que corresponde al cuerpo del numeral \( \cn{4}^{\prime} \). Por lo tanto, la codificación de la operación \( \cn{+_{1}}^{\prime} \) es:

\[ \cn{+_{1}}^{\prime} \synteq λn^{\prime}.λx\, y\, z.n^{\prime}\, x (z\, y) x \]

Con estas piezas, la codificación de la operación predecesor se define como

\begin{equation}
  \label{eq:numeral:pred2}
  \cn{-_{1}} \synteq λn.λx\, y.(n\, \cn{+_{1}}^{\prime}\, \cn{0}^{\prime})x\, y\, \bs{I}
\end{equation}

Para corroborar que la codificación computa el resultado deseado, consideremos los casos \( \cn{n} \synteq \cn{0} \) y \( \cn{n} \synteq \cn{k} \) en la reducción de la aplicación \( (\cn{-_{1}}\, \cn{n}) \):

\begin{align*}
  \cn{-_{1}}\, \cn{0} \contract{β} &λx\, y.(\cn{0}\, \cn{+_{1}}^{\prime}\, \cn{0}^{\prime})x\, y\, \bs{I} \\
                        \reduce{β} &λx\, y.(\bs{I} \cn{0}^{\prime})x\, y\, \bs{I} \\
                      \contract{β} &λx\, y.\cn{0}^{\prime}\, x\, y\, \bs{I} \\
                           \synteq &λx\, y.(λx\, y\, z.y) x\, y\, \bs{I} \\
                        \reduce{β} &λx\, y.y \\
                           \synteq &\cn{0}
\end{align*}

\begin{align*}
  \cn{-_{1}}\, \cn{k} \contract{β} &λx\, y.(\cn{k}\, \cn{+_{1}}^{\prime}\, \cn{0}^{\prime})x\, y\, \bs{I} \\
                        \reduce{β} &λx\, y.\cn{+_{1}}^{\prime k}\, \cn{0}^{\prime}\, x\, y\, \bs{I} \\
                        \reduce{β} &λx\, y.\cn{k}^{\prime}\, x\, y\, \bs{I} \\
                           \synteq &λx\, y.(λx\, y\, z.x^{k-1}(z\, y)) x\, y\, \bs{I} \\
                        \reduce{β} &λx\, y.x^{k-1}(\bs{I}\, y) \\
                      \contract{β} &λx\, y.x^{k-1}\, y \\
                           \synteq &\cn{k-1}
\end{align*}



\subsection{Iteración}
\label{sec:iteracion}

Si un procedimiento \( F \) se realiza \( n \) veces, se puede iterar el procedimiento utilizando la estructura de los numerales

\[ (λf\, x.f^{n}\, x) F \reduce{} λx.F^{n}\, x \]

El estado inicial del cómputo es un término al que se le aplicará esta abstracción.

La codificación de un estado con \( n \) componentes se realiza utilizando la codificación de valores n-valentes de la sección de lógica, se pueden considerar como \( n \)-tuplas para \( n \) fijo a lo largo de la iteración.

\begin{align*}
  \bs{v_{1}} &\synteq λx_{1}\, ...\, x_{n}.x_{1} \\
  \bs{v_{2}} &\synteq λx_{1}\, ...\, x_{n}.x_{2} \\
             &\cdots \\
  \bs{v_{n}} &\synteq λx_{1}\, ...\, x_{n}.x_{n}
\end{align*}

Un estado del cómputo es un término \( s \synteq λp.p\, s_{1}\, s_{2}\, ...\, s_{n} \) el cual espera ser aplicado a algún \( \bs{v_{i}} \), de tal manera que la componente \( s_{i} \) se obtiene al reducir \( (s\, v_{i}) \).

El constructor de un estado es \( s^{*} \synteq λs_{1}\, s_{2}\, ...\, s_{n}.λp.p\, s_{1}\, s_{2}\, ...\, s_{n} \).

Por ejemplo, codificar la operación factorial, primero se determina la forma del estado

\[ (indice, acumulador) = s \synteq λp.p\, i\, a \]

El índice de un estado se obtiene con el término \( \bs{i} \synteq (λi\, a.i) \), y el acumulador de un estado se obtiene con el término \( \bs{a} \synteq (λi\, a.a) \). Estos son equivalentes a los valores de verdad.

El constructor del estado es \( s^{*} \synteq λi\, a.λp.p\, i\, a \).

La operación factorial para un numeral \( n \) comienza en el estado \( s \synteq (s^{*}\, n\, 1) \) y en un paso computa el estado \( (s^{*}\, (\bs{1_{-}}\, n) (\bs{\times} (s\, \bs{i}) (s\, \bs{a}))) \) el cual decrementa el índice en 1 y aumenta el acumulador multiplicando el acumulador del estado anterior por el índice actual.

La codificación quedaría

\[ \bs{!} \synteq λn.n(λs.(s^{*} (\bs{1_{0}}\, (s\, \bs{i})) (\bs{\times} (s\, \bs{i}) (s\, \bs{a}))))(s^{*}\, n\, 1) \]

No es necesario el combinador \( Y \) para hacer magia...

El algoritmo equivalente al término del factorial presentado aqui es

\begin{algorithm}
  \caption{factorial}
  \begin{algorithmic}
    \REQUIRE \( n \in \mathbb{N} \)
    \ENSURE \( n! \)
    \STATE \( s \leftarrow (n,\ 1) \)
    
    \COMMENT{La siguiente iteración mantiene una invariante \( n! = a\times i! \) en el estado \( (i,\ a) \)}
    \FOR{\( i = 1 \) \TO \( n \)}
    \STATE \( s \leftarrow (s_{1}-1,\ s_{2} \times s_{1})  \)
    \ENDFOR

    \RETURN \( s_{2} \)
  \end{algorithmic}
\end{algorithm}

\subsection{Hiperoperaciones}
\label{sec:hiperoperaciones}

\paragraph{Presentar segundos incisos en la lista de términos para las operaciones básicas}

¿Se podrá abstraer el concepto de esta repetición de operaciones?

Tetración, et al. Notación de Knuth, hiperoperaciones inversas ( resta, división, raíz/logaritmo )

\paragraph{Aquí comienzan las notas anteriores}


Así como se pueden representar los valores de verdad de falso y verdadero en el cálculo lambda, también podemos encontrar representaciones para los números naturales. En esta sección se aborda una representación llamada numerales de Church, también se presentan términos lambda para operar números naturales con esta representación.

Para cada \( n \in \mathbb{N} \) el numeral de Church de \( n \) es un término lambda denotado como \( \cn{n} \) definido como:

\[ \cn{n} \synteq λx\, y.x^{n}\, y \]

En la siguiente tabla se puede apreciar mejor la estructura de los numerales de Church

\begin{table}
  \centering
  \begin{tabular}{|c|c|}
    \hline
    \( n \) & \( \cn{n} \) \\ [0.5ex]
    \hline\hline
    0 & \( λx\, y.y \) \\
    \hline
    1 & \( λx\, y.x\, y \) \\
    \hline
    2 & \( λx\, y.x(x\, y) \) \\
    \hline
    3 & \( λx\, y.x(x(x\, y)) \) \\
    \hline
    ... & ... \\
    \hline
  \end{tabular}
  \caption{Numerales de Church}
  \label{tab:numerales}
\end{table}

Como se observa en la tabla, un numeral de Church es una abstracción descurrificada de dos argumentos la cual al ser evaluada es reducida a la \( n \)-ésima composición del primer argumento evaluada en el segundo argumento.

Una manera de entender esta representación es pensar en los números naturales como un conteo de uno en uno; el 0 es no contar; el 1 es contar uno mas que el 0; el 2 es uno mas que el 1, así que el 2 es uno mas que el uno mas que el 0; el 3 es uno mas que el 2, así que el 3 es uno mas que el uno mas que el uno mas que el 0 y así sucesivamente. La idea de ``el uno mas'' es la del sucesor, si consideramos a \( x \) como una función sucesor y a \( y \) como el 0, podemos expresar \( x(x(x(y))) \) como \( \mathrm{sucesor}(\mathrm{sucesor}(\mathrm{sucesor}(0))) \), así que

\begin{align*}
\mathrm{sucesor}(\mathrm{sucesor}(\mathrm{sucesor}(0))) & = \mathrm{sucesor}(\mathrm{sucesor}(1)) \\
                             & = \mathrm{sucesor}(2) \\
                             & = 3
\end{align*}

Es interesante pensar en diferentes maneras de expresar las operaciones mas elementales de la aritmétima como términos lambda que operen sobre esta representación. A continuación se presenta una exploración de los términos lambda correspondientes a algunas operaciones elementales de la aritmética: suma, multiplicación, exponenciación y resta. La suma es una repetición de la operación sucesor, la multiplicación una repetición de suma, la exponenciación una repetición de multiplicaciones y la resta una repetición de la operación predecesor. Esto nos lleva a identificar las operaciones de sucesor y predecesor como los algoritmos base para el resto de las operaciones primitivas.

El término \emph{sucesor} debe ser uno tal que al ser aplicado a un numeral \( \cn{n} \) se pueda \( β \)-reducir al numeral \( \cn{n+1} \). Considerando la definición de \( \cn{n} \synteq λx\, y.x^{n}\, y \), lo que buscamos es una manera de agregarle una \( x \) a la composición en el cuerpo de \( \cn{n} \) para obtener \( λx\, y.x^{n+1}\, y \). Se construye este término considerando primero que será aplicado a un numeral

\[ \mathrm{sucesor} \synteq λ\cn{n}.? \] 

Además el resultado de \( β \)-reducir esta aplicación deberá ser una función de dos argumentos (como lo son todos los numerales de Church):

\[ \mathrm{sucesor} \synteq λ\cn{n}.λx\, y.? \]

Tomando en cuenta que \( \cn{n}\, x\, y \synteq x^{n}\, y \) y que \( x\, x^{n} y \synteq x^{n+1}\, y \):

\[ \mathrm{sucesor} \synteq λn\, x\, y.x(n\, x\, y) \]

A continuación se \( β \)-reduce la aplicación de \( \mathrm{sucesor} \) al numeral \( \cn{4} \synteq λx\, y.x(x(x(x\, y))) \):

\begin{align*}
                & \mathrm{sucesor}\, \cn{4} \\
\synteq         & (λn\, x\, y.x(n\, x\, y)) (λx\, y.x(x(x(x\, y)))) \\
\convertible{α} & (λn\, x\, y.x(n\, x\, y)) (λf\, z.f(f(f(f\, z)))) \\
\contract{β}    & (λx\, y.x(((λf\, z.f (f (f (f\, z)))) x) y)) \\
\contract{β}    & (λx\, y.x((λz.x(x(x(x\, z)))) y)) \\
\contract{β}    & (λx\, y.x(x(x(x(x\, y))))) \\
\synteq         & \cn{5}
\end{align*}

La otra operación elemental en la aritmética es el \emph{predecesor}, el término que represente esta operación debe ser uno que cumpla con la siguiente definición:

\begin{align*}
\mathrm{predecesor}\, \cn{0} & \reduce{β} \cn{0} \\
\mathrm{predecesor}\, \cn{n} & \reduce{β} \cn{n-1}
\end{align*}

El término lambda del predecesor con la representación de numerales de Church es mucho mas compleja que la del sucesor. Se pudiera pensar que la misma idea utilizada en la derivación del sucesor aplicaría para la derivación del predecesor: si tenemos \( n \) aplicaciones de \( x \) a \( y \), al aplicar el término que buscamos a un numeral de Church se debe \( β \)-reducir a otro numeral con una aplicación de \( x \) menos, se utiliza \( y \) para añadir una \( x \) mas en el cuerpo del numeral. Sin embargo, la estructura de los numerales no nos permite quitar una \( x \) usando \( y \) facilmente ya que el numeral puede ser aplicado a dos términos, el que representa las \( x \) y el que representa a la \( y \); la variable que determina el valor del numeral es  \( x \) y la sustitución de \( x \) por otro término en esta representación se hace con \emph{cada} aparición de \( x \) en el cuerpo del numeral, por otro lado, al sustituír la \( y \) por otro término solo podemos hacer mas complejo el término o sustituírla por otra variable.

Para derivar el término del predecesor vamos a presentar un término con una estructura similar a los numerales de Church:

\[ λx\, y\, z.z\, x^{n}\, y \]

La diferencia entre este término y un numeral de Church es que podemos modificar su estructura por enfrente, por atrás y en las composiciones intermedias. Si este término representara \( \cn{n+1} \) pudieramos obtener el cuerpo de \( \cn{n} \) de la siguiente manera:

\begin{align*}
             & (λx\, y\, z.z\, x^{n}\, y) x\, y (λa.a) \\
\contract{β} & (((λy\, z.z\, x^{n}\, y) y) (λa.a)) \\
\reduce{β}   & ((λz.z\, x^{n}\, y) (λa.a)) \\
\contract{β} & (λa.a) x^{n}\, y \\
\contract{β} & x^{n}\, y
\end{align*}

Es decir, mantenemos las \( x \) y la \( y \) y le aplicamos a \( x^{n} y \) el término lambda que representa a la función identidad. Esta manera conveniente de representar a los numerales resulta ser incompleta, ya que no se podrá obtener \( x^{n-1} y \) a partir del resultado (ya que la \( z \) no aparece en el término resultante). Sin embargo, si logramos tener un término que nos genera este término modificado pudiéramos realizar esta transformación dentro de la función predecesor sería mas fácil encontrar \( \cn{n-1} \).

La estructura del sucesor sería:

\[ λn\, x\, y.?\, (λa.a) \]

Donde \( ? \) debe ser tal que al \( β \)-reducirse resulte en un término con la forma \( λz.z\, x^{n-1}\, y \). Es conveniente desmenuzar el problema de encontrar este término desconocido: primero sabemos que el numeral de Church \( \cn{n} \) puede ser aplicado a dos términos y el primer término al que sea aplicado se sustituirá en todas las apariciones de \( x \), como queremos que la \( β \)-reducción nos genere una función cuyo argumento sea la primer variable en la composición del numeral, tenemos que encontrar una manera de propagar un término de la forma \( λw.w\, x^{m}\, y \) de tal manera que al aplicarle otro término nos resulte \( λw.w\, x^{m+1}\, y \). De esta manera al aplicar este otro término una y otra vez, resulte \( λw.w\, x^{n-1}\, y \) con el cual podemos obtener el cuerpo del predecesor sustituyendo \( w \) por \( λa.a \).

Este otro término que buscamos será el que sustituirá a la \( x \) en \( \cn{n} \) para que:

\[ ?(λw.w\, x^{m}\, y) \reduce{β} λw.w\, x^{m+1}\, y \]

Lo que sucede en cada aplicación de este estilo es que se compone una \( x \) en cada aplicación y se deja explícita una \( w \) que podrá ser sustituída como valor. El término que nos permite hacer esto tiene la siguiente forma:

\[ λg\, w.w (g\, x) \]

Al ser aplicado a un término \( λw.w\, x^{m}\, y \) la variable \( g \) será sustituída por este término y el resultado será \( λw.w((λr.r\, x^{m}\, y) x) \) (nótese el cambio de nombre de la variable ligada \( w \) en el argumento), lo cual se reduce a \( λw.w\, x^{m+1}\, y \) el cual mantiene su estructura original.

El percance con esta aproximación a la solución es que el primer valor al que se le aplica el término \( λg\, w.w (g\, x) \) debe ser \( λw.w\, y \).

Para visualizar una manera de resolver el problema, es conveniente expresar cómo se verían las aplicaciones de \( λg\, w.w (g\, x) \) para un numeral de Church en particular. Si consideramos la aplicación de \( \cn{4}\, (λg\, w.w(g\, x)) \):

\begin{align*}
             & \cn{4} (λg\, w.w(g\, x)) \\
\synteq      & ( (λx\, y.x^{4}\, y) (λg.(λw.(w (g\, x)))) ) \\
\synteq      & ( (λx\, y.x(x(x(x\, y)))) (λg.(λw.(w (g\, x)))) ) \\
\contract{β} & (λy.(λg.(λw.(w (g\, x))))((λg.(λw.(w (g\, x))))((λg.(λw.(w (g\, x))))((λg.(λw.(w (g\, x)))) y))))
\end{align*}

Esto nos lleva al segundo paso para encontrar la función predecesor, en el desarrollo anterior notamos que la primer aplicación de \( λg\, w.w (g\, x) \) es en la variable \( y \) la cual está ligada por la \( λ \) del término. Sabemos que para obtener \( λw.w\, x^{3}\, y \) debemos \( β \)-reducir el término:

\[ ((λg.(λw.(w (g\, x)))) ((λg.(λw.(w (g\, x)))) ((λg.(λw.(w (g\, x)))) (λw.w\, y)))) \]

Con esto podemos encontrar el valor que tiene que tomar \( y \) en el numeral ya que:

\[ ((λg.(λw.(w (g\, x)))) y) \reduce{β} λw.w\, y \]

El término que buscamos es el que debe sustituír a la variable \( y \) en la reducción:

\begin{align*}
           & ((λg.(λw.(w (g\, x)))) ?) \\
\reduce{β} & (λw.(w (?\, x)))
\end{align*}

El término \( ? \) debe ser una función que al ser aplicada a \( x \) se reduzca a \( y \). El término \( λu.y \) cumple con esta propiedad y será el que utilizaremos.

Considerando los términos determinados en el procedimiento anterior, podemos decir cómo será la función predecesor. Primero se aplica \( (λg.(λw.(w (g\, x)))) \) a \( \cn{n} \), este término resultante se aplica a \( λu.y \), \( β \)-reducir esta aplicación nos resulta \( λw.w\, x^{n-1}\, y \) la cual puede ser aplicada a la función identidad \( λa.a \) para obtener \( x^{n-1}\, y \). Lo cual nos lleva al término completo de predecesor:

\[ (λn.(λx\, y.(((n (λg.(λw.(w (g\, x))))) (λu.y)) (λa.a)))) \]

Teniendo los términos lambda de sucesor y predecesor se puede abordar la derivación de operaciones mas complejas como la de adición, multiplicación, exponenciación y sustracción de numerales de Church siguiendo el mismo enfoque. En este trabajo no se abordan otras operaciones como la división debido al aumento de complejidad por no ser una operación interna, es decir, la división de dos naturales puede ser un racional y no se definió una representación de términos lambda para el conjunto de los racionales.

Un término lambda para la adición de dos numerales \( \cn{m} \) y \( \cn{n} \) es

\[ λm\, n.(λx\, y.n\, \mathrm{sucesor}\, m) \]

y se obtuvo a partir de la observación de que realizar la suma \( m+n \) es equivalente a computar el \( n \)-ésimo sucesor de \( m \).

Utilizando la estructura de \( \cn{n} \) podemos aplicar \( \cn{n}\, \mathrm{sucesor}\, \cn{m} \) para obtener la \( n \)-ésima composición de la función sucesor aplicada al numeral \( \cn{m} \):

\begin{align*}
             & \cn{n}\, \mathrm{sucesor}\, \cn{m} \\
\synteq      & (( (λx\, y.x^{n}\, y) \mathrm{sucesor}) (λx\, y.x^{m}\, y)) \\
\contract{β} & ( (λy.\mathrm{sucesor}^{n}\, y) (λx\, y.x^{m}\, y)) \\
\contract{β} & \mathrm{sucesor}^{n}\, λx\, y.x^{m}\, y \\
\reduce{β}   & λx\, y.x^{m+n}\, y \\
\synteq      & \cn{m+n}
\end{align*}

Un término lambda para la multiplicación de dos numerales de Church es

\[ λm\, n\, x\, y.n (m\, x) y \]

el cual aborda la idea de componer \( m\, n \) consigo mismo \( n \) veces (lo cual equivaldría a sumar \( n \) veces \( m \).

En el caso de la adición y la multiplicación, el orden en el que aplicamos el término a los numerales no es de importancia ya que son operaciones conmutativas, \( m+n = n+m \) y \( m \times n = n \times m \). Sin embargo en la sustracción y la exponenciación no se tiene esta propiedad, por lo que es importante el orden en el que se aplican los numerales a los términos, para ello consideraremos el orden como \( m-n \) y \( m^{n} \).

Basándonos en el término de la adición podemos obtener un término de la sustracción el cual es

\[ λm\, n\, x\, y.n\, \mathrm{predecesor}\, m \].

Ya que en la adición se dejó explícito el acto de aumentar \( m \) veces en 1 a \( n \), cambiamos el término de \( \mathrm{sucesor} \) por el de \( \mathrm{predecesor} \) y ahora se decrementa \( m \) veces en 1 a \( n \).

Un término lambda para la exponenciación es

\[ λm\, n.n\, m \]

es curioso tener una representación tan sencilla para una operación tan compleja como esta. A diferencia de los anteriores términos, al aplicarle a ésta exponenciación dos numerales, el numeral resultante tendrá las variables compuestas las variables que no se componen en las entradas, es decir, si \( \cn{m} \synteq λf\, g.f^{m}\, g \) y \( \cn{n} \synteq λx\, y.x^{n}\, y \), el resultado será \( \cn{m^{n}} \synteq λg\, y.g^{m^{n}}\, y \).

Para corroborar que estas representaciones calculan de manera correcta la operación correspondiente para los numerales de Church se pueden realizar varias pruebas con diferentes numerales de entrada. En este trabajo no se desarrollarán ejemplos para estos términos.

Los mecanismos que hemos utilizado para derivar las operaciones se basan en construír términos que vayan transformando entradas con una estructura determinada de tal manera que nos acerquemos poco a poco al cálculo de la operación deseada; esta labor llega a ser bastante tediosa y carece de interés algorítmico. A continuación se presenta una manera mas interesante y elegante de abordar el problema de representar operaciones aritméticas.

Se introduce el término lambda que me permite generar hiperoperaciones aritméticas:

\[ λf\, u\, m\, n.n (λw.f\, m\, w) u \]

Abstracción de la noción de repetición sobre la estructura de un numeral, considerar propiedades de conmutatividad y asociatividad en operaciones. Abordar el problema del cómputo de operaciones inversas. Determinar un término que nos genere elementos de la secuencia de hiperoperaciones.

\section{Procesos recursivos}
\label{sec:procesos-recursivos}

Combinador Y, ordenes de evaluación, funciones recursivas.

\[ \bs{Y} \synteq λf.(λx.f(x\, x))(λx.f(x\, x)) \]

{\center Derivación de \( \bs{Y} \)}
\begin{align}
  F &\synteq λn.\bs{\prec}\, (\bs{0^{?}}\, n) \cn{1} (\bs{\times}\, n (F (\bs{-}\, n\, \cn{1}))) \\
  F' &\synteq λf\, n.\bs{\prec}\, (\bs{0^{?}}\, n) \cn{1} (\bs{\times}\, n (f (\bs{-}\, n\, \cn{1})))\\
  F'' &\synteq λf'\, n.\bs{\prec}\, (\bs{0^{?}}\, n) \cn{1} (\bs{\times}\, n (f'\, f' (\bs{-}\, n\, \cn{1}))) \\
  C &\synteq λf''.f''\, f'' \\
  C\, F'' &\reduce{β} \text{ función factorial a partir de \( F'' \)} \\
  F''' &\synteq (λf'''.f' (f'''\, f''')) \\
  F'''\, F''' &\reduce{β} f'(F'''\, F''') \\
  C^{*} &\synteq λf'.(λf'''.f' (f'''\, f'''))(λf'''.f' (f'''\, f''')) \\
  C^{*}\, F' &\reduce{β} \text{ función factorial a partir de \( F' \)}
\end{align}

\[ Y \synteq C^{*} \]

Presentar una breve introducción sobre los combinadores y hablar del combinador \( \bs{Y} \) y cómo nos permite expresar funciones recursivas en el cálculo lambda.

Como ejemplos prácticos de esta subsección sería adecuado desarrollar el término para el cálculo de factoriales o algúna otra función de una sola variable que transforme un numeral de Church en otro. También pudiera expandir la recursividad a términos multivariables currificados como la función Ackermann (abstracción a la generación de hiperoperaciones, ver \emph{The Book of Numbers} de Conway).

\section{Pares ordenados}
\label{sec:pares-ordenados}

Construcción axiomática de pares ordenados, listas, \( n \)-tuplas, árboles y otras estructuras complejas.

Presentar la representación de pares ordenados para la construcción de estructuras mas complejas.

\[ \mathrm{Car}(\mathrm{Cons}(x,y)) = x \]

\[ \mathrm{Cdr}(\mathrm{Cons}(x,y)) = y \]

Esta sección es apropiada para comenzar a relacionar la teoría de autómatas, lenguajes regulares y libres de contexto con sistemas medianamente complejos que se pueden incrustar en el cálculo lambda sin modificar el sistema. Un problema pudiece ser el no determinismo, pero pudiera solventar esto con el desarrollo de operaciones funcionales sobre listas (map, filter, fold, etc).

\subsection*{Cambios en la metodología}

Expandir el concepto de valores de verdad al de pares ordenados

\subsubsection*{Constructor}

\begin{verbatim}
CreaPar (primero, segundo) =
    Elige (x) =
        Si x, entonces:
            primero
        De lo contrario:
            segundo
    Elige
\end{verbatim}

\begin{align*}
  \otimes & \synteq λa\, d.λx.B\, x\, a\, d \\
          & \contract{β} λa\, d.λx.x\, a\, d \\
          & \synteq λa\, d\, x.x\, a\, d
\end{align*}

\subsubsection*{Selectores}

\begin{verbatim}
Primero (Elige) =
    Elige(T)
\end{verbatim}

\begin{align*}
  \otimes_{1} & \synteq λx.x\, T
\end{align*}

\begin{verbatim}
Segundo (Elige) =
    Elige(F)
\end{verbatim}

\begin{align*}
  \otimes_{2} & \synteq λx.x\, F
\end{align*}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
