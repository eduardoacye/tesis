
\section{Álgebra Booleana}
\label{sec:algebra-booleana}

El álgebra booleana es una rama del álgebra en donde las expresiones tienen asociado un valor de \emph{falso} o \emph{verdadero}. Estas expresiones son fundamentales en el estudio de circuitos y programas escritos en lenguajes de programación.

Los términos lambda no tienen asignados un valor de verdad y las operaciones que se plantearon en los primeros dos capítulos involucraron el concepto de falso y verdadero únicamente en el metalenguaje y asociando estos valores no a los términos lambda en sí, si no a propiedades de estos, por ejemplo, es falso que \( \| λx.x \| = 5 \) y es verdadero que \( (\bs{K}\, x) \reduce{β} (λx.y) \). Sin embargo es posible codificar los valores de verdad como elementos de \( Λ \) y construir abstracciones que emulen las propiedades de las operaciones booleanas bajo la \( β \)-reducción. De esta manera se pueden escribir términos que, de acuerdo con la codificación establecida, representen expresiones booleanas y términos lambda al mismo tiempo.

En los lenguajes de programación usualmente se mezclan las expresiones booleanas con otras expresiones y objetos a partir de \emph{predicados}, éstos son funciones con algún dominio \( X \) y codominio \( \{ \mathrm{falso},\ \mathrm{verdadero} \} \). Por ejemplo, al escribir un programa en donde se necesite tomar una desición a partir de si un número \verb!n! es positivo o negativo se escribiría (en pseudocódigo):

\begin{verbatim}
Si esPositivo(n), entonces:
    ...
De lo contrario:
    ...
Fin
\end{verbatim}

En este ejemplo \verb!esPositivo! es un predicado que es evaluado a falso si \verb!n! no es positivo y a verdadero si lo es.

La codificación de valores de verdad y operaciones booleanas es común incluso en lenguajes de programación populares, por ejemplo en C, el tipo \verb!bool! es codificado como un entero, en donde falso es 0 y verdadero cualquier otro entero, a su vez, los enteros son codificados usualmente como secuencias de 32 bits en complemento a dos. Por lo tanto, si \verb!esPositivo! fuera una función de C: \verb!esPositivo(8)! sería evaluado a 1 y \verb!esPositivo(-8)! sería evaluado a 0.

Al igual que el cálculo lambda, otras teorías que fundamentan las ciencias de la computación también carecen de expresiones y operaciones booleanas. En el caso de la máquina de Turing los cambios de estado en la ejecución de un programa se determinan a partir de su función de transición y predicados simples de igualdad entre símbolos del alfabeto de cinta se realizan en un paso, sin embargo, predicados mas complejos requieren ser codificados con estados, transiciones y anotaciones en su cinta.

\subsection{Valores de verdad}
\label{sec:valores-de-verdad}

En el álgebra booleana, los valores de las expresiones son falso y verdadero. El nombre de estos valores no es de relevancia y usualmente falso se representa como 0 y verdadero como 1. El aspecto importante de estos valores es que son distintos y si un valor \( x \) no es uno, entonces es el otro.

Podemos ignorar la representación concreta de estos valores y pensar en una situación hipotética: Una persona omnisciente y muda llamada \( P \) puede decirme si una oración que le digo es falsa o verdadera dándole una manzana y una pera; si me regresa la manzana significa que la oración es verdadera y si me regresa la pera significa que la oración es falsa. En este planteamiento irreal e hipotético, no fué necesario conocer la estructura de la verdad y la falsedad, solo fué necesario tener a alguien que tomara una desición (en este caso \( P \)) y proveer dos objetos que podemos distinguir entre sí (en este caso la manzana y la pera). Las desiciones de esta persona pueden ser los conceptos de falso y verdadero si nunca podemos conocer los valores booleanos.

Detrás del concepto de falso y verdadero, está el concepto de \emph{desición}, la codificación que se desarrolla está basada en este concepto y aparece en \cite[p.~133]{Barendregt:Bible}.

Supongamos que \( P \) es un término lambda el cual puede ser aplicado a una oración \( O \), al \( β \)-reducir \( (P\, O) \) se obtiene una decisión \( D \) la cual al ser aplicada a dos términos lambda \( M \) y \( N \) se \( β \)-reduce a \( M \) si la oración \( O \) es verdadera y a \( M \) si es falsa:

\[ P\, O \reduce{β} D, \]
\[ D\, M\, N \reduce{β} \begin{cases} M & \text{si \( O \) es verdadera}\\ N & \text{si \( O \) es falsa}\end{cases} .\]

Para fines prácticos no es necesario saber cómo es \( P \) ni \( O \), lo importante es que cuando \( O \) es cierta, \( D \) eligirá \( M \) y si \( O \) es falsa, eligirá \( N \). Por lo tanto, \( (P\, O) = D \) es un término lambda de la forma

\[ λx\, y.Q \]

Si \( D \) es una desición tomada por que \( O \) es verdadera, podemos asegurar que \( (D\, M\, N) = M \), por lo tanto:

\[ D \synteq λx\, y.x \]

Si \( D \) es una desición tomada por que \( O \) es falsa, podemos asegurar que \( (D\, M\, N) = N \), por lo tanto:

\[ D \synteq λx\, y.y \]

Teniendo los términos lambda que representan la desición de \( P \) ante una oración falsa y ante una oración verdadera, se puede considerar que estos términos representan el concepto de falso y verdadero.

\begin{defn}[Valores de verdad]
  \label{defn:valores-verdad}
  El concepto de falso y verdadero es codificado en el cálculo lambda como los términos \( \bs{T} \) y \( \bs{F} \) respectivamente.
  \begin{align*}
    \bs{T} &\synteq λx\, y.x & \bs{F} &\synteq λx\, y.y
  \end{align*}
\end{defn}

Utilizar \( \bs{T} \) y \( \bs{F} \) en términos lambda es similar a imitar a \( P \) y determinar cuando \( O \) es verdadera o falsa. Esto es debido a que se pueden plantear predicados que sean conceptualmente ilógicos, por ejemplo, si \verb!esPositivo! se define de tal manera que sin importar en que valor sea evaluado siempre resulte en falso, los programas que se escriban no van a funcionar suponiendo que \verb!esPositivo! calcula lo que debe de calcular, sin embargo lo importante de codificar el álgebra booleana es poder manipular los valores de falso y verdadero, no representar un término \( P \) que determine verdades absolutas.

\subsection{Expresiones booleanas}

Las expresiones booleanas se conforman de operaciones y valores de verdad. Las operaciones más básicas son la conjunción, la disyunción y la negación, también llamadas \( AND \), \( OR \), \( NOT \) y denotadas \( \land \), \( \lor \) y \( \lnot \) respectivamente.

La conjunción y la disyunción son operaciones binarias definidas en

\[ \{ \mathrm{falso},\ \mathrm{verdadero} \}^{2} \to \{ \mathrm{falso},\ \mathrm{verdadero} \} \]

y la negación es una operación unaria definida en

\[ \{ \mathrm{falso},\ \mathrm{verdadero} \} \to \{ \mathrm{falso},\ \mathrm{verdadero} \}. \]

Las tablas de verdad en el cuadro \ref{tab:and-or-not} establecen los resultados de estas tres operaciones para cada valor en su dominio.

\begin{table}[h!]
  \centering
  \small
  \begin{tabular}{|c|c|c|c|}
    \hline
    \( x \) & \( y \) & \( x \land y \) & \( x \lor y \) \\ [0.5ex]
    \hline\hline
    falso & falso & falso & falso \\
    falso & verdadero & falso & verdadero \\
    verdadero & falso & falso & verdadero \\
    verdadero & verdadero & verdadero & verdadero \\
    \hline
  \end{tabular}
  \hfill
  \begin{tabular}{|c|c|}
    \hline
    \( x \) & \( \lnot x \) \\ [0.5ex]
    \hline\hline
    falso & verdadero  \\
    verdadero & falso \\
    \hline
  \end{tabular}
  \caption{Tablas de verdad para \( \land \), \( \lor \) y \( \lnot \)}
  \label{tab:and-or-not}
\end{table}

En el álgebra booleana, las expresiones se escriben en notación de infijo, utilizan paréntesis para agrupar expresiones y cuando los paréntesis son omitidos la negación tiene mayor presedencia que la conjunción y la conjunción tiene mayor presedencia que la disyunción, por ejemplo:

\[ \mathrm{verdadero} \land \mathrm{falso} \lor \lnot \mathrm{falso} \]
\[ \lnot (\mathrm{falso} \lor \mathrm{falso}) \]
\[ \mathrm{verdadero} \land (\mathrm{falso} \lor \mathrm{falso}) \]

Esta notación es conveniente para escribir expresiones booleanas de manera concisa, pero es únicamente una conveniencia sintáctica del álgebra booleana. La codificación que se desarrolla de las operaciones seguirá las convenciones sintácticas del cálculo lambda, por ejemplo, suponiendo que \( \bs{\land} \), \( \bs{\lor} \), \( \bs{\lnot} \) son términos lambda, las expresiones mencionadas escribirían con notación de prefijo:

\[ \bs{\lor} (\bs{\land}\, \bs{T}\, \bs{F}) \bs{F} \]
\[ \bs{\lnot} (\bs{\lor}\, \bs{F}\, \bs{F}) \]
\[ \bs{\land}\, \bs{T} (\bs{\lor}\, \bs{F}\, \bs{F}) \]

Al igual que los valores de verdad, las operaciones básicas son codificadas como abstracciones del cálculo lambda. Hay varias metodologías para derivar términos lambda para las operaciones booleanas a partir de \( \bs{T} \) y \( \bs{F} \), en esta sección se abordarán dos:

\begin{itemize}
\item Combinando valores de verdad
\item Programando las operaciones
\end{itemize}

La primer metodología parte de la observación de que la codificación de falso y verdadero son abstracciones, por lo tanto, es posible \( β \)-reducirlas al aplicarlas a otros términos; se explora la clase de términos lambda en \( \{ \bs{T},\ \bs{F} \}^{+} \).

La segunda metodología presenta la construcción del operador condicional, a partir del cual se derivan las operaciones booleanas como si fueran programas de computadora.

\subsubsection{Combinaciones de valores de verdad}
\label{sec:combinacion-valores}

Una manera de obtener términos lambda a partir de \( \bs{F} \) y \( \bs{T} \) es \( β \)-reducir combinaciones de aplicaciones entre estos valores. En el cuadro \ref{tab:verdad-pares} se muestran los términos obtenidos al reducir combinaciones de dos valores de verdad.

\begin{table}[h!]
  \centering
  \begin{tabular}{|c||l|}
    \hline
    \( \bs{F}\, \bs{F} \) & \( (λx\, y.y)\bs{F} \reduce{β} λy.y \synteq \bs{I} \) \\
    \hline
    \( \bs{F}\, \bs{T} \) & \( (λx\, y.y)\bs{T} \reduce{β} λy.y \synteq \bs{I} \) \\
    \hline
    \( \bs{T}\, \bs{F} \) & \( (λx\, y.x)\bs{F} \reduce{β} λy.\bs{F} \synteq \bs{K}\, \bs{F} \) \\
    \hline
    \( \bs{T}\, \bs{T} \) & \( (λx\, y.x)\bs{T} \reduce{β} λy.\bs{T} \synteq \bs{K}\, \bs{T} \) \\
    \hline
  \end{tabular}
  \caption{Posibles combinaciones de valores de verdad por pares.}
  \label{tab:verdad-pares}
\end{table}

En las reducciones de \ref{tab:verdad-pares} se pueden observar cuatro términos, a partir de estos se puede descubrir la operación de negación:

\begin{itemize}
\item \( (\bs{F}\, \bs{F}) \) se reduce a la abstracción identidad, esto significa que para cualquier término \( M \in Λ \)
  \[ \bs{λ} \vdash (\bs{F}\, \bs{F}\, M) = M \]
\item Al igual que la primer reducción \( (\bs{F}\, \bs{T}) \) se reduce a \( \bs{I} \), por lo tanto se concluye que para cualesquiera términos \( M \in Λ \), \( N \in \{ \bs{F},\ \bs{T} \} \)
  \[ \bs{λ} \vdash (\bs{F}\, N\, M) = M \]
\item \( (\bs{T}\, \bs{F}) \) se reduce a la abstracción constante de \( \bs{F} \), esto significa que para cualquier término \( M \in Λ \)
  \[ \bs{λ} \vdash (\bs{T}\, \bs{F}\, M) = \bs{F} \]
\item Al igual que la tercer reducción \( (\bs{T}\, \bs{T}) \) se reduce a \( (\bs{K}\, \bs{T}) \), por lo tanto se concluye que para cualesquiera términos \( M \in Λ \), \( N \in \{ \bs{F},\ \bs{T} \} \)
  \[ \bs{λ} \vdash (\bs{T}\, N\, M) = N \]
\end{itemize}

Debido a las reducciones mostradas en el cuadro \ref{tab:verdad-pares} se puede analizar que a partir de un témino \( \bs{F} \), se puede obtener \( \bs{T} \) al reducir \( (\bs{F}\, N\, \bs{T}) \) y que a partir de un término \( \bs{T} \), se puede obtener \( \bs{F} \) al reducir \( (\bs{T}\, \bs{F}\, M) \). Considerando que \( N \synteq \bs{F} \) y \( M \synteq \bs{T} \) las reducciones serían:

\[ \bs{F}\, \bs{F}\, \bs{T} \reduce{β} \bs{T} \]
\[ \bs{T}\, \bs{F}\, \bs{T} \reduce{β} \bs{F} \]

Si se considera que \( P \in \{ \bs{F},\ \bs{T} \} \)

\[ P\, \bs{F}\, \bs{T} \reduce{β} \bs{\lnot}\, P \]

\begin{rem}[Sobre la \( β \)-reducción]
  En el tratamiento de la codificación del álgebra booleana en el cálculo lambda, cuando se \( β \)-reducen términos lambda que tienen como subtérminos valores que suponemos son \( \bs{F} \) o \( \bs{T} \) se extiende la teoría \( \bs{λ} \) con la siguiente ecuación:

  \begin{align*}
    P\, \bs{T}\, \bs{F} &= P && \text{si \( P \in \{ \bs{F},\ \bs{T} \} \)}
  \end{align*}
\end{rem}

\begin{defn}[Operación de negación]
  \label{defn:negacion}
  El término lambda \( \bs{\lnot} \synteq (λp.p\, \bs{F}\, \bs{T}) \) se reduce a \( \bs{T} \) cuando es aplicado a \( \bs{F} \) y viceversa

  \begin{align*}
    \bs{\lnot}\, \bs{F} &\synteq (λp.p\, \bs{F}\, \bs{T}) \bs{F} \\
                        &\contract{β} \bs{F}\, \bs{F}\, \bs{T} \\
                        &\reduce{β} \bs{T}
  \end{align*}
  \begin{align*}
    \bs{\lnot}\, \bs{T} &\synteq (λp.p\, \bs{F}\, \bs{T}) \bs{T} \\
                        &\contract{β} \bs{T}\, \bs{F}\, \bs{T} \\
                        &\reduce{β} \bs{F}
  \end{align*}
\end{defn}

Las reducciones del cuadro \ref{tab:verdad-pares} se pueden aplicar a \( \bs{F} \) y \( \bs{T} \) para obtener todas las posibles combinaciones de aplicaciones de valores de verdad de la forma \( ((P\, M) N) \), en el cuadro \ref{tab:verdad-tripletas} se muestran las reducciones de las nuevas aplicaciones.

\begin{table}[h!]
  \centering
  \begin{tabular}{|c||l|}
    \hline
    \( \bs{F}\, \bs{F}\, \bs{F} \) & \( \bs{I}\, \bs{F} \reduce{β} \bs{F} \) \\
    \hline
    \( \bs{F}\, \bs{F}\, \bs{T} \) & \( \bs{I}\, \bs{T} \reduce{β} \bs{T} \) \\
    \hline
    \( \bs{F}\, \bs{T}\, \bs{F} \) & \( \bs{I}\, \bs{F} \reduce{β} \bs{F} \) \\
    \hline
    \( \bs{F}\, \bs{T}\, \bs{T} \) & \( \bs{I}\, \bs{T} \reduce{β} \bs{T} \) \\
    \hline
    \( \bs{T}\, \bs{F}\, \bs{F} \) & \( \bs{K}\, \bs{F}\, \bs{F} \reduce{β} \bs{F} \) \\
    \hline
    \( \bs{T}\, \bs{F}\, \bs{T} \) & \( \bs{K}\, \bs{F}\, \bs{T} \reduce{β} \bs{F} \) \\
    \hline
    \( \bs{T}\, \bs{T}\, \bs{F} \) & \( \bs{K}\, \bs{T}\, \bs{F} \reduce{β} \bs{T} \) \\
    \hline
    \( \bs{T}\, \bs{T}\, \bs{T} \) & \( \bs{K}\, \bs{T}\, \bs{T} \reduce{β} \bs{T} \) \\
    \hline
  \end{tabular}
  \caption{Posibles combinaciones de valores de verdad con asociación a la izquierda.}
  \label{tab:verdad-tripletas}
\end{table}

Al observar el cuadro \ref{tab:verdad-tripletas}, se distinguen algúnos patrones en los resultados de las reducciones, por ejemplo, si \( P \) es un valor de verdad cualquiera, \( (P\, \bs{F}\, \bs{F}) \) se reduce a \( \bs{F} \) y \( (P\, \bs{T}\, \bs{T}) \) se reduce a \( \bs{T} \), las combinaciones mas interesantes se presentan en los renglones 2, 3, 6 y 7.

En búsqueda de las operaciones binarias de conjunción y disyunción se desarrollan tablas de verdad con las posibles combinaciones de dos términos \( P, Q \in \{ \bs{F},\ \bs{T} \} \). La cantidad de combinaciones de estos valores es \( 2 \times \binom 3 2 = 2 \times \frac{3!}{2!} = 6 \) y son \( (P\, Q\, \bs{F}) ,\ (P\, Q\, \bs{T}) ,\ (P\, \bs{F}\, Q) ,\ (P\, \bs{T}\, Q) ,\ (\bs{F}\, P\, Q) ,\ (\bs{T}\, P\, Q) \). Las tablas de verdad de estas combinaciones intercambiando las posiciones de \( P \) y \( Q \) serían las mismas ya que ambos términos toman los valores de falso y verdadero en las tablas de verdad. En el cuadro \ref{tab:verdad-pq} se muestran estas tablas.

\begin{table}[h!]
  \centering
  \begin{tabular}{|c|c||c|c|c|c|c|c|}
    \hline
    \( P \) & \( Q \) & \( P\, Q\, \bs{F} \) & \( P\, Q\, \bs{T} \) & \( P\, \bs{F}\, Q \) & \( P\, \bs{T}\, Q \) & \( \bs{F}\, P\, Q \) & \( \bs{T}\, P\, Q \) \\ [0.5ex]
    \hline
    \hline
    \( \bs{F} \) & \( \bs{F} \) & \( \bs{F} \) & \( \bs{T} \) & \( \bs{F} \) & \( \bs{F} \) & \( \bs{F} \) & \( \bs{F} \) \\
    \( \bs{F} \) & \( \bs{T} \) & \( \bs{F} \) & \( \bs{T} \) & \( \bs{T} \) & \( \bs{T} \) & \( \bs{T} \) & \( \bs{F} \) \\
    \( \bs{T} \) & \( \bs{F} \) & \( \bs{F} \) & \( \bs{F} \) & \( \bs{F} \) & \( \bs{T} \) & \( \bs{F} \) & \( \bs{T} \) \\
    \( \bs{T} \) & \( \bs{T} \) & \( \bs{T} \) & \( \bs{T} \) & \( \bs{F} \) & \( \bs{T} \) & \( \bs{T} \) & \( \bs{T} \) \\
    \hline
  \end{tabular}
  \caption{Tablas de verdad considerando dos variables \( P \) y \( Q \) en aplicaciones de tres términos}
  \label{tab:verdad-pq}
\end{table}

Las columnas de la combinación \( (P\, Q\, \bs{F}) \) y \( (P\, \bs{T}\, Q) \) del cuadro \ref{tab:verdad-pq} corresponden a la operación de conjunción y disyunción respectivamente, como aparecen en el cuadro \ref{tab:and-or-not}. Las otras combinaciones corresponden a operaciones no básicas del álgebra booleana: \( (P\, Q\, \bs{T}) \) es la implicación material; \( (P\, \bs{F}\, Q) \) es la no implicación inversa; \( (\bs{F}\, P\, Q) \) es la proyección de \( Q \); y \( (\bs{T}\, P\, Q) \) es la proyección de \( P \).

Ya que  \( \bs{λ} \vdash (P\, Q\, \bs{F}) = (\bs{\land}\, P\, Q) \) y \( \bs{λ} \vdash (P\, \bs{T}\, Q) = (\bs{\lor}\, P\, Q) \), se construyen los términos \( \bs{\land} \) y \( \bs{\lor} \) abstrayendo a \( P \) y \( Q \) de las igualdades.

\begin{defn}[Operación de conjunción]
  \label{defn:conjuncion}
  El término lambda que representa la conjunción es

  \[ \bs{\land} \synteq λp\, q.p\, q\, \bs{F} \]

  y cumple las siguientes propiedades de \( β \)-reducción al ser aplicada a valores de verdad:

  \begin{align*}
    \bs{\land}\, \bs{F}\, \bs{F} &\synteq (λp\, q.p\, q\, \bs{F}) \bs{F}\, \bs{F} \\
                                 &\reduce{β} \bs{F}\, \bs{F}\, \bs{F} \\
                                 &\reduce{β} \bs{F}
  \end{align*}

  \begin{align*}
    \bs{\land}\, \bs{F}\, \bs{T} &\synteq (λp\, q.p\, q\, \bs{F}) \bs{F}\, \bs{T} \\
                                 &\reduce{β} \bs{F}\, \bs{T}\, \bs{F} \\
                                 &\reduce{β} \bs{F}
  \end{align*}

  \begin{align*}
    \bs{\land}\, \bs{T}\, \bs{F} &\synteq (λp\, q.p\, q\, \bs{F}) \bs{T}\, \bs{F} \\
                                 &\reduce{β} \bs{T}\, \bs{F}\, \bs{F} \\
                                 &\reduce{β} \bs{F}
  \end{align*}

  \begin{align*}
    \bs{\land}\, \bs{T}\, \bs{T} &\synteq (λp\, q.p\, q\, \bs{F}) \bs{T}\, \bs{T} \\
                                 &\reduce{β} \bs{T}\, \bs{T}\, \bs{F} \\
                                 &\reduce{β} \bs{T}
  \end{align*}
\end{defn}

\begin{defn}[Operación de disyunción]
  \label{defn:disyuncion}
  El término lambda que representa la disyunción es

  \[ \bs{\lor} \synteq λp\, q.p\, \bs{T}\, q \]

  y cumple las siguientes propiedades de \( β \)-reducción al ser aplicada a valores de verdad:

  \begin{align*}
    \bs{\lor}\, \bs{F}\, \bs{F} &\synteq (λp\, q.p\, \bs{T}\, q) \bs{F}\, \bs{F} \\
                                &\reduce{β} \bs{F}\, \bs{T}\, \bs{F} \\
                                &\reduce{β} \bs{F}
  \end{align*}

  \begin{align*}
    \bs{\lor}\, \bs{F}\, \bs{T} &\synteq (λp\, q.p\, \bs{T}\, q) \bs{F}\, \bs{T} \\
                                &\reduce{β} \bs{F}\, \bs{T}\, \bs{T} \\
                                &\reduce{β} \bs{T}
  \end{align*}

  \begin{align*}
    \bs{\lor}\, \bs{T}\, \bs{F} &\synteq (λp\, q.p\, \bs{T}\, q) \bs{T}\, \bs{F} \\
                                &\reduce{β} \bs{T}\, \bs{T}\, \bs{F} \\
                                &\reduce{β} \bs{T}
  \end{align*}

  \begin{align*}
    \bs{\lor}\, \bs{T}\, \bs{T} &\synteq (λp\, q.p\, \bs{T}\, q) \bs{T}\, \bs{T} \\
                                &\reduce{β} \bs{T}\, \bs{T}\, \bs{T} \\
                                &\reduce{β} \bs{T}
  \end{align*}
\end{defn}

Esta metodología para encontrar operaciones del álgebra booleana, aplicando los términos codificados de los valores de verdad, es tediosa pero hasta cierto grado efectiva. Como en los casos de las operaciones no básicas mostradas en el cuadro \ref{tab:verdad-pq}, operaciones del álgebra booleana pueden ser ``descubiertas'' y no construídas. Ya que la negación, la conjunción y la disyunción fueron descubiertas con este método, cualquier operación booleana eventualmente será encontrada como combinación de valores de verdad. Sin embargo, descubrir la codificación de una operación booleana complicada utilizando este método es un proceso muy tardado.

\subsubsection{Programación de operaciones booleanas}
\label{sec:programacion-operaciones}

Otra metodología que permite construír las operaciones booleanas como términos lambda es la de partir de un algorítmo que las describa. Usualmente las operaciones booleanas no son definidas como procedimientos, si no como operaciones primitivas del lenguaje utilizado para describirlos.

Consideremos dos términos \( M \) y \( N \). Ya que \( (\bs{T}\, M\, N) \reduce{β} M \) y \( (\bs{F}\, M\, N) \reduce{β} N \), si \( M \reduce{β} M' \) y \( N \reduce{β} N' \), entonces

\[ \bs{T}\, M\, N \reduce{β} M' \]

\[ \bs{F}\, M\, N \reduce{β} N' \]

Es decir, si \( P \in \{ \bs{F},\ \bs{T} \} \):

\[ P\, M\, N \reduce{β} \begin{cases} M' & P \synteq \bs{T} \\ N' & P \synteq \bs{F} \end{cases} \]

Esta aplicación de un valor de verdad a dos términos lambda cualquiera permite capturar el concepto de una expresión o sentencia condicional, usualmente llamada en los lenguajes de programación como sentencia \verb!if-then-else!.

\begin{defn}[Expresión condicional]
  \label{defn:condicional}
  El término lambda que representa a la expresión condicional es

  \[ \bs{\prec} \synteq λp\, m\, n.p\, m\, n \]

  Y si \( P \) es un valor de verdad, entonces

  \begin{align*}
    \bs{\prec}\, P\, M\, N &\synteq (λp\, m\, n.p\, m\, n)P\, M\, N \\
                           &\reduce{β} P\, M\, N
  \end{align*}

  Un programa de la forma

\begin{verbatim}
Si P, entonces:
    M
De lo contrario:
    N
Fin
\end{verbatim}

  Puede ser traducido a \( (\bs{\prec}\, P\, M\, N) \)
\end{defn}

Consideremos la siguiente definición en pseudocódigo de la operación de negación:

\begin{verbatim}
Negacion (predicado) :=
    Si predicado, entonces:
        Regresa Falso
    De lo contrario:
        Regresa Verdadero
    Fin
Fin
\end{verbatim}

El pseudocódigo se traduce al cálculo lambda como

\[ \bs{\lnot} \synteq λp.\bs{\prec}\, p\, \bs{F}\, \bs{T} \]

El cuerpo de la abstracción puede ser \( β \)-reducido para obtener el término de la definición \ref{defn:negacion}

\begin{align*}
  λp.\bs{\prec}\, p\, \bs{F}\, \bs{T} &\synteq λp.(λp\, m\, n.p\, m\, n) p\, \bs{F}\, \bs{T} \\
                                      &\reduce{β} λp.p\, \bs{F}\, \bs{T}
\end{align*}

Para la operación de conjunción, se considera el siguiente pseudocódigo:

\begin{verbatim}
Conjuncion (predicado1, predicado2) :=
    Si predicado1, entonces:
        Si predicado2, entonces:
            Regresa Verdadero
        De lo contrario:
            Regresa Falso
        Fin
    De lo contrario:
        Regresa Falso
    Fin
Fin
\end{verbatim}

Traducido al cálculo lambda como

\[ \bs{\land} \synteq λp_{1}\, p_{2}.\bs{\prec}\, p_{1} (\bs{\prec}\, p_{2}\, \bs{T}\, \bs{F}) \bs{F} \]

Al \( β \)-reducir el cuerpo de la abstracción se obtiene el término de la definición \ref{defn:conjuncion}

\begin{align*}
  λp_{1}\, p_{2}.\bs{\prec}\, p_{1} (\bs{\prec}\, p_{2}\, \bs{T}\, \bs{F}) \bs{F}
  &\synteq λp_{1}\, p_{2}.(λp\, m\, n.p\, m\, n) p_{1} ((λp\, m\, n.p\, m\, n) p_{2}\, \bs{T}\, \bs{F}) \bs{F} \\
  &\reduce{β} λp_{1}\, p_{2}.p_{1} ((λp\, m\, n.p\, m\, n) p_{2}\, \bs{T}\, \bs{F}) \bs{F} \\
  &\reduce{β} λp_{1}\, p_{2}.p_{1} (p_{2}\, \bs{T}\, \bs{F}) \bs{F} \\
  &=_{\bs{λ}} λp_{1}\, p_{2}.p_{1}\, p_{2}\, \bs{F}
\end{align*}

De igual manera, considerando el siguiente pseudocódigo de la operación de disyunción:

\begin{verbatim}
Disyuncion (predicado1, predicado2) :=
    Si predicado1, entonces:
        Regresa Verdadero
    De lo contrario:
        Si predicado2, entonces:
            Regresa Verdadero
        De lo contrario:
            Regresa Falso
        Fin
    Fin
Fin
\end{verbatim}

Se traduce al cálculo lambda como

\[ \bs{\lor} \synteq λp_{1}\, p_{2}.\bs{\prec}\, p_{1}\, \bs{T} (\bs{\prec}\, p_{2}\, \bs{T}\, \bs{F}) \]

Y al \( β \)-reducir el cuerpo de la abstracción se obtiene el término de la definición \ref{defn:disyuncion}

\begin{align*}
  λp_{1}\, p_{2}.\bs{\prec}\, p_{1}\, \bs{T} (\bs{\prec}\, p_{2}\, \bs{T}\, \bs{F})
  &\synteq λp_{1}\, p_{2}.(λp\, m\, n.p\, m\, n) p_{1}\, \bs{T} ((λp\, m\, n.p\, m\, n) p_{2}\, \bs{T}\, \bs{F}) \\
  &\reduce{β} λp_{1}\, p_{2}.p_{1}\, \bs{T} ((λp\, m\, n.p\, m\, n) p_{2}\, \bs{T}\, \bs{F}) \\
  &\reduce{β} λp_{1}\, p_{2}.p_{1}\, \bs{T} (p_{2}\, \bs{T}\, \bs{F}) \\
  &=_{\bs{λ}} λp_{1}\, p_{2}.p_{1}\, \bs{T}\, p_{2}
\end{align*}

Utilizando esta técnica, se puede obtener el término lambda para una operación a partir del pseudocódigo basado en valores de verdad y la sentencia \verb!if-then-else!. Teniendo estos resultados resulta natural, generalizar el pseudocódigo para construír un término lambda que a partir de la tabla de verdad de una operación booleana binaria, resulte en la abstracción que codifica la operación.


\begin{defn}[Traducción de operaciones booleanas binarias]
  \label{defn:op-bool-bin-lambda}
  Sea \( \bs{\odot} \) una operación booleana binaria con la siguiente tabla de verdad

  \begin{center}
    \begin{tabular}{|c|c||c|}
      \hline
      \( P \) & \( Q \) & \( P \bs{\odot} Q \) \\ [0.5ex]
      \hline\hline
      \( \bs{F} \) & \( \bs{F} \) & \( x_{1} \) \\
      \hline
      \( \bs{F} \) & \( \bs{T} \) & \( x_{2} \) \\
      \hline
      \( \bs{T} \) & \( \bs{F} \) & \( x_{3} \) \\
      \hline
      \( \bs{T} \) & \( \bs{T} \) & \( x_{4} \) \\
      \hline
    \end{tabular}
  \end{center}

  El procedimiento generalizado es

\begin{verbatim}
OperacionBooleana(x1, x2, x3, x4) :=
    Binaria(predicado1, predicado2) :=
        Si predicado1, entonces:
            Si predicado2, entonces:
                Regresa x4
            De lo contrario:
                Regresa x3
            Fin
        De lo contrario:
            Si predicado2, entonces:
                Regresa x2
            De lo contrario:
                Regresa x1
            Fin
        Fin
    Fin
    Regresa Binaria
Fin
\end{verbatim}

  Y la traducción al cálculo lambda es

  \[ λx_{1}\, x_{2}\, x_{3}\, x_{4}.(λp_{1}\, p_{2}.(\bs{\prec}\, p_{1} (\bs{\prec}\, p_{2}\, x_{4}\, x_{3}) (\bs{\prec}\, p_{2}\, x_{2}\, x_{1}))) \]
  
\end{defn}

\begin{exmp}[Operaciones \emph{NAND} y \emph{NOR}]
  \label{ejmp:nand-nor}
  Estas operaciones booleanas binarias conforman los conjuntos unitarios \( \{ \mathrm{NAND} \} \) y \( \{ \mathrm{NOR} \} \) los cuales son conjuntos funcionalmene completos, es decir, únicamente con la operación NAND se puede emular cualquier operación booleana y únicamente con la operación NOR se puede emular cualquier operación booleana.

  
  La operación \emph{NAND} se denota \( P \uparrow Q \) y tiene la siguiente tabla de verdad

  \begin{center}
    \begin{tabular}{|c|c||c|}
      \hline
      \( P \) & \( Q \) & \( P \uparrow Q \) \\ [0.5ex]
      \hline\hline
      \( \bs{F} \) & \( \bs{F} \) & \( \bs{T} \) \\
      \hline
      \( \bs{F} \) & \( \bs{T} \) & \( \bs{T} \) \\
      \hline
      \( \bs{T} \) & \( \bs{F} \) & \( \bs{T} \) \\
      \hline
      \( \bs{T} \) & \( \bs{T} \) & \( \bs{F} \) \\
      \hline
    \end{tabular}
  \end{center}

  Con el proceso de traducción mostrado en la definición \ref{defn:op-bool-bin-lambda}, el término lambda \( \bs{\uparrow} \) que codifica la operación NAND sería
  
  \begin{align*}
    \bs{\uparrow}
    &\synteq λp_{1}\, p_{2}. \bs{\prec}\, p_{1} (\bs{\prec}\, p_{2}\, \bs{F}\, \bs{T}) (\bs{\prec}\, p_{2}\, \bs{T}\, \bs{T}) \\
    &\reduce{β} λp_{1}\, p_{2}.p_{1} (p_{2}\, \bs{F}\, \bs{T}) \bs{T}
  \end{align*}

  La operación \emph{NOR} se denota \( P \downarrow Q \) y tiene la siguiente tabla de verdad

  \begin{center}
    \begin{tabular}{|c|c||c|}
      \hline
      \( P \) & \( Q \) & \( P \downarrow Q \) \\ [0.5ex]
      \hline\hline
      \( \bs{F} \) & \( \bs{F} \) & \( \bs{T} \) \\
      \hline
      \( \bs{F} \) & \( \bs{T} \) & \( \bs{F} \) \\
      \hline
      \( \bs{T} \) & \( \bs{F} \) & \( \bs{F} \) \\
      \hline
      \( \bs{T} \) & \( \bs{T} \) & \( \bs{F} \) \\
      \hline
    \end{tabular}
  \end{center}

  Usando el mismo proceso de traducción que con la operación NAND, se obtiene

  \begin{align*}
    \bs{\downarrow}
    &\synteq λp_{1}\, p_{2}. \bs{\prec}\, p_{1} (\bs{\prec}\, p_{2}\, \bs{F}\, \bs{F}) (\bs{\prec}\, p_{2}\, \bs{F}\, \bs{T}) \\
    &\reduce{β} λp_{1}\, p_{2}.p_{1}\, \bs{F} (p_{2}\, \bs{F}\, \bs{T})
  \end{align*}

\end{exmp}

Cuando se generaliza el método de traducción de \ref{defn:op-bool-bin-lambda} a operaciones booleanas \( n \)-árias, se obtiene un término bosquejado de la siguiente manera

\begin{center}
  \begin{tikzpicture}[level/.style={sibling distance=100mm/#1, level distance=10mm}]
    \node (args1) {\( λx_{1}\, ...\, x_{2^{n}} \)}
    child {
      node (args2) {\( λp_{1}\, ...\, p_{n} \)}
      child {
        node (p1) {\( \bs{\prec}\, p_{1} \)}
        child {
          node (p2a) {\( \bs{\prec}\, p_{2} \)}
          child {
            node (dots1) {\( ... \)}
            child {
              node (pna) {\( \bs{\prec}\, p_{n} \)}
              child {
                node (x2n) {\( x_{2^{n}} \)}
              }
              child {
                node (x2n1) {\( x_{2^{n}-1} \)}
              }
            }
            child {
              node (dots3) {\( ... \)}
            }
          }
          child {
            node (dots2) {\( ... \)}
          }
        }
        child {
          node (p2b) {\( \bs{\prec}\, p_{2} \)}
          child {
            node (dots4) {\( ... \)}
          }
          child {
            node (dots5) {\( ... \)}
            child {
              node (dots6) {\( ... \)}
            }
            child {
              node (pnb) {\( \bs{\prec}\, p_{n} \)}
              child {
                node (x2) {\( x_{2} \)}
              }
              child {
                node (x1) {\( x_{1} \)}
              }
            }
          }
        }
      }
    };
  \end{tikzpicture}
\end{center}

\subsection{Extensiones al álgebra booleana}
\label{sec:boolean-extensiones}

Conociendo el proceso de codificación del álgebra booleana en el cálculo lambda, resulta simple adaptar la codificación.

Consideremos el caso en donde, además de tener los valores de falso y verdadero, se desea incorporar un valor ``desconocido'' utilizado para representar un valor que no es ni falso, ni verdadero. La interpretación de estos valores es similar a \ref{defn:valores-verdad}, pero en lugar de decidir sobre dos términos, se decide sobre tres.

\begin{defn}[Valores de álgebra trivalente]
  La codificación en términos lambda de los valores de ésta álgebra trivalente son

  \begin{align*}
    \bs{T} &\synteq λx\, y\, z.x \\
    \bs{F} &\synteq λx\, y\, z.y \\
    \bs{U} &\synteq λx\, y\, z.z 
  \end{align*}
\end{defn}

Al igual que en la codificación bivalente, se puede codificar un término \( \bs{\prec_{3}} \), similar a \( \bs{\prec} \) de la definición \ref{defn:condicional} pero con tres ramificaciones

\begin{defn}[Condicional trivalente]
  \[ \bs{\prec_{3}} \synteq λp\, m\, n\, o.p\, m\, n\, o \]

  De tal manera que, si \( P \in \{ \bs{T},\ \bs{F},\ \bs{U} \} \)

  \[ (\bs{\prec_{3}}\, P\, M\, N\, O) \reduce{β} \begin{cases} M & P \synteq \bs{T}; \\ N & P \synteq \bs{F}; \\ O & P \synteq \bs{U}. \end{cases} \]
\end{defn}

Sea \( \odot \) una operación trivalente binaria con la siguiente tabla de valores

\begin{center}
  \begin{tabular}{|c|c||c|}
    \hline
    \( P \) & \( Q \) & \( P \odot Q \) \\ [0.5ex] \hline\hline
    \( \bs{T} \) & \( \bs{T} \) & \( x_{1} \) \\ \hline
    \( \bs{T} \) & \( \bs{F} \) & \( x_{2} \) \\ \hline
    \( \bs{T} \) & \( \bs{U} \) & \( x_{3} \) \\ \hline
    \( \bs{F} \) & \( \bs{T} \) & \( x_{4} \) \\ \hline
    \( \bs{F} \) & \( \bs{F} \) & \( x_{5} \) \\ \hline
    \( \bs{F} \) & \( \bs{U} \) & \( x_{6} \) \\ \hline
    \( \bs{U} \) & \( \bs{T} \) & \( x_{7} \) \\ \hline
    \( \bs{U} \) & \( \bs{F} \) & \( x_{8} \) \\ \hline
    \( \bs{U} \) & \( \bs{U} \) & \( x_{9} \) \\ \hline
  \end{tabular}
\end{center}

El procedimiento en pseudocódigo que la describe es:

\begin{verbatim}
OperacionTrivalente(x1, x2, x3, x4, x5, x6, x7, x8, x9) :=
    Binaria(predicado1, predicado2) :=
        Si predicado1 es verdadero, entonces:
            Si predicado2 es verdadero, entonces:
                Regresa x1
            Si predicado2 es falso, entonces:
                Regresa x2
            Si predicado2 es desconocido, entonces:
                Regresa x3
            Fin
        Si predicado1 es falso, entonces:
            Si predicado2 es verdadero, entonces:
                Regresa x4
            Si predicado2 es falso, entonces:
                Regresa x5
            Si predicado2 es desconocido, entonces:
                Regresa x6
            Fin
        Si predicado1 es desconocido, entonces:
            Si predicado2 es verdadero, entonces:
                Regresa x7
            Si predicado2 es falso, entonces:
                Regresa x8
            Si predicado2 es desconocido, entonces:
                Regresa x9
            Fin
        Fin
    Fin
    Regresa Binaria
Fin
\end{verbatim}

Traducido al cálculo lambda como

\[ λx_{1}\, x_{2}\, x_{3}\, x_{4}\, x_{5}\, x_{6}\, x_{7}\, x_{8}\, x_{9}.(λp_{1}\, p_{2}.(\bs{\prec_{3}}\, p_{1}\, R_{1}\, R_{2}\, R_{3})) \]

Donde

\begin{align*}
  R_{1} &\synteq (\bs{\prec_{3}}\, p_{2}\, x_{1}\, x_{2}\, x_{3}) \\
  R_{2} &\synteq (\bs{\prec_{3}}\,  p_{2}\, x_{4}\, x_{5}\, x_{6}) \\
  R_{3} &\synteq (\bs{\prec_{3}}\, p_{2}\, x_{7}\, x_{8}\, x_{9})
\end{align*}

\subsection{Lógica en el cálculo lambda}
\label{sec:logica-lambda}

En esta sección se abordó la codificación de valores de verdad y operaciones como la conjunción, disyunción y negación. Usualmente en las ciencias de la computación y las matemáticas, estos objetos se abordan desde la perspectiva algebraica y desde la perspectiva lógica.

En el cálculo lambda se distinguen las dos perspectivas por el lenguaje en el que se manejan los objetos, en el caso del álgebra booleana, los valores de verdad y las operaciones booleanas se codifican como términos lambda y pueden ser combinados con otros términos lambda que no forman parte del álgebra booleana. Por otra parte, la lógica proposicional estudia proposiciones, las cuales son enunciados matemáticos a los cuales se les puede atribuír el valor de falso o verdadero y que, a partir de conectivos lógicos como \( \lnot \), \( \land \) y \( \lor \), se infieren verdades sobre los enunciados.

El cálculo lambda se puede extender de tal manera que nos permita inferir verdades sobre sus términos, en esta subsección se abordan los cálculos lambda aumentados con nociones \emph{ilativas}, denotados \( \mathit{i}\bs{λ} \). El tratamiento de esta extensión está basado en el apéndice B ``Lógica combinatoria ilativa'' de \cite[pp.~573--576]{Barendregt:Bible}.

\begin{defn}[Términos \( \mathit{i}\bs{λ} \)]
  \label{defn:ilativo-terminos}
  Los términos de la teoría \( \mathit{i}\bs{λ} \), denotados \( \mathit{i}Λ \) se definen sobre el alfabeto de \( Λ \) extendido con un conjunto \( C \) de \emph{constantes lógicas}.

  \begin{align*}
    M \in Λ &\implies M \in \mathit{i}Λ \\
    c \in C &\implies c \in \mathit{i}Λ \\
    M, N \in \mathit{i}Λ &\implies (M\, N) \in \mathit{i}Λ
  \end{align*}
\end{defn}

\begin{defn}[Fórmulas en \( \mathit{i}\bs{λ} \)]
  \label{defn:ilativo-formulas}
  Las fórmulas de la teoría \( \mathit{i}\bs{λ} \) se definen de la siguiente manera
  
  \begin{itemize}
  \item Si \( M, N \in \mathit{i}Λ \), entonces \( M = N \) es una fórmula.
  \item Si \( M \in \mathit{i}Λ \), entonces \( M \) es una fórmula.
  \end{itemize}

  En el estudio de teorías ilativas, la interpretación de \( \mathit{i}\bs{λ} \vdash M \) y \( \mathit{i}\bs{λ} \vdash M = N \) es ``La fórmula \( M \) es verdadera'' y ``La fórmula \( M = N \) es verdadera'' respectivamente.
\end{defn}

\subsubsection{Teoría \( \mathit{i}\bs{λ}_{KR} \)}

Constantes \( C = \{ \bs{N} \} \) con la interpretación \( \lnot\, M \) es \( (\bs{N}\, M) \)

Paradoja de Kleene-Rosser

\[ X \synteq λx.\bs{N} (x\, x) \]

\[ X\, X = (λx.\bs{N} (x\, x)) X = \bs{N} (X\, X) \]

Se puede derivar que una fórmula \( X\, X = \lnot (X\, X) \), es decir, en \( \mathit{i}\bs{λ}_{KR} \) se pueden derivar contradicciones.

\subsubsection{Teoría \( \mathit{i}\bs{λ}_{0} \)}

Constantes \( C = \{ \bs{F},\ \bs{Q},\ \bs{E},\ \bs{Ξ},\ \bs{Π},\ \bs{P} \} \) con las siguientes interpretaciones

\begin{itemize}
\item \( M \in N \) es \( N\, M \)
\item \( M \implies N \) es \( \bs{P}\, M\, N \)
\item \( M \subseteq N \) es \( \bs{Ξ}\, M\, N \)
\item \( N^{M} \) es \( \bs{F}\, M\, N \)
\item \( \forall x\ M \) es \( \bs{Ξ} (λx.M) \)
\end{itemize}

\subsubsection*{Pendientes}

\begin{itemize}
\item Definibilidad de \( \bs{E} \), \( \bs{F} \), \( \bs{P} \) y \( \bs{Π} \) a partir de \( \bs{Q} \), \( \bs{Ξ} \).
\item Inconsistencia de \( \mathit{i}\bs{λ}_{0} \) por la paradoja de Curry ``Una teoría lambda ilativa es inconsistente si cada \( M \) puede ser derivada'' (la paradoja de Kleene-Rosser es una consecuencia de la paradoja de Curry).
\item Mencionar la técnica utilizada por Church para ``escapar'' de la paradoja de Curry y presentar el ``tradeoff'' de tener un sistema suficientemente poderoso: Equivalencia \( \bs{λ} \) y máquina de Turing \emph{vs.} separar la noción ilativa de la abstracción.
\end{itemize}

\section{Aritmética}
\label{sec:aritmetica}

Así como se pueden representar los valores de verdad de falso y verdadero en el cálculo lambda, también podemos encontrar representaciones para los números naturales. En esta sección se aborda una representación llamada numerales de Church, también se presentan términos lambda para operar números naturales con esta representación.

Para cada \( n \in \mathbb{N} \) el numeral de Church de \( n \) es un término lambda denotado como \( \bar{n} \) definido como:

\[ \bar{n} \synteq λx\, y.x^{n}\, y \]

En la siguiente tabla se puede apreciar mejor la estructura de los numerales de Church

\begin{table}
  \centering
  \begin{tabular}{|c|c|}
    \hline
    \( n \) & \( \bar{n} \) \\ [0.5ex]
    \hline\hline
    0 & \( λx\, y.y \) \\
    \hline
    1 & \( λx\, y.x\, y \) \\
    \hline
    2 & \( λx\, y.x(x\, y) \) \\
    \hline
    3 & \( λx\, y.x(x(x\, y)) \) \\
    \hline
    ... & ... \\
    \hline
  \end{tabular}
  \caption{Numerales de Church}
  \label{tab:numerales}
\end{table}

Como se observa en la tabla, un numeral de Church es una abstracción descurrificada de dos argumentos la cual al ser evaluada es reducida a la \( n \)-ésima composición del primer argumento evaluada en el segundo argumento.

Una manera de entender esta representación es pensar en los números naturales como un conteo de uno en uno; el 0 es no contar; el 1 es contar uno mas que el 0; el 2 es uno mas que el 1, así que el 2 es uno mas que el uno mas que el 0; el 3 es uno mas que el 2, así que el 3 es uno mas que el uno mas que el uno mas que el 0 y así sucesivamente. La idea de ``el uno mas'' es la del sucesor, si consideramos a \( x \) como una función sucesor y a \( y \) como el 0, podemos expresar \( x(x(x(y))) \) como \( \mathrm{sucesor}(\mathrm{sucesor}(\mathrm{sucesor}(0))) \), así que

\begin{align*}
\mathrm{sucesor}(\mathrm{sucesor}(\mathrm{sucesor}(0))) & = \mathrm{sucesor}(\mathrm{sucesor}(1)) \\
                             & = \mathrm{sucesor}(2) \\
                             & = 3
\end{align*}

Es interesante pensar en diferentes maneras de expresar las operaciones mas elementales de la aritmétima como términos lambda que operen sobre esta representación. A continuación se presenta una exploración de los términos lambda correspondientes a algunas operaciones elementales de la aritmética: suma, multiplicación, exponenciación y resta. La suma es una repetición de la operación sucesor, la multiplicación una repetición de suma, la exponenciación una repetición de multiplicaciones y la resta una repetición de la operación predecesor. Esto nos lleva a identificar las operaciones de sucesor y predecesor como los algoritmos base para el resto de las operaciones primitivas.

El término \emph{sucesor} debe ser uno tal que al ser aplicado a un numeral \( \bar{n} \) se pueda \( β \)-reducir al numeral \( \bar{n+1} \). Considerando la definición de \( \bar{n} \synteq λx\, y.x^{n}\, y \), lo que buscamos es una manera de agregarle una \( x \) a la composición en el cuerpo de \( \bar{n} \) para obtener \( λx\, y.x^{n+1}\, y \). Se construye este término considerando primero que será aplicado a un numeral

\[ \mathrm{sucesor} \synteq λ\bar{n}.? \] 

Además el resultado de \( β \)-reducir esta aplicación deberá ser una función de dos argumentos (como lo son todos los numerales de Church):

\[ \mathrm{sucesor} \synteq λ\bar{n}.λx\, y.? \]

Tomando en cuenta que \( \bar{n}\, x\, y \synteq x^{n}\, y \) y que \( x\, x^{n} y \synteq x^{n+1}\, y \):

\[ \mathrm{sucesor} \synteq λn\, x\, y.x(n\, x\, y) \]

A continuación se \( β \)-reduce la aplicación de \( \mathrm{sucesor} \) al numeral \( \bar{4} \synteq λx\, y.x(x(x(x\, y))) \):

\begin{align*}
                & \mathrm{sucesor}\, \bar{4} \\
\synteq         & (λn\, x\, y.x(n\, x\, y)) (λx\, y.x(x(x(x\, y)))) \\
\convertible{α} & (λn\, x\, y.x(n\, x\, y)) (λf\, z.f(f(f(f\, z)))) \\
\contract{β}    & (λx\, y.x(((λf\, z.f (f (f (f\, z)))) x) y)) \\
\contract{β}    & (λx\, y.x((λz.x(x(x(x\, z)))) y)) \\
\contract{β}    & (λx\, y.x(x(x(x(x\, y))))) \\
\synteq         & \bar{5}
\end{align*}

La otra operación elemental en la aritmética es el \emph{predecesor}, el término que represente esta operación debe ser uno que cumpla con la siguiente definición:

\begin{align*}
\mathrm{predecesor}\, \bar{0} & \reduce{β} \bar{0} \\
\mathrm{predecesor}\, \bar{n} & \reduce{β} \bar{n-1}
\end{align*}

El término lambda del predecesor con la representación de numerales de Church es mucho mas compleja que la del sucesor. Se pudiera pensar que la misma idea utilizada en la derivación del sucesor aplicaría para la derivación del predecesor: si tenemos \( n \) aplicaciones de \( x \) a \( y \), al aplicar el término que buscamos a un numeral de Church se debe \( β \)-reducir a otro numeral con una aplicación de \( x \) menos, se utiliza \( y \) para añadir una \( x \) mas en el cuerpo del numeral. Sin embargo, la estructura de los numerales no nos permite quitar una \( x \) usando \( y \) facilmente ya que el numeral puede ser aplicado a dos términos, el que representa las \( x \) y el que representa a la \( y \); la variable que determina el valor del numeral es  \( x \) y la sustitución de \( x \) por otro término en esta representación se hace con \emph{cada} aparición de \( x \) en el cuerpo del numeral, por otro lado, al sustituír la \( y \) por otro término solo podemos hacer mas complejo el término o sustituírla por otra variable.

Para derivar el término del predecesor vamos a presentar un término con una estructura similar a los numerales de Church:

\[ λx\, y\, z.z\, x^{n}\, y \]

La diferencia entre este término y un numeral de Church es que podemos modificar su estructura por enfrente, por atrás y en las composiciones intermedias. Si este término representara \( \bar{n+1} \) pudieramos obtener el cuerpo de \( \bar{n} \) de la siguiente manera:

\begin{align*}
             & (λx\, y\, z.z\, x^{n}\, y) x\, y (λa.a) \\
\contract{β} & (((λy\, z.z\, x^{n}\, y) y) (λa.a)) \\
\reduce{β}   & ((λz.z\, x^{n}\, y) (λa.a)) \\
\contract{β} & (λa.a) x^{n}\, y \\
\contract{β} & x^{n}\, y
\end{align*}

Es decir, mantenemos las \( x \) y la \( y \) y le aplicamos a \( x^{n} y \) el término lambda que representa a la función identidad. Esta manera conveniente de representar a los numerales resulta ser incompleta, ya que no se podrá obtener \( x^{n-1} y \) a partir del resultado (ya que la \( z \) no aparece en el término resultante). Sin embargo, si logramos tener un término que nos genera este término modificado pudiéramos realizar esta transformación dentro de la función predecesor sería mas fácil encontrar \( \bar{n-1} \).

La estructura del sucesor sería:

\[ λn\, x\, y.?\, (λa.a) \]

Donde \( ? \) debe ser tal que al \( β \)-reducirse resulte en un término con la forma \( λz.z\, x^{n-1}\, y \). Es conveniente desmenuzar el problema de encontrar este término desconocido: primero sabemos que el numeral de Church \( \bar{n} \) puede ser aplicado a dos términos y el primer término al que sea aplicado se sustituirá en todas las apariciones de \( x \), como queremos que la \( β \)-reducción nos genere una función cuyo argumento sea la primer variable en la composición del numeral, tenemos que encontrar una manera de propagar un término de la forma \( λw.w\, x^{m}\, y \) de tal manera que al aplicarle otro término nos resulte \( λw.w\, x^{m+1}\, y \). De esta manera al aplicar este otro término una y otra vez, resulte \( λw.w\, x^{n-1}\, y \) con el cual podemos obtener el cuerpo del predecesor sustituyendo \( w \) por \( λa.a \).

Este otro término que buscamos será el que sustituirá a la \( x \) en \( \bar{n} \) para que:

\[ ?(λw.w\, x^{m}\, y) \reduce{β} λw.w\, x^{m+1}\, y \]

Lo que sucede en cada aplicación de este estilo es que se compone una \( x \) en cada aplicación y se deja explícita una \( w \) que podrá ser sustituída como valor. El término que nos permite hacer esto tiene la siguiente forma:

\[ λg\, w.w (g\, x) \]

Al ser aplicado a un término \( λw.w\, x^{m}\, y \) la variable \( g \) será sustituída por este término y el resultado será \( λw.w((λr.r\, x^{m}\, y) x) \) (nótese el cambio de nombre de la variable ligada \( w \) en el argumento), lo cual se reduce a \( λw.w\, x^{m+1}\, y \) el cual mantiene su estructura original.

El percance con esta aproximación a la solución es que el primer valor al que se le aplica el término \( λg\, w.w (g\, x) \) debe ser \( λw.w\, y \).

Para visualizar una manera de resolver el problema, es conveniente expresar cómo se verían las aplicaciones de \( λg\, w.w (g\, x) \) para un numeral de Church en particular. Si consideramos la aplicación de \( \bar{4}\, (λg\, w.w(g\, x)) \):

\begin{align*}
             & \bar{4} (λg\, w.w(g\, x)) \\
\synteq      & ( (λx\, y.x^{4}\, y) (λg.(λw.(w (g\, x)))) ) \\
\synteq      & ( (λx\, y.x(x(x(x\, y)))) (λg.(λw.(w (g\, x)))) ) \\
\contract{β} & (λy.(λg.(λw.(w (g\, x))))((λg.(λw.(w (g\, x))))((λg.(λw.(w (g\, x))))((λg.(λw.(w (g\, x)))) y))))
\end{align*}

Esto nos lleva al segundo paso para encontrar la función predecesor, en el desarrollo anterior notamos que la primer aplicación de \( λg\, w.w (g\, x) \) es en la variable \( y \) la cual está ligada por la \( λ \) del término. Sabemos que para obtener \( λw.w\, x^{3}\, y \) debemos \( β \)-reducir el término:

\[ ((λg.(λw.(w (g\, x)))) ((λg.(λw.(w (g\, x)))) ((λg.(λw.(w (g\, x)))) (λw.w\, y)))) \]

Con esto podemos encontrar el valor que tiene que tomar \( y \) en el numeral ya que:

\[ ((λg.(λw.(w (g\, x)))) y) \reduce{β} λw.w\, y \]

El término que buscamos es el que debe sustituír a la variable \( y \) en la reducción:

\begin{align*}
           & ((λg.(λw.(w (g\, x)))) ?) \\
\reduce{β} & (λw.(w (?\, x)))
\end{align*}

El término \( ? \) debe ser una función que al ser aplicada a \( x \) se reduzca a \( y \). El término \( λu.y \) cumple con esta propiedad y será el que utilizaremos.

Considerando los términos determinados en el procedimiento anterior, podemos decir cómo será la función predecesor. Primero se aplica \( (λg.(λw.(w (g\, x)))) \) a \( \bar{n} \), este término resultante se aplica a \( λu.y \), \( β \)-reducir esta aplicación nos resulta \( λw.w\, x^{n-1}\, y \) la cual puede ser aplicada a la función identidad \( λa.a \) para obtener \( x^{n-1}\, y \). Lo cual nos lleva al término completo de predecesor:

\[ (λn.(λx\, y.(((n (λg.(λw.(w (g\, x))))) (λu.y)) (λa.a)))) \]

Teniendo los términos lambda de sucesor y predecesor se puede abordar la derivación de operaciones mas complejas como la de adición, multiplicación, exponenciación y sustracción de numerales de Church siguiendo el mismo enfoque. En este trabajo no se abordan otras operaciones como la división debido al aumento de complejidad por no ser una operación interna, es decir, la división de dos naturales puede ser un racional y no se definió una representación de términos lambda para el conjunto de los racionales.

Un término lambda para la adición de dos numerales \( \bar{m} \) y \( \bar{n} \) es

\[ λm\, n.(λx\, y.n\, \mathrm{sucesor}\, m) \]

y se obtuvo a partir de la observación de que realizar la suma \( m+n \) es equivalente a computar el \( n \)-ésimo sucesor de \( m \).

Utilizando la estructura de \( \bar{n} \) podemos aplicar \( \bar{n}\, \mathrm{sucesor}\, \bar{m} \) para obtener la \( n \)-ésima composición de la función sucesor aplicada al numeral \( \bar{m} \):

\begin{align*}
             & \bar{n}\, \mathrm{sucesor}\, \bar{m} \\
\synteq      & (( (λx\, y.x^{n}\, y) \mathrm{sucesor}) (λx\, y.x^{m}\, y)) \\
\contract{β} & ( (λy.\mathrm{sucesor}^{n}\, y) (λx\, y.x^{m}\, y)) \\
\contract{β} & \mathrm{sucesor}^{n}\, λx\, y.x^{m}\, y \\
\reduce{β}   & λx\, y.x^{m+n}\, y \\
\synteq      & \bar{m+n}
\end{align*}

Un término lambda para la multiplicación de dos numerales de Church es

\[ λm\, n\, x\, y.n (m\, x) y \]

el cual aborda la idea de componer \( m\, n \) consigo mismo \( n \) veces (lo cual equivaldría a sumar \( n \) veces \( m \).

En el caso de la adición y la multiplicación, el orden en el que aplicamos el término a los numerales no es de importancia ya que son operaciones conmutativas, \( m+n = n+m \) y \( m \times n = n \times m \). Sin embargo en la sustracción y la exponenciación no se tiene esta propiedad, por lo que es importante el orden en el que se aplican los numerales a los términos, para ello consideraremos el orden como \( m-n \) y \( m^{n} \).

Basándonos en el término de la adición podemos obtener un término de la sustracción el cual es

\[ λm\, n\, x\, y.n\, \mathrm{predecesor}\, m \].

Ya que en la adición se dejó explícito el acto de aumentar \( m \) veces en 1 a \( n \), cambiamos el término de \( \mathrm{sucesor} \) por el de \( \mathrm{predecesor} \) y ahora se decrementa \( m \) veces en 1 a \( n \).

Un término lambda para la exponenciación es

\[ λm\, n.n\, m \]

es curioso tener una representación tan sencilla para una operación tan compleja como esta. A diferencia de los anteriores términos, al aplicarle a ésta exponenciación dos numerales, el numeral resultante tendrá las variables compuestas las variables que no se componen en las entradas, es decir, si \( \bar{m} \synteq λf\, g.f^{m}\, g \) y \( \bar{n} \synteq λx\, y.x^{n}\, y \), el resultado será \( \bar{m^{n}} \synteq λg\, y.g^{m^{n}}\, y \).

Para corroborar que estas representaciones calculan de manera correcta la operación correspondiente para los numerales de Church se pueden realizar varias pruebas con diferentes numerales de entrada. En este trabajo no se desarrollarán ejemplos para estos términos.

Los mecanismos que hemos utilizado para derivar las operaciones se basan en construír términos que vayan transformando entradas con una estructura determinada de tal manera que nos acerquemos poco a poco al cálculo de la operación deseada; esta labor llega a ser bastante tediosa y carece de interés algorítmico. A continuación se presenta una manera mas interesante y elegante de abordar el problema de representar operaciones aritméticas.

Se introduce el término lambda que me permite generar hiperoperaciones aritméticas:

\[ λf\, u\, m\, n.n (λw.f\, m\, w) u \]

Abstracción de la noción de repetición sobre la estructura de un numeral, considerar propiedades de conmutatividad y asociatividad en operaciones. Abordar el problema del cómputo de operaciones inversas. Determinar un término que nos genere elementos de la secuencia de hiperoperaciones.

\section{Procesos recursivos}
\label{sec:procesos-recursivos}

Combinador Y, ordenes de evaluación, funciones recursivas.

\[ \bs{Y} \synteq λf.(λx.f(x\, x))(λx.f(x\, x)) \]

{\center Derivación de \( \bs{Y} \)}
\begin{align}
  F &\synteq λn.\bs{\prec}\, (\bs{0^{?}}\, n) \bar{1} (\bs{\times}\, n (F (\bs{-}\, n\, \bar{1}))) \\
  F' &\synteq λf\, n.\bs{\prec}\, (\bs{0^{?}}\, n) \bar{1} (\bs{\times}\, n (f (\bs{-}\, n\, \bar{1})))\\
  F'' &\synteq λf'\, n.\bs{\prec}\, (\bs{0^{?}}\, n) \bar{1} (\bs{\times}\, n (f'\, f' (\bs{-}\, n\, \bar{1}))) \\
  C &\synteq λf''.f''\, f'' \\
  C\, F'' &\reduce{β} \text{ función factorial a partir de \( F'' \)} \\
  F''' &\synteq (λf'''.f' (f'''\, f''')) \\
  F'''\, F''' &\reduce{β} f'(F'''\, F''') \\
  C^{*} &\synteq λf'.(λf'''.f' (f'''\, f'''))(λf'''.f' (f'''\, f''')) \\
  C^{*}\, F' &\reduce{β} \text{ función factorial a partir de \( F' \)}
\end{align}

\[ Y \synteq C^{*} \]

Presentar una breve introducción sobre los combinadores y hablar del combinador \( \bs{Y} \) y cómo nos permite expresar funciones recursivas en el cálculo lambda.

Como ejemplos prácticos de esta subsección sería adecuado desarrollar el término para el cálculo de factoriales o algúna otra función de una sola variable que transforme un numeral de Church en otro. También pudiera expandir la recursividad a términos multivariables currificados como la función Ackermann (abstracción a la generación de hiperoperaciones, ver \emph{The Book of Numbers} de Conway).

\section{Pares ordenados}
\label{sec:pares-ordenados}

Construcción axiomática de pares ordenados, listas, \( n \)-tuplas, árboles y otras estructuras complejas.

Presentar la representación de pares ordenados para la construcción de estructuras mas complejas.

\[ \mathrm{Car}(\mathrm{Cons}(x,y)) = x \]

\[ \mathrm{Cdr}(\mathrm{Cons}(x,y)) = y \]

Esta sección es apropiada para comenzar a relacionar la teoría de autómatas, lenguajes regulares y libres de contexto con sistemas medianamente complejos que se pueden incrustar en el cálculo lambda sin modificar el sistema. Un problema pudiece ser el no determinismo, pero pudiera solventar esto con el desarrollo de operaciones funcionales sobre listas (map, filter, fold, etc).

\subsection*{Cambios en la metodología}

Expandir el concepto de valores de verdad al de pares ordenados

\subsubsection*{Constructor}

\begin{verbatim}
CreaPar (primero, segundo) =
    Elige (x) =
        Si x, entonces:
            primero
        De lo contrario:
            segundo
    Elige
\end{verbatim}

\begin{align*}
  \otimes & \synteq λa\, d.λx.B\, x\, a\, d \\
          & \contract{β} λa\, d.λx.x\, a\, d \\
          & \synteq λa\, d\, x.x\, a\, d
\end{align*}

\subsubsection*{Selectores}

\begin{verbatim}
Primero (Elige) =
    Elige(T)
\end{verbatim}

\begin{align*}
  \otimes_{1} & \synteq λx.x\, T
\end{align*}

\begin{verbatim}
Segundo (Elige) =
    Elige(F)
\end{verbatim}

\begin{align*}
  \otimes_{2} & \synteq λx.x\, F
\end{align*}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
