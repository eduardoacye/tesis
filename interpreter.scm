(define (atom? x)
  (not (pair? x)))
(define (atom-str x)
  (if (number? x) (number->string x) (symbol->string x)))

(define (abst? x)
  (and (pair? x)
       (eq? 'lambda (car x))
       (= 3 (length x))
       (pair? (cadr x))
       (= 1 (length (cadr x)))
       (atom? (abst-arg x))))
(define (abst-arg x) (caadr x))
(define (abst-body x) (caddr x))

(define (app? x) (and (pair? x) (= 2 (length x))))
(define (app-left x) (car x))
(define (app-right x) (cadr x))

(define (def? x)
  (and (pair? x)
       (eq? 'define (car x))
       (= 3 (length x))
       (atom? (def-name x))))
(define (def-name x) (cadr x))
(define (def-val x) (caddr x))

(define gb '())

(define (extend b name val)
  (cons (cons name val) b))

(define (gextend! name val)
  (set! gb (extend gb name val))
  val)

(define (lookup e b)
  (cond ((or (assv e b) (assv e gb)) => cdr)
        (else #f)))

(define (eval-error str . xs)
  (apply error 'eval str xs))

(define (eval e b)
  (cond ((atom? e)
         (cond ((lookup e b) =>
                (lambda (r)
                  (if (equal? r e) r (eval r b))))
               (else e)))
        ((def? e)
         (let ((name (def-name e))
               (val  (def-val e)))
           (gextend! name (eval val b))))
        ((abst? e)
         (let ((e* (if (lookup (abst-arg e) b) (abst-rename e b) e)))
           (list 'lambda
                 (list (abst-arg e*))
                 (eval (abst-body e*) (extend b (abst-arg e*) (abst-arg e*))))))
        ((app? e)
         (let ((op (eval (app-left e) b)))
           (if (abst? op)
               (eval (abst-body op) (extend b (abst-arg op) (app-right e)))
               (let ((right (eval (app-right e) b)))
                 (list op right)))))
        (else
         (eval-error "Expresión mal formada" e))))

(define abcs
  (map string (string->list "abcdefghijklmnopqrstuvwxyz")))

(define (abst-rename e b)
  (define (rename e from to)
    (cond ((atom? e)
           (if (equal? from e) to e))
          ((def? e)
           (list 'define (def-name e) (rename (def-val e) from to)))
          ((abst? e)
           (if (equal? from (abst-arg e))
               e
               (list 'lambda
                     (list (abst-arg e))
                     (rename (abst-body e) from to))))
          ((app? e)
           (list (rename (app-left e) from to)
                 (rename (app-right e) from to)))
          (else
           (eval-error "Expresión mal formada" e))))
  (define arg (abst-arg e))
  (define arg-str (atom-str arg))
  (define vars-str (map atom-str (append (map car b) (map car gb))))
  (define arg-str*
    (let loop ((i 0))
      (let ((arg-str* (string-append arg-str (number->string i))))
        (if (member arg-str* vars-str)
            (loop (+ i 1))
            arg-str*))))
  (define arg* (string->symbol arg-str*))
  (list 'lambda
        (list arg*)
        (rename (abst-body e) arg arg*)))

(define initial-defs
  '((define I (lambda (x) x))
    (define K (lambda (x) (lambda (y) x)))
    (define S (lambda (x) (lambda (y) (lambda (z) ((x z) (y z))))))
    (define T K)
    (define F (lambda (x) (lambda (y) y)))
    (define If (lambda (p) (lambda (m) (lambda (n) ((p m) n)))))
    (define Not (lambda (p) (((If p) F) T)))
    (define Or (lambda (p) (lambda (q) (((If p) T) (((If q) T) F)))))
    (define And (lambda (p) (lambda (q) (((If p) (((If q) T) F)) F))))
    (define 0 F)
    (define 0? (lambda (n) ((n (K F)) T)))
    (define 1+ (lambda (n) (lambda (x) (lambda (y) (x ((n x) y))))))
    (define 1 (1+ 0))
    (define 2 (1+ 1))
    (define 3 (1+ 2))
    (define 4 (1+ 3))
    (define + (lambda (m) (lambda (n) ((n 1+) m))))
    (define * (lambda (m) (lambda (n) ((n (+ m)) 0))))
    (define ^ (lambda (m) (lambda (n) ((n (* m)) 1))))
    (define 0* (lambda (x) (lambda (y) (lambda (z) y))))
    (define 1+* (lambda (n*) (lambda (x) (lambda (y) (lambda (z) (((n* x) (z y)) x))))))
    (define 1- (lambda (n) (lambda (x) (lambda (y) (((((n 1+*) 0*) x) y) I)))))
    (define - (lambda (m) (lambda (n) ((n 1-) m))))))

(define (repl)
  (set! gb '())
  (for-each (lambda (e) (eval e '())) initial-defs)
  (let loop ()
    (format #t "(λ)> ")
    (let ((e (read)))
      (unless (null? e)
        (let ((r (eval e '())))
          (format #t "~a\n" r)
          (loop))))
    (set! gb '())))


