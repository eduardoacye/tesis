#lang racket
(require rackunit)
(require macro-debugger/expand)
(require "lambda-lib.rkt")
(test-case "Implementación de variables"  
  (check-true (variable? (variable "x")))
  (check-false (variable? 42))
  (check-exn exn:fail:contract? (lambda () (variable 42)))
  (check-equal? (variable-nombre (variable "x")) "x"))
(test-case "Implementación de abstracciones"  
  (check-true (abstracción? (abstracción (variable "x") (variable "y"))))
  (check-false (abstracción? (variable "x")))
  (check-exn exn:fail:contract? (lambda () (abstracción "x" "y")))
  (check-equal? (abstracción-argumento (abstracción (variable "x") (variable "y")))
                (variable "x"))
  (check-equal? (abstracción-cuerpo (abstracción (variable "x") (variable "y")))
                (variable "y")))
(test-case "Implementación de aplicaciones"  
  (check-true (aplicación? (aplicación (variable "x") (variable "y"))))
  (check-false (aplicación? (abstracción (variable "x") (variable "y"))))
  (check-exn exn:fail:contract? (lambda () (aplicación "x" "y")))
  (check-equal? (aplicación-operador (aplicación (variable "x") (variable "y")))
                (variable "x"))
  (check-equal? (aplicación-operando (aplicación (variable "x") (variable "y")))
                (variable "y")))
(test-case "Implementación de huecos"
  (check-true (hueco? (hueco)))
  (check-false (hueco? 42)))
(test-case "Implementación de metainstrucciones"  
  (check-true (metainstrucción? (metainstrucción "f" (list (variable "x")))))
  (check-false (metainstrucción? (aplicación (variable "x") (variable "y"))))
  (check-exn exn:fail:contract?
             (lambda () (metainstrucción (variable "f") (variable "x"))))
  (check-equal? (metainstrucción-nombre
                 (metainstrucción "f" (list (variable "x")))) "f")
  (check-equal? (metainstrucción-argumentos
                 (metainstrucción "f" (list (variable "x"))))
                (list (variable "x"))))
(test-case "Definición de metainstrucciones"
  (check-equal? (syntax->datum (expand-only #'(define-metainstrucción (f x)
                                                (if (variable? x) 1 0))
                                            (list #'define-metainstrucción)))
                '(begin
                  (define (f x) (if (variable? x) 1 0))
                  (hash-set! metainstrucciones (symbol->string 'f) f))))
(test-case "Predicado para términos"
  (check-true
   (término? (abstracción (variable "x")
                          (aplicación (variable "x") (variable "x")))))
  (check-false
   (término? (abstracción (variable "x") (aplicación (variable "x") (hueco))))))
(test-case "Predicados de variables"
  (let ([v (variable "x")])
    (check-true (variable=? v v)))
  (check-false (variable=? (variable "x") (variable "x")))
  (check-true (átomo=? (variable "x") (variable "x")))
  (check-false (átomo=? (variable "x") (variable "y"))))
(test-case "Predicados de abstracciones"
  (check-true (argumento=? (abstracción (variable "x") (variable "y"))
                           (abstracción (variable "x") (variable "z"))))
  (check-false (argumento=? (abstracción (variable "y") (variable "x"))
                            (abstracción (variable "z") (variable "x"))))
  (check-true (cuerpo=? (abstracción (variable "y") (variable "x"))
                        (abstracción (variable "z") (variable "x"))))
  (check-false (cuerpo=? (abstracción (variable "x") (variable "y"))
                         (abstracción (variable "x") (variable "z")))))
(test-case "Predicados de aplicaciones"
  (check-true (operador=? (aplicación (variable "x") (variable "y"))
                          (aplicación (variable "x") (variable "z"))))
  (check-false (operador=? (aplicación (variable "y") (variable "x"))
                           (aplicación (variable "z") (variable "x"))))
  (check-true (operando=? (aplicación (variable "y") (variable "x"))
                          (aplicación (variable "z") (variable "x"))))
  (check-false (operando=? (aplicación (variable "x") (variable "y"))
                           (aplicación (variable "x") (variable "z")))))
(test-case "Predicados de metainstrucciones"
  (check-true (nombre=? (metainstrucción "f" null)
                        (metainstrucción "f" (list (variable "x")))))
  (check-false (nombre=? (metainstrucción "f" (list (variable "x")))
                         (metainstrucción "g" null)))
  (check-true (cantidad-argumentos=? (metainstrucción "f" (list (variable "x")))
                                     (metainstrucción "g" (list (hueco)))))
  (check-false (cantidad-argumentos=? (metainstrucción "f" (list (variable "x")))
                                      (metainstrucción "f" null)))
  (check-true (argumentos=? (metainstrucción "f" (list (variable "x")
                                                       (variable "y")))
                            (metainstrucción "g" (list (variable "x")
                                                       (variable "y")))))
  (check-false (argumentos=? (metainstrucción "f" (list (variable "x")))
                             (metainstrucción "f" (list (variable "x")
                                                        (variable "y"))))))
(test-case "Lectura de fin de archivo"
  (check-equal? (parsear-cadena "") eof)
  (check-equal? (parsear-expresión (open-input-string "") eof (variable "x"))
                (variable "x")))
(test-case "Predicados para delimitadores"
  (check-true (delimitador-final? eof))
  (check-true (delimitador-final? #\)))
  (check-false (delimitador-final? #\x))
  (check-false (delimitador-final? #\())
  (check-exn exn:fail:contract? (lambda () (delimitador-final? 42))))
(test-case "Lectura de delimitador final"
  (check-exn exn:fail? (lambda () (parsear-cadena ")")))
  (check-equal? (parsear-expresión (open-input-string ")") #\) null) #\))
  (let ([p (open-input-string ")")])
    (check-equal? (parsear-expresión p #\) (variable "x")) (variable "x"))
    (check-equal? (read-char p) #\))))
(test-case "Lectura de espacio en blanco"
  (check-equal? (parsear-cadena " \t\n \n\t")
                (parsear-cadena ""))
  (check-equal? (parsear-expresión (open-input-string " \t\n \n\t)")
                                   #\space
                                   (variable "x"))
                (parsear-expresión (open-input-string ")") #\) (variable "x"))))
(test-case "Acumulación de expresiones"
  (check-equal? (aplicación/identidad null (variable "x"))
                (variable "x"))
  (check-equal? (aplicación/identidad (variable "x") (variable "y"))
                (aplicación (variable "x") (variable "y"))))
(test-case "Parsear sin abuso de notación"
  (check-equal? (parsear-cadena "foo")
                (variable "foo"))
  (check-equal? (parsear-cadena "(foo bar)")
                (aplicación (variable "foo") (variable "bar")))
  (check-equal? (parsear-cadena "((foo bar) baz)")
                (aplicación (aplicación (variable "foo") (variable "bar"))
                            (variable "baz")))
  (check-equal? (parsear-cadena "(foo (bar baz))")
                (aplicación (variable "foo")
                            (aplicación (variable "bar") (variable "baz"))))
  (check-equal? (parsear-cadena "(\\bar.bar)")
                (abstracción (variable "bar") (variable "bar")))
  (check-equal? (parsear-cadena "foo[bar,baz]")
                (metainstrucción "foo" (list (variable "bar") (variable "baz"))))
  (check-equal? (parsear-cadena "(\\foo.(\\bar.foo))")
                (abstracción (variable "foo")
                             (abstracción (variable "bar") (variable "foo"))))
  (check-equal? (parsear-cadena "  []  ")
                (hueco)))
(test-case "Parsear con abuso de notación"
  (check-equal? (parsear-cadena "foo bar")
                (aplicación (variable "foo") (variable "bar")))
  (check-equal? (parsear-cadena "foo bar baz")
                (aplicación (aplicación (variable "foo") (variable "bar"))
                            (variable "baz")))
  (check-equal? (parsear-cadena "foo (bar baz)")
                (aplicación (variable "foo")
                            (aplicación (variable "bar") (variable "baz"))))
  (check-equal? (parsear-cadena "\\foo.foo")
                (abstracción (variable "foo") (variable "foo")))
  (check-equal? (parsear-cadena "\\foo bar.foo")
                (abstracción (variable "foo")
                             (abstracción (variable "bar") (variable "foo"))))
  (check-equal? (parsear-cadena "(\\foo bar.foo)")
                (abstracción (variable "foo")
                             (abstracción (variable "bar") (variable "foo"))))
  (check-equal? (parsear-cadena "(\\foo.\\bar.foo)")
                (abstracción (variable "foo")
                             (abstracción (variable "bar")
                                          (variable "foo"))))
  (check-equal? (parsear-cadena "\\foo.bar baz")
                (abstracción (variable "foo")
                             (aplicación (variable "bar")
                                         (variable "baz"))))
  (check-equal? (parsear-cadena "\\foo bar.bar baz")
                (abstracción (variable "foo")
                             (abstracción (variable "bar")
                                          (aplicación (variable "bar")
                                                      (variable "baz")))))
  (check-equal? (parsear-cadena "(\\foo.foo)\\bar.bar")
                (aplicación (abstracción (variable "foo")
                                         (variable "foo"))
                            (abstracción (variable "bar")
                                         (variable "bar"))))
  (check-equal? (parsear-cadena "foo[\\bar.bar bar, \\baz.baz baz] quux")
                (aplicación
                 (metainstrucción "foo"
                                  (list (abstracción (variable "bar")
                                                     (aplicación (variable "bar")
                                                                 (variable "bar")))
                                        (abstracción (variable "baz")
                                                     (aplicación (variable "baz")
                                                                 (variable "baz")))))
                 (variable "quux")))
  (check-equal? (parsear-cadena "\\x.x [] x")
                (abstracción (variable "x")
                             (aplicación (aplicación (variable "x") (hueco))
                                         (variable "x")))))
(test-case "Escritura formal a texto plano"
  (check-equal? (escribir-expresión-formal (parsear-cadena "foo"))
                "foo")
  (check-equal? (escribir-expresión-formal (parsear-cadena "\\foo.foo"))
                (format "(~afoo.foo)" (integer->char 955)))
  (check-equal? (escribir-expresión-formal
                 (parsear-cadena "foo bar (baz baz)"))
                "((foo bar) (baz baz))")
  (check-equal? (escribir-expresión-formal
                 (parsear-cadena "   [       ]"))
                "[ ]")
  (check-equal? (escribir-expresión-formal
                 (parsear-cadena "foo[\\bar.baz,baz bar]"))
                (format "foo[(~abar.baz), (baz bar)]" (integer->char 955))))
(test-case "Escritura breve a texto plano"
  (check-equal? (escribir-expresión-breve (parsear-cadena "foo"))
                "foo")
  (check-equal? (escribir-expresión-breve (parsear-cadena "\\foo.foo"))
                (format "~afoo.foo" (integer->char 955)))
  (check-equal? (escribir-expresión-breve
                 (parsear-cadena "foo bar (baz baz)"))
                "foo bar (baz baz)")
  (check-equal? (escribir-expresión-breve
                 (parsear-cadena "foo (bar baz) \\quux.quux quux"))
                (format "foo (bar baz) ~aquux.quux quux" (integer->char 955)))
  (check-equal? (escribir-expresión-breve (parsear-cadena " [    ]"))
                "[ ]")
  (check-equal? (escribir-expresión-breve
                 (parsear-cadena "foo[\\bar.baz,baz bar]"))
                (format "foo[~abar.baz, baz bar]" (integer->char 955))))
(define-metainstrucción (siempre-x . argumentos)
  (variable "x"))

(define-metainstrucción (encuentra-foo e)
  (define (busca-foo e)
    (cond [(or (variable? e) (hueco? e))
           #f]
          [(abstracción? e)
           (busca-foo (abstracción-cuerpo))]
          [(aplicación? e)
           (or (busca-foo (aplicación-operador e))
               (busca-foo (aplicación-operando e)))]
          [(metainstrucción? e)
           (if (string=? "foo" (metainstrucción-nombre e)) e #f)]))
  (let ([foo (busca-foo e)])
    (if foo foo e)))

(test-case "Evaluación de expresiones"
           (check-equal? (evaluar-cadena "y y siempre-x[y] y y")
                         (parsear-cadena "y y x y y"))
           (check-equal? (evaluar-cadena "\\x.encuentra-foo[x]")
                         (parsear-cadena "\\x.x"))
           (check-equal? (evaluar-cadena "\\x.encuentra-foo[foo[x]]")
                         (parsear-cadena "\\x.foo[x]"))
           (check-equal? (evaluar-cadena "siempre-x[encuentra-foo[foo[x]]]")
                         (parsear-cadena "x"))
           (check-equal? (evaluar-cadena "encuentra-foo[siempre-x[foo[x]]]")
                         (parsear-cadena "x")))
