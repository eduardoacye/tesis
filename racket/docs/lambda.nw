% -*- mode: latex; mmm-noweb-code-mode: racket-mode; coding: utf-8 -*-

% lambda.nw --- 

% Copyright (C) 2016 Eduardo Acuña Yeomans <eduardo.acye@gmail.com>

% Author: Eduardo Acuña Yeomans <eduardo.acye@gmail.com>

% This program is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License
% as published by the Free Software Foundation; either version 3
% of the License, or (at your option) any later version.

% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.

% You should have received a copy of the GNU General Public License
% along with this program. If not, see <http://www.gnu.org/licenses/>.

\documentclass[letterpaper,twoside,openright,11pt]{book}

\usepackage{setspace}
\onehalfspacing

\usepackage[lmargin=1.4 in, rmargin=.8 in, tmargin=1 in, bmargin=1 in]{geometry}
\usepackage[utf8]{inputenc}
% \usepackage[spanish]{babel}
\usepackage[T1]{fontenc}

\usepackage{tikz}
\usetikzlibrary{positioning,arrows,shadows}

\usepackage[sumlimits]{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[full]{textcomp}
\usepackage[osf]{newpxtext}
\usepackage{cabin}
\usepackage[varqu,varl]{inconsolata}
\usepackage[bigdelims,vvarbb]{newpxmath}
\usepackage[cal=boondoxo]{mathalfa} % mathcal
\usepackage{proof}

\newcommand{\bs}{\boldsymbol}
\newcommand{\mc}{\mathcal}

\usepackage{xcolor}
\usepackage{enumerate}

\usepackage{newunicodechar}
\newunicodechar{λ}{\lambda}
\newunicodechar{Λ}{\Lambda}
\newunicodechar{α}{\alpha}
\newunicodechar{β}{\beta}
\newunicodechar{δ}{\delta}
\newunicodechar{Δ}{\Delta}
\newunicodechar{Γ}{\Gamma}
\newunicodechar{ω}{\omega}
\newunicodechar{Ω}{\Omega}
\newunicodechar{ρ}{\rho}
\newunicodechar{σ}{\sigma}
\newunicodechar{Σ}{\Sigma}
\newunicodechar{τ}{\tau}
\newunicodechar{ν}{\nu}
\newunicodechar{μ}{\mu}
\newunicodechar{ξ}{\xi}
\newunicodechar{Ξ}{\Xi}
\newunicodechar{ζ}{\zeta}
\newunicodechar{η}{\eta}
\newunicodechar{φ}{\phi}
\newunicodechar{Φ}{\Phi}
\newunicodechar{π}{\pi}
\newunicodechar{Π}{\Pi}
\newunicodechar{θ}{\theta}
\newunicodechar{Θ}{\Theta}

\newcommand{\subst}[3]{#1 \left[ #2 \operatorname{:=} #3 \right]}
\newcommand{\synteq}{\ \equiv\ }
\newcommand{\contract}[1]{\ \operatorname{\rightarrow_{#1}}\ }
\newcommand{\xcontract}[2]{\ \operatorname{\overset{#2}{\rightarrow_{#1}}}}
\newcommand{\reduce}[1]{\ \operatorname{\twoheadrightarrow_{#1}}\ }
\newcommand{\xreduce}[2]{\ \operatorname{\overset{#2}{\twoheadrightarrow_{#1}}}}
\newcommand{\convertible}[1]{\ \operatorname{=_{#1}}\ }
\DeclareMathOperator{\Sub}{Sub}
\DeclareMathOperator{\FV}{FV}
\newcommand*\cn[1]{\widehat{#1}}

\usepackage{noweb}
%\pagestyle{empty}
\noweboptions{smallcode,spanish,breakcode,longchunks,longxref,webnumbering}

\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  pdftitle={El cálculo lambda y los fundamentos de la computación},
  pdfauthor={Eduardo Acuña Yeomans}
  bookmarks=true,
}

\date{}

\begin{document}

\begin{center}
  \vspace*{10pt}
  {\Huge\textbf{\textsc{Lambda}}}\\
  \vspace*{5pt}
  {\large Un programa para la exploración del cálculo \( λ \) puro}
  \vspace*{10pt}
\end{center}

@ \paragraph{Introducción}

El programa [[lambda]]\footnote{Nombrado así en ausencia de originalidad.} tiene la finalidad de proveer una entorno computacional ameno para estudiar el contenido de este trabajo de manera interactiva. La presente implementación está escrita en el lenguaje de programación [[Racket]]\footnote{Para más información, visitar el sitio oficial ~\url{http://racket-lang.org/}.} y consta de un intérprete de expresiones del cálculo \( λ \) el cuál puede ser utilizado de tres maneras diferentes:

\begin{enumerate}
\item A través de un ciclo de lectura, evaluación y escritura (conocido como \emph{REPL}) por consola;
\item Por medio de un editor estructural gráfico;
\item Como una biblioteca para facilitar la programación de algoritmos que involucren términos del cálculo \( λ \).
\end{enumerate}

El corazón del intérprete es un \emph{evaluador}, una función que transforma expresiones de un lenguaje a valores, los cuales a su vez pueden ser expresiones de este lenguaje. El lenguaje con el que trabaja este procedimiento es una extensión a \( Λ \) que incluye ``huecos'' y ``metainstrucciones'', estas últimas permiten manipular términos \( λ \) de manera arbitraria, por ejemplo calcular la longitud de un término \( M \) involucraría invocar una metainstrucción similar a la definición de \( \| M \| \) . Las expresiones de este lenguaje son almacenadas en memoria como un árbol de sintaxis. Para construír estos árboles se utilizan dos métodos: usando un \emph{lector} (o parser) que transforma cadenas de caracteres a árboles o utilizando el \emph{editor estructural} que permite únicamente editar expresiones válidas del lenguaje.

@ \section*{Estructuras del lenguaje}

@ \paragraph{Árbol de sintaxis}

Un árbol de sintaxis para el lenguaje de [[lambda]] consiste de vértices que pueden ser \emph{variables}, \emph{aplicaciones}, \emph{abstracciones}, \emph{huecos} o \emph{metainstrucciones}. Estos tipos de vértices son implementados haciendo uso del macro [[struct]] el cuál a partir de un identificador de la estructura y los identificadores de sus componentes produce un constructor, un predicado y selectores para cada componente.

La estructura que representa a las variables de un árbol es llamada [[variable]] y se compone de una cadena de caracteres llamada [[nombre]].

<<estructuras del lenguaje>>=
(struct variable (nombre) #:transparent)

@ %def variable
@

La estructura que representa a las abstracciones de un árbol es llamada [[abstracción]], se compone de una variable llamada [[argumento]] y de otro vértice del árbol llamado [[cuerpo]], este último puede ser de cualquiera de los cuatro tipos de vértices mencionados.


<<estructuras del lenguaje>>=
(struct abstracción (argumento cuerpo) #:transparent)

@ %def abstracción
@

La estructura que representa a las aplicaciones de un árbol es llamada [[aplicación]], se compone de un vértice llamado [[operador]] y de otro vértice llamado [[operando]].


<<estructuras del lenguaje>>=
(struct aplicación (operador operando) #:transparent)

@ %def aplicación
@

Se define el predicado [[término?]] para determinar si un objeto dado es un término \( λ \), es decir, si es una estructura [[variable]], [[abstracción]] o [[aplicación]]. Se debe verificar que los campos de cada subtérmino corresponden a un término \( λ \) adecuado, por ejemplo, las abstracciones deben tener como argumento una variable y como cuerpo un término.

<<predicados del lenguaje>>=
(define (término? x)
  (cond
   [(variable? x)    (string? (variable-nombre x))]
   [(abstracción? x) (and (variable? (abstracción-argumento x))
                          (término? (abstracción-cuerpo x)))]
   [(aplicación? x)  (and (término? (aplicación-operador x))
                          (término? (aplicación-operando x)))]
   [else             #f]))

@ %def término?

La estructura que representa a las metainstrucciones de un árbol es llamada [[metainstrucción]], se compone de una cadena de caracteres llamada [[nombre]] y de una lista de vértices llamada [[argumentos]].

<<estructuras del lenguaje>>=
(struct metainstrucción (nombre argumentos) #:transparent)

@ %def metainstrucción
@

Para representar un vértice sin un término asignado se utiliza la estructura [[hueco]], esta funciona como una especie de comodín o valor nulo.


<<estructuras del lenguaje>>=
(struct hueco () #:transparent)

@ %def hueco
@


De manera análoga a la identificación de términos \( λ \) mediante el procedimiento [[término?]] se define el predicado [[expresión?]] el cuál permite distinguir estructuras que sean expresiones de este lenguaje, incluyendo a los términos \( λ \).

<<predicados del lenguaje>>=
(define (expresión? x)
  (cond
   [(variable? x)        (string? (variable-nombre x))]
   [(abstracción? x)     (and (variable? (abstracción-argumento x))
                              (expresión? (abstracción-cuerpo x)))]
   [(aplicación? x)      (and (expresión? (aplicación-operador x))
                              (expresión? (aplicación-operando x)))]
   [(metainstrucción? x) (and (string? (metainstrucción-nombre x))
                              (every expresión? (metainstrucción-argumentos x)))]
   [(hueco? x)           #t]
   [else                 #f]))

@ %def expresión?
@

Utilizando los constructores [[variable]], [[abstracción]] y [[aplicación]], un término \( λ \) como
\[ (λx.(x\, x)) (λx.(x\, x)) \]
puede ser representado en memoria como


<<construcción de un término>>=
(aplicación (abstracción (variable "x") (aplicación (variable "x") (variable "x")))
            (abstracción (variable "x") (aplicación (variable "x") (variable "x"))))
@ 

el cuál corresponde a un árbol de sintaxis visualizado graficamente como

\begin{center}
  \begin{tikzpicture}[
    aplicacion/.style={circle, draw, fill=white, text centered, anchor=north, text=black},
    abstraccion/.style={rectangle, draw, fill=white, text centered, anchor=north, text=black},
    variables/.style={draw=none, text centered, anchor=north, text=black},
    level distance=0.5cm, growth parent anchor=south, sibling distance=3cm,
    line width=0.4mm,
    ]
    \node (app1) [aplicacion] {} [-]
    child{
      node (abs1) [abstraccion] {\( λ\ x \)}
      child{[sibling distance=2cm]
        node (app2) [aplicacion] {}
        child{
          node (var1) [variables] {\( x \)}
        }
        child{
          node (var2) [variables] {\( x \)}
        }
      }
    }
    child{
      node (abs2) [abstraccion] {\( λ\ x \)}
      child{[sibling distance=2cm]
        node (app3) [aplicacion] {}
        child{
          node (var3) [variables] {\( x \)}
        }
        child{
          node (var4) [variables] {\( x \)}
        }
      }
    };
  \end{tikzpicture}
\end{center}

\paragraph{Módulo de estructuras del lenguaje} Las estructuras y procedimientos del árbol de sintaxis son agrupados en un módulo de [[Racket]] el cuál podrá ser accesado desde otros módulos. Para ``exportar'' los identificadores definidos se utiliza el macro [[provide]].


<<provee las definiciones del árbol>>=
(provide variable variable? variable-nombre
         abstracción abstracción? abstracción-argumento abstracción-cuerpo
         aplicación aplicación? aplicación-operador aplicación-operando
         metainstrucción metainstrucción? metainstrucción-nombre metainstrucción-argumentos
         hueco hueco?
         término? expresión?)
@ 

El archivo [[estructuras.rkt]] contiene este módulo y tiene la siguiente forma:

<<estructuras.rkt>>=
;;; -*- mode: racket; coding: utf-8 -*-
;;; Copyright (C) 2016 Eduardo Acuña Yeomans <eduardo.acye@gmail.com>
;;; Procura no editar este archivo, mejor modifica lambda.nw

#lang racket/base

(require srfi/1)

<<provee las definiciones del árbol>>

;;; Estructuras del árbol de sintaxis
<<estructuras del lenguaje>>

;;; Predicados especiales
<<predicados del lenguaje>>
@

@ \section*{Lectura de expresiones}

\paragraph{Representación textual} El lenguaje de [[lambda]] es descrito conceptualmente por las estructuras de los árboles de sintaxis. Sin embargo es tedioso definir expresiones del lenguaje escribiendo manualmente los constructores de las expresiones. Trabajando en un contexto meramente textual como en el código de un lenguaje de programación es conveniente tener una manera de transformar una cadena de caracteres como ``\( \mathrm{(λx.(x x))(λx.(x x))} \)'' (o mejor aún, con abuso de notación ``\( \mathrm{(λx.x x) λx.x x} \)'' ) a un árbol de sintaxis de este término. Este es el trabajo del lector.

La representación textual del lenguaje contempla la escritura de términos descrita en la definición formal de \( Λ \) y los abusos de notación contemplados en el trabajo. Adicionalmente se reprsentan las metainstrucciones de tal manera que

<<pseudocódigo de una metainstrucción>>=
(metainstrucción nombre (list argumento-0 argumento-1 ... argumento-n))
@

tiene como representación textual

[["nombre[argumento-0, argumento-1, ... , argumento-n]"]]

\paragraph{Parser} El lector de expresiones de este lenguaje es un \emph{parser} descendente recursivo que a partir de un puerto de entrada de [[Racket]] construye un árbol de sintaxis.

El procedimiento [[leer]] es el punto de entrada del parser, recibe opcionalmente un puerto llamado [[p]] que por defecto es [[(current-input-port)]].

<<lector de expresiones>>=
(define (leer [p (current-input-port)])
  (let ([e (parsear-expresión p)])
    (cond
     [(and (char? e) (char=? #\; e))
      (leer p)]
     [(not (char? e))
      e]
     [else
      (error 'leer "Se esperaba una expresión completa pero se leyó `~a'" e)])))

@ %def leer
@

El procedimiento [[parsear-expresión]] se encarga de regresar una expresión [[e]], en caso que la estructura sintáctica analizada no haya sido una expresión válida se regresa un caracter que indica el inicio de lo que no se pudo leer. En esta implementación del lector el caracter punto y coma delimita expresiones, por lo tanto, obtener como resultado [[#\;]] provoca que se analice la siguiente expresión del puerto.

La implementación de [[parsear-expresión]] considera un puerto de entrada [[p]] de donde se consumen caracteres, un caracter [[c]] que es el primer caracter del puerto y un acumulador de expresiones [[a]] que representa el árbol leído. A partir de [[c]] se puede determinar el tipo de expresión que se está leyendo.


<<lector de expresiones>>=
(define (parsear-expresión [p (current-input-port)]
                           [c (peek-char p)]
                           [a null])
  (cond
   [(eof-object? c)
    <<lectura de fin de archivo>>]
   [(delimitador-final? c)
    <<lectura de delimitador final>>]
   [(char-whitespace? c)
    <<lectura de espacio en blanco>>]
   [(char=? #\( c)
    <<lectura de paréntesis abierto>>]
   [(char=? #\[ c)
    <<lectura de hueco>>]
   [(or (char=? (integer->char 955) c)
        (char=? #\\ c))
    <<lectura de lambda>>]
   [else
    <<lectura de variable o metainstrucción>>]))

@ %def parsear-expresión
@

El análisis de casos tiene tres cláusulas ``triviales'': cuando no hay más que leer del puerto, cuando se lee un delimitador final y cuando se lee un espacio en blanco. Cuando el siguiente objeto del puerto de entrada es el ``fin de archivo'', el lector debe regresar este objeto si el acumulador [[a]] es núlo, de lo contrario se regresa la expresión acumulada.

<<lectura de fin de archivo>>=
(if (null? a) c a)
@

El siguiente caso es la lectura de un delimitador final, el procedimiento [[delimitador-final?]] se encarga de determinar si un caracter termina una expresión.

<<procedimientos auxiliares de lectura>>=
(define (delimitador-final? c)
  (or (eof-object? c)
      (char=? #\] c)
      (char=? #\) c)
      (char=? #\. c)
      (char=? #\, c)
      (char=? #\; c)))

@ %def delimitador-final?
@

Cuando un objeto leído de un puerto de entrada satisface este predicado, el lector consume y regresa el delimitador si el acumulador [[a]] es núlo, de lo contrario regresa la expresión acumulada.

<<lectura de delimitador final>>=
(if (null? a) (read-char p) a)
@ 

El caracter delimitador no es consumido en caso de que [[a]] no sea núlo ya que usualmente los delimitadores finales tienen asociado un delimitador inicial con el que deben concordar, por ejemplo, el predicado [[delimitador-inicial?]] se define\footnote{Se realiza una comparación con [[(integer->char 955)]] ya que 955 es el valor numérico del caracter \( λ \) en Unicode.} como

<<procedimientos auxiliares de lectura>>=
(define (delimitador-inicial? c)
  (or (char=? #\( c)
      (char=? #\[ c)
      (char=? (integer->char 955) c)
      (char=? #\\ c)))

@ %def delimitador-inicial?
@

En el lenguaje, el delimitador [[#\(]] debe estar asociado al delimitador [[#\)]] y de igual manera con [[#\[]] y [[#\]]]. Esta verificación se realiza en otra parte del código, pero se debe preservar la información del delimitador leído.

Técnicamente, los caracteres delimitadores del lenguaje son los que satisfacen los predicados [[delimitador-inicial?]], [[delimitador-final?]] y [[char-whitespace?]], sin embargo es conveniente definirlos por separado ya que son tratados de manera diferente en la lectura de una expresión. Para determinar si algún caracter es delimitador (sin importar el tipo de delimitador que sea) se utiliza el predicado [[delimitador?]].

<<procedimientos auxiliares de lectura>>=
(define (delimitador? c)
  (or (delimitador-final? c)
      (delimitador-inicial? c)
      (char-whitespace? c)))

@ %def delimitador?
@

El tercer y último caso ``trivial'' en la lectura es el de espacios en blanco. Al encontrarse un caracter de este tipo se consume del puerto y se llama de manera recursiva [[parsear-expresión]] de tal manera que el caracter es ignorado y se preserva el valor de la expresión acumulada [[a]].

<<lectura de espacio en blanco>>=
(read-char p)
(parsear-expresión p (peek-char p) a)
@

El resto de los casos son significativamente más complejos que los primeros tres. Primero se aborda el leer un paréntesis abierto, esto puede ocurrir cuando se desea agrupar una aplicación o una abstracción. El procedimiento [[parsear-paréntesis]] se encarga de leer una expresión después de un paréntesis abierto y verificar que dicha expresión termina con un paréntesis cerrado.

<<lectura de paréntesis abierto>>=
(read-char p)
(let ([e (parsear-paréntesis p)])
  (parsear-expresión p (peek-char p) (aplicación/identidad a e)))
@ 

Primero se consume el caracter [[#\(]] del puerto de entrada, después se llama el procedimiento [[parsear-paréntesis]] el cuál regresará la expresión [[e]] delimitada por [[#\(]] y [[#\)]]. El procedimiento [[parsear-expresión]] es llamado de manera recursiva ya que es posible que esta expresión entre paréntesis sea parte de una aplicación escrita con abuso de notación, por ejemplo [[(M N)P]]. El resultado es acumulado con el procedimiento [[aplicación/identidad]], este contempla la posibilidad que la expresión leída sea parte de una expresión de la forma [[M(N P)]] y se define como

<<procedimientos auxiliares de lectura>>=
(define (aplicación/identidad a e)
  (if (null? a) e (aplicación a e)))

@ %def aplicación/identidad
@

Cuando el acumulador [[a]] es núlo, el nuevo acumulador es la expresión [[e]], de lo contrario, el nuevo acumulador es la aplicación de [[a]] con [[e]].

El procedimiento [[parsear-paréntesis]] lee una expresión [[e]], verifica que el resultado es una aplicación o una abstracción y verifica que el caracter después la representación textual de [[e]] es un paréntesis cerrado.

<<procedimientos auxiliares de lectura>>=
(define (parsear-paréntesis [p (current-input-port)]
                            [c (peek-char p)])
  (let ([e (parsear-expresión p c)])
    (unless (or (abstracción? e) (aplicación? e))
      (error 'parsear-paréntesis
             "Se esperaba una abstracción o una aplicación pero se leyó ~a" e))
    (let ([c (read-char p)])
      (unless (char=? #\) c)
        (error 'parsear-paréntesis
               "Se esperaba `)' pero se leyó `~a'" c))
      e)))

@ %def parsear-paréntesis
@

Ahora se aborda el caso de leer el caracter [[#\[]] este caracter es utilizado después de leer el nombre de una metainstrucción, sin embargo, cuando se encuentra este caracter por sí solo denota el inicio de un hueco, los cuales se conforman de un corchete abierto y uno cerrado con espacios en blanco opcionales entre los corchetes.

<<lectura de hueco>>=
(read-char p)
(let ([e (parsear-hueco p)])
  (parsear-expresión p (peek-char p) (aplicación/identidad a e)))
@

<<procedimientos auxiliares de lectura>>=
(define (parsear-hueco [p (current-input-port)]
                       [c (peek-char p)])
  (cond [(char-whitespace? c)
         (read-char p)
         (parsear-hueco p (peek-char p))]
        [(char=? #\] c)
         (read-char p)
         (hueco)]
        [else
         (error 'parsear-hueco
                "Se esperaba `]' pero se leyó `~a'" c)]))

@ %def parsear-hueco
@


El siguiente caso es leer un caracter que representa a \( λ \), en esta implementación estos caracteres son [[#\\]] y el resultado de [[(integer->char 955)]] que es el caracter Unicode de la letra lambda minúscula. De manera similar a la lectura de paréntesis abierto, se consume del puerto el caracter leído, se obtiene la abstracción con el procedimiento [[parsear-abstracción]] y se manejan los abusos de notación de la aplicación.

<<lectura de lambda>>=
(read-char p)
(let ([e (parsear-abstracción p)])
  (parsear-expresión p (peek-char p) (aplicación/identidad a e)))
@ 

La implementación del procedimiento [[parsear-abstracción]] es un poco más compleja a la de [[parsear-paréntesis]], la representación textual de las abstracciones con el abuso de notación es de la forma [["\ x-1 x-2 ... x-n . M"]], ya que el procedimiento inicia después de consumir el caracter de \( λ \), primero se deben identificar todas las variables antes del punto y regresar una abstracción ``descurrificada''.

<<procedimientos auxiliares de lectura>>=
(define (parsear-abstracción [p (current-input-port)]
                             [c (peek-char p)])
  (let itera ([c c]
              [a null])
    (cond [(or (eof-object? c)
               (and (delimitador? c) (not (char-whitespace? c)) (not (char=? #\. c))))
           (error 'parsear-abstracción
                  "Se esperaba una variable pero se leyó `~a'" c)]
          [(char-whitespace? c)
           (read-char p)
           (itera (peek-char p) a)]
          [(char=? #\. c)
           (read-char p)
           (if (null? a)
               (error 'parsear-abstracción
                      "Se esperaba una variable pero se leyó `~a'" c)
               (let ([e (parsear-expresión p)])
                 (if (expresión? e)
                     (foldr abstracción e (reverse a))
                     (error 'parsear-abstracción
                            "Se esperaba una expresión pero se leyó ~a" e))))]
          [else
           (let ([v (variable (parsear-constituyente p))])
             (itera (peek-char p) (cons v a)))])))

@ %def parsear-abstracción
@

El procedimiento [[parsear-constituyente]] se utiliza para consumir del puerto de entrada una cadena de caracteres constituida por no-delimitadores.

<<procedimientos auxiliares de lectura>>=
(define (parsear-constituyente [p (current-input-port)]
                               [c (peek-char p)])
  (let itera ([a null]
              [c c])
    (if (delimitador? c)
        (if (null? a)
            (error 'parsear-constituyente
                   "Se esperaba un identificador pero se leyó `~a'" c)
            (list->string (reverse a)))
        (itera (cons (read-char p) a)
               (peek-char p)))))

@ %def parsear-constituyente
@

Las cadenas conformadas por caracteres constituyentes son usadas en los nombres de las variables y metainstrucciones, para determinar si una cadena es un ``nombre'' se puede utilizar el predicado [[nombre?]].

<<procedimientos auxiliares de lectura>>=
(define (nombre? x)
  (and (string? x)
       (not (string=? x ""))
       (not (any delimitador? (string->list x)))))

@ %def nombre? 
@

La última cláusula del análisis de casos se encarga de leer variables o metainstrucciones, esto es debido a que ambas inician con la lectura de caracteres constituyentes. Para obtener la variable o la expresión se lee una cadena de caracteres constituyentes del puerto de entrada, si el delimitador de esta cadena es [[#\[]] entonces la expresión debe ser una metainstrucción, de lo contrario debe ser una variable.

<<obtener variable o metainstrucción>>=
(let* ([x (parsear-constituyente p c)]
       [c (peek-char p)])
  (cond [(and (char? c) (char=? #\[ c))
         (read-char p)
         (metainstrucción x (parsear-corchetes p))]
        [else
         (variable x)]))
@ 

Al igual que en el caso del paréntesis abierto y que la \( λ \), se debe acumular este valor utilizando [[aplicación/identidad]].

<<lectura de variable o metainstrucción>>=
((lambda (e)
   (parsear-expresión p (peek-char p) (aplicación/identidad a e)))
 <<obtener variable o metainstrucción>>)
@ 

En el caso que la expresión termine con el corchete abierto, se utiliza el procedimiento [[parsear-corchetes]] para obtener una lista de expresiones separadas por coma y delimitadas por [[#\]]]. Es importante tener en cuenta que no se admiten espacios entre el nombre de una metainstrucción y el corchete que denota el inicio de su lista de argumentos.

<<procedimientos auxiliares de lectura>>=
(define (parsear-corchetes [p (current-input-port)]
                           [c (peek-char p)])
  (let itera ([a null]
              [e (parsear-expresión p c)])
       (cond [(eof-object? e)
              (error 'parsear-corchetes
                     "Se esperaba leer `]' o `,' pero se leyó ~a" e)]
             [(char? e)
              (case e
                [(#\]) (reverse a)]
                [(#\,) (itera a (parsear-expresión p))]
                [else
                 (error 'parsear-corchetes
                        "Se esperaba leer `]' o `,' pero se leyó ~a" e)])]
             [else
              (itera (cons e a) (parsear-expresión p))])))

@ %def parsear-corchetes
@

@ \paragraph{Módulo de lector} El módulo del lector utiliza el módulo de [[estructuras.rkt]] y provee el procedimiento [[leer]], evitando que los usuarios del parser malutilicen los procedimientos auxiliares de lectura. Adicionalmente se proveen los predicados [[delimitador?]] y [[nombre?]] que pueden ser reutilizados en otras partes del programa. El archivo [[lector.rkt]] contiene este módulo y tiene la siguiente forma:

<<lector.rkt>>=
;;; -*- mode: racket; coding: utf-8 -*-
;;; Copyright (C) 2016 Eduardo Acuña Yeomans <eduardo.acye@gmail.com>
;;; Procura no editar este archivo, mejor modifica lambda.nw

#lang racket/base

(require srfi/1
         "estructuras.rkt")

;;; Exportar punto de entrada del parser
(provide leer
         delimitador? nombre?)

;;; Procedimientos principales
<<lector de expresiones>>

;;; Procedimientos auxiliares
<<procedimientos auxiliares de lectura>>
@ 

@ \paragraph{Pruebas del lector} El archivo de pruebas [[lector-pruebas.rkt]] es utilizado para verificar si la funcionalidad del lector es la esperada. Se omite su definición en este documento pero es distribuído con el código del trabajo.

@ \section*{Escritura de expresiones}

Así como se tiene un mecanismo para pasar de la representación externa textual de una expresión a una estructura en memoria, también se tiene un mecanismo para realizar el procedimiento inverso, es decir, escribir la representación externa textual de una estructura en memoria.

@ \paragraph{Diversidad en la escritura}
En el caso del lenguaje de expresiones esto es algo complicado ya que hay varias representaciones textuales para una sola expresión, por ejemplo, formalmente correcta o con algún abuso de notación. Por lo tanto, la escritura de expresiones se maneja utilizando diferentes procedimientos que resultan en estilos diversos de escritura.

Una cuestión importante que se debe tener en cuenta es que una misma representación externa textual puede escribirse para ser interpretada de manera diferente, por ejemplo, se pudieran escribir diferentes ``backends'' de escritura: texto plano, \LaTeX, [[postscript]], o incluso escribir la estructura en memoria de Racket a otro lenguaje de programación en la que pueda ser representada.

Los escritores que son implementados en el programa son:

\begin{itemize}
\item A texto plano sin abuso de notación;
\item A texto plano con abuso de notación;
\item A \LaTeX sin abuso de notación;
\item A \LaTeX con abuso de notación.
\end{itemize}

Se abordan estos estilos en orden.

@ \paragraph{De expresiones a texto plano}

Para traducir una expresión a texto plano se procesa el árbol de manera recursiva, concatenando cadenas de caracteres con la representación externa de las subexpresiones.

Primero define el procedimiento [[expresión->texto-plano]] el cuál se encarga de identificar la clase de expresión que se desea traducir.

<<A texto plano sin abuso>>=
(define (expresión->texto-plano e)
  (cond
   [(variable? e)
    <<Traducir variable a texto plano sin abuso>>]
   [(abstracción? e)
    <<Traducir abstracción a texto plano sin abuso>>]
   [(aplicación? e)
    <<Traducir aplicación a texto plano sin abuso>>]
   [(hueco? e)
    <<Traducir hueco a texto plano sin abuso>>]
   [(metainstrucción? e)
    <<Traducir metainstrucción a texto plano sin abuso>>]
   [else
    (error 'expresión->texto-plano
           "La expresión ~a no es válida" e)]))

@ %def expresión->texto-plano
@

Para traducir una variable a texto plano sin abuso de notación, basta con obtener el nombre de la variable ya que los nombres de las variables ya son cadenas de caracteres. Sin embargo, la traducción de variables es utilizada en la traducción de abstracciones, por lo tanto es conveniente definir el procedimiento [[variable->texto-plano]] el cuál regresa su nombre.

<<A texto plano sin abuso>>=
(define (variable->texto-plano e)
  (variable-nombre e))

@ %def variable->texto-plano
@

En [[expresión->texto-plano]] solo se invoca este procedimiento

<<Traducir variable a texto plano sin abuso>>=
(variable->texto-plano e)
@

Para traducir una abstracción a texto plano sin abuso de notación, primero se debe traducir su argumento y su cuerpo y después concatenarlos de la forma \( (λ \mathtt{argumento} . \mathtt{cuerpo}) \).

<<Traducir abstracción a texto plano sin abuso>>=
(format "(~a~a.~a)"
        (integer->char 955)
        (variable->texto-plano (abstracción-argumento e))
        (expresión->texto-plano (abstracción-cuerpo e)))
@ 

Para traducir una aplicación a texto plano sin abuso de notación, se traduce su operador y su operando y después se concatenan de la forma \( (\mathtt{operador}\ \mathtt{operando}) \).

<<Traducir aplicación a texto plano sin abuso>>=
(format "(~a ~a)"
        (expresión->texto-plano (aplicación-operador e))
        (expresión->texto-plano (aplicación-operando e)))
@ 

La traducción de un hueco a texto plano sin abuso de notación es simplemente la cadena compuesta por el corchete abierto y el corchete cerrado.

<<Traducir hueco a texto plano sin abuso>>=
"[ ]"
@ 

La traducción de una metainstrucción a texto plano sin abuso de notación es un poco más complicada que en los otros casos. Primero se verifica que el nombre de la metainstrucción es una cadena de caracteres y que los argumentos de la metainstrucción sean una lista, después se obtiene una lista de las traducciones de cada expresión en la lista de argumentos de la metainstrucción, teniendo esta lista se concatenan comas entre cada argumento de la lista.

<<Traducir metainstrucción a texto plano sin abuso>>=
(let ([nombre     (metainstrucción-nombre     e)]
      [argumentos (metainstrucción-argumentos e)])
  (format "~a[~a]"
              nombre
              (string-join (map expresión->texto-plano argumentos) ", ")))
@ 

En ocaciones será de utilidad obtener la representación externa de una expresión con las convenciones de abuso de notación utilizadas en este trabajo. La lectura de expresiones admite el abuso de notación en cualquier parte de la expresión, sin embargo, para la escritura de expresiones con abuso, habrá una sola representación externa con abuso de notación y será aquella que aproxime la máxima cantidad de abuso de notación posible.

La implementación del escritor para texto plano con abuso de notación es el procedimiento [[expresión->abuso-texto-plano]] el cuál tiene una forma similar a [[expresión->texto-plano]] sólo que en el análisis de casos se invocan procedimientos especializados para cada clase de expresión.

<<A texto plano con abuso>>=
(define (expresión->abuso-texto-plano e)
  (cond
   [(variable? e)
    (variable->abuso-texto-plano e)]
   [(abstracción? e)
    (abstracción->abuso-texto-plano e)]
   [(aplicación? e)
    (aplicación->abuso-texto-plano e)]
   [(hueco? e)
    (hueco->abuso-texto-plano e)]
   [(metainstrucción? e)
    (metainstrucción->abuso-texto-plano e)]
   [else
    (error 'expresión->abuso-texto-plano
           "La expresión ~a no es válida" e)]))

@ %def expresión->abuso-texto-plano
@

Para traducir una variable a texto plano con abuso de notación, se hace uso del procedimiento [[variable->texto-plano]] ya que las variables tienen una sola representación externa en texto plano.

<<A texto plano con abuso>>=
(define (variable->abuso-texto-plano e)
  (variable->texto-plano e))

@ %def variable->abuso-texto-plano
@

La traducción de abstracciones a texto plano con abuso de notación consiste en revisar la clase de expresión que es el cuerpo, en caso que sea también una abstracción se debe iterar sobre los cuerpos de las abstracciones acumulando la representación externa de sus argumentos hasta llegar a un cuerpo que no sea abstracción. La forma de la cadena resultante debe ser \( λ\mathtt{argumento}_{1}\ \mathtt{argumento}_{2}\ ...\ \mathtt{argumento}_{n}.\mathtt{cuerpo}_{n} \).

<<A texto plano con abuso>>=
(define (abstracción->abuso-texto-plano e)
  (let itera ([cuerpo (abstracción-cuerpo e)]
              [resultado (format "~a~a"
                                 (integer->char 955)
                                 (variable->abuso-texto-plano (abstracción-argumento e)))])
    (if (not (abstracción? cuerpo))
        (format "~a.~a" resultado (expresión->abuso-texto-plano cuerpo))
        (itera (abstracción-cuerpo cuerpo)
               (format "~a ~a"
                       resultado
                       (variable->abuso-texto-plano (abstracción-argumento cuerpo)))))))

@ %def abstracción->abuso-texto-plano
@

Para traducir una aplicación a texto plano con abuso de notación primero se computa una lista de términos conformada por los operandos anidados de las aplicaciones de la forma \( ((M\ N) P) \) donde el primer operador que no sea aplicación es el primer elemento de la lista, es decir, se obtiene la lista de expresiones removiendo la asociación a la izquierda de la aplicación original, por ejemplo si consideramos una aplicación de la forma\[ (...\ ((((M_{1}\ M_{2})\ M_{3})\ M_{4})\ M_{5})\ ...\ M_{n}) \]la lista de expresiones seria\[ \mathtt{(list}\ M_{1}\ M_{2}\ M_{3}\ M_{4}\ M_{5}\ ...\ M_{n} \mathtt{)} \]donde \( M_{1} \) no es una aplicación.

Después de remover la asociación a la izquierda se determinan los elementos de la lista que deben estar encerrados entre paréntesis. El criterio utilizado en general es: si el elemento de la lista es una aplicación o una abstracción, va encerrada entre paréntesis, de lo contrario, se escribe tal cuál. Además se aplica un criterio diferente para un caso en particular: cuando el último elemento de la lista es una abstracción, no se encierra entre paréntesis, esto es para que una expresión como\[ (((M\ N)\ P)\ (λx.Q)) \]pueda ser escrita como\[ M\ N\ P\ λx.Q \]la cuál es una expresión sintácticamente equivalente. Esto no se puede realizar para las abstracciones en general ya que una expresión como\[ ((M\ (λx.N))\ P) \]sería considerada equivalente a\[ M\ λx.N\ P \]sin embargo, esta última expresión corresponde a\[ (M\ (λx.(N\ P))) \]al tener los paréntesis escritos de manera adecuada se concatenan las expresiones con un espacio en blanco.

El procedimiento [[aplicación->abuso-texto-plano]] implementa este algoritmo para el abuso de notación.

<<A texto plano con abuso>>=
(define (aplicación->abuso-texto-plano e)
  (let itera ([operador (aplicación-operador e)]
              [resultado (format " ~a"
                                 (let ([e (aplicación-operando e)])
                                   (if (aplicación? e)
                                       (format "(~a)" (aplicación->abuso-texto-plano e))
                                       (expresión->abuso-texto-plano e))))])
    (if (not (aplicación? operador))
        (format "~a~a"
                (cond [(aplicación? operador)
                       (format "(~a)" (aplicación->abuso-texto-plano operador))]
                      [(abstracción? operador)
                       (format "(~a)" (abstracción->abuso-texto-plano operador))]
                      [else
                       (expresión->abuso-texto-plano operador)])
                resultado)
        (let ([e (aplicación-operando operador)])
          (itera (aplicación-operador operador)
                 (format " ~a~a"
                         (cond [(aplicación? e)
                                (format "(~a)" (aplicación->abuso-texto-plano e))]
                               [(abstracción? e)
                                (format "(~a)" (abstracción->abuso-texto-plano e))]
                               [else
                                (expresión->abuso-texto-plano e)])
                         resultado))))))

@ %def aplicación->abuso-texto-plano
@

La traducción a texto plano con abuso de notación para huecos es exactamente la misma que cuando no se tiene abuso de notación.

<<A texto plano con abuso>>=
(define (hueco->abuso-texto-plano e)
  "[ ]")

@ %def hueco->abuso-texto-plano
@

En el caso de la traducción de metainstrucciones a texto plano con abuso de notación se emplea el mismo procedimiento que en el caso donde no hay abuso de notación, con la excepción de que las llamadas recursivas a la traducción de argumentos se realizan invocando el procedimiento [[expresión->abuso-texto-plano]] en lugar de [[expresión->texto-plano]].

<<A texto plano con abuso>>=
(define (metainstrucción->abuso-texto-plano e)
  (let itera ([argumentos (metainstrucción-argumentos e)]
              [resultado (format "~a[" (metainstrucción-nombre e))])
    (cond [(null? argumentos)
           (format "~a]" resultado)]
          [(null? (cdr argumentos))
           (format "~a~a]"
                   resultado
                   (expresión->abuso-texto-plano (car argumentos)))]
          [else
           (itera (cdr argumentos)
                  (format "~a~a, "
                          resultado
                          (expresión->abuso-texto-plano (car argumentos))))])))

@ %def metainstrucción->abuso-texto-plano
@

@ \paragraph{De expresiones a \LaTeX} Traducir expresiones a código interpretable por \LaTeX{} es relativamente fácil, esta tarea se divide en dos: la escritura de la expresión en sí y la plantilla del documento. Primero se define la plantilla del documento en donde se encuentra el preámbulo, el [[\begin{document}]] y [[\end{document}]]. El parámetro [[plantilla-latex]] contiene una cadena de caracteres que es utilizada de tal manera que [[(format (plantilla-latex) expresión-latex)]] sea una cadena de caracteres con el contenido de un documento válido de \LaTeX{}.

<<A LaTeX sin abuso>>=
(define +plantilla-latex-inicial+
  "\
\\documentclass[preview]{standalone}\n\
\\usepackage{amsmath}\n\
\\begin{document}\n\
\\( ~a \\)\n\
\\end{document}")

(define plantilla-latex
  (make-parameter
   +plantilla-latex-inicial+
   (lambda (x)
     (if (and (string? x) (= (length (string-split x "~a" #:trim? #f)) 2))
         x
         +plantilla-latex-inicial+))))

@ %def plantilla-latex
@

Los escritores para \LaTeX{} tienen una estructura similar a los de texto plano, la única diferencia es que se escriben comandos del modo de matemáticas de \LaTeX{} para darle formato a las expresiones. La definición del procedimiento [[expresión->latex]] es similar a [[expresión->texto-plano]].

<<A LaTeX sin abuso>>=
(define (expresión->latex e)
  (cond
   [(variable? e)
    (variable->latex e)]
   [(abstracción? e)
    (abstracción->latex e)]
   [(aplicación? e)
    (aplicación->latex e)]
   [(hueco? e)
    (hueco->latex e)]
   [(metainstrucción? e)
    (metainstrucción->latex e)]
   [else
    (error 'expresión->latex
           "La expresión ~a no es válida" e)]))

@ %def expresión->latex
@

Para la traducción de una variable a \LaTeX{} sin abuso de notación simplemente se obtiene su nombre.

<<A LaTeX sin abuso>>=
(define (variable->latex e)
  (variable-nombre e))

@ %def variable->latex
@

La traducción de una abstracción a \LaTeX{} sin abuso de notación es igual que en el caso de texto plano, solo que el símbolo \( λ \) es escrito [[\lambda]].

<<A LaTeX sin abuso>>=
(define (abstracción->latex e)
  (format "(\\lambda ~a . ~a)"
          (variable->latex (abstracción-argumento e))
          (expresión->latex (abstracción-cuerpo e))))

@ %def abstracción->latex
@

De manera similar se traduce una aplicación a \LaTeX{} sin abuso de notación, la diferencia en este caso es que el espacio entre el operador y el operando se escribe [[\, ]].

<<A LaTeX sin abuso>>=
(define (aplicación->latex e)
  (format "(~a\\, ~a)"
          (expresión->latex (aplicación-operador e))
          (expresión->latex (aplicación-operando e))))

@ %def aplicación->latex
@

Para traducir un hueco a \LaTeX{} sin abuso de notación se traduce el espacio como [[\quad]].

<<A LaTeX sin abuso>>=
(define (hueco->latex e)
  "[\\quad ]")

@ %def hueco->latex
@

Para traducir una metainstrucción a \LaTeX{} sin abuso de notación se computa la lista de cadenas de los argumentos separados por la coma y el espacio [[\, ]].

<<A LaTeX sin abuso>>=
(define (metainstrucción->latex e)
  (let ([nombre     (metainstrucción-nombre e)]
        [argumentos (metainstrucción-argumentos e)])
    (format "~a[~a]"
            nombre
            (string-join (map expresión->latex argumentos) ",\\, "))))

@ %def metainstrucción->latex
@

La implementación del escritor a \LaTeX{} con abuso de notación sigue el algoritmo de escritura a texto plano con abuso.

Siguiendo las convenciones de los escritores previamente definidos, [[expresión->abuso-latex]] implementa el despacho a escritores especializados por la clase de expresión.

<<A LaTeX con abuso>>=
(define (expresión->abuso-latex e)
  (cond
   [(variable? e)
    (variable->abuso-latex e)]
   [(abstracción? e)
    (abstracción->abuso-latex e)]
   [(aplicación? e)
    (aplicación->abuso-latex e)]
   [(hueco? e)
    (hueco->abuso-latex e)]
   [(metainstrucción? e)
    (metainstrucción->abuso-latex e)]
   [else
    (error 'expresión->abuso-latex
           "La expresión ~a no es válida" e)]))

@ %def expresión->abuso-latex
@

Los escritores especializados para traducir a \LaTeX{} con abuso de notación se basan en la escritura a texto plano con abuso.

<<A LaTeX con abuso>>=
(define (variable->abuso-latex e)
  (variable->texto-plano e))

(define (abstracción->abuso-latex e)
  (let itera ([cuerpo (abstracción-cuerpo e)]
              [resultado (format "\\lambda ~a"
                                 (variable->abuso-latex (abstracción-argumento e)))])
    (if (not (abstracción? cuerpo))
        (format "~a . ~a" resultado (expresión->abuso-latex cuerpo))
        (itera (abstracción-cuerpo cuerpo)
               (format "~a\\, ~a"
                       resultado
                       (variable->abuso-latex (abstracción-argumento cuerpo)))))))

(define (aplicación->abuso-latex e)
  (let itera ([operador (aplicación-operador e)]
              [resultado (format "\\, ~a"
                                 (let ([e (aplicación-operando e)])
                                   (if (aplicación? e)
                                       (format "(~a)" (aplicación->abuso-latex e))
                                       (expresión->abuso-latex e))))])
    (if (not (aplicación? operador))
        (format "~a~a"
                (cond [(aplicación? operador)
                       (format "(~a)" (aplicación->abuso-latex operador))]
                      [(abstracción? operador)
                       (format "(~a)" (abstracción->abuso-latex operador))]
                      [else
                       (expresión->abuso-latex operador)])
                resultado)
        (let ([e (aplicación-operando operador)])
          (itera (aplicación-operador operador)
                 (format "\\, ~a~a"
                         (cond [(aplicación? e)
                                (format "(~a)" (aplicación->abuso-latex e))]
                               [(abstracción? e)
                                (format "(~a)" (abstracción->abuso-latex e))]
                               [else
                                (expresión->abuso-latex e)])
                         resultado))))))

(define (hueco->abuso-latex e)
  "[\\quad ]")

(define (metainstrucción->abuso-latex e)
  (let itera ([argumentos (metainstrucción-argumentos e)]
              [resultado (format "~a[" (metainstrucción-nombre e))])
    (cond [(null? argumentos)
           (format "~a]" resultado)]
          [(null? (cdr argumentos))
           (format "~a~a]"
                   resultado
                   (expresión->abuso-latex (car argumentos)))]
          [else
           (itera (cdr argumentos)
                  (format "~a~a,\\, "
                          resultado
                          (expresión->abuso-latex (car argumentos))))])))

@ %def variable->abuso-latex abstracción->abuso-latex aplicación->abuso-latex hueco->abuso-latex metainstrucción->abuso-latex
@

@ \paragraph{Módulo de escritor} El módulo de los escritores utiliza el módulo [[estructuras.rkt]] y provee los procedimientos de escritura a texto plano, \LaTeX~ y a figuras de [[Racket]] con abuso y sin abuso de notación. El archivo [[escritor.rkt]] contiene este módulo y tiene la siguiente forma.

<<escritor.rkt>>=
;;; -*- mode: racket; coding: utf-8 -*-
;;; Copyright (C) 2016 Eduardo Acuña Yeomans <eduardo.acye@gmail.com>
;;; Procura no editar este archivo, mejor modifica lambda.nw

#lang racket/base

(require "estructuras.rkt"
         racket/list
         racket/string
         (for-syntax racket/base))

(provide expresión->texto-plano
         expresión->abuso-texto-plano
         plantilla-latex
         expresión->latex
         expresión->abuso-latex)

;;; Traducir a texto plano sin abuso de notación
<<A texto plano sin abuso>>

;;; Traducir a texto plano con abuso de notación
<<A texto plano con abuso>>

;;; Traducir a LaTeX sin abuso de notación
<<A LaTeX sin abuso>>

;;; Traducir a LaTeX con abuso de notación
<<A LaTeX con abuso>>
@

@ \paragraph{Pruebas de escritores} El archivo de pruebas [[escritor-pruebas.rkt]] es utilizado para verificar si la funcionalidad de los escritores es la esperada. Se omite su definición en este documento pero es distribuído con el código del trabajo.


@ \section*{Evaluador de expresiones}

<<Evaluación de metainstrucciones>>=
(define (evaluar-expresión e)
  (cond
   [(variable? e)
    (variable (variable-nombre e))]
   [(abstracción? e)
    (abstracción (evaluar-expresión (abstracción-argumento e))
                 (evaluar-expresión (abstracción-cuerpo e)))]
   [(aplicación? e)
    (aplicación (evaluar-expresión (aplicación-operador e))
                (evaluar-expresión (aplicación-operando e)))]
   [(hueco? e)
    (hueco)]
   [(metainstrucción? e)
    (cond [(hash-ref metainstrucciones (metainstrucción-nombre e) #f) =>
           (lambda (procedimiento)
             (apply procedimiento (metainstrucción-argumentos e)))]
          [else
           (metainstrucción (metainstrucción-nombre e)
                            (map evaluar-expresión
                                 (metainstrucción-argumentos e)))])]
   [else
    (error 'evaluar-expresión "La expresión ~a no es válida" e)]))

@ %def evaluar-expresión
@

<<Registro de metainstrucciones>>=
(define metainstrucciones (make-hash))

@ %def metainstrucciones
@


<<Macros para definir metainstrucciones>>=
(define-syntax define-metainstrucción
  (syntax-rules ()
    [(_ (id . args) cuerpo ...)
     (begin
       (define (id . args) cuerpo ...)
       (hash-set! metainstrucciones (symbol->string 'id) id))]
    [(_ id value)
     (begin
       (define id value)
       (hash-set! metainstrucciones (symbol->string 'id) id))]))

(define-syntax define-instrucción
  (syntax-rules ()
    [(_ (id . args) cuerpo ...)
     (define-metainstrucción (id . args*)
       (apply (lambda args cuerpo ...)
              (map evaluar-expresión args*)))]
    [(_ id value)
     (define-metainstrucción id
       (lambda args
         (apply value (map evaluar-expresión args))))]))

@ %def define-metainstrucción define-instrucción
@


<<Instrucciones>>=
(define-instrucción (decodifica-numeral M)
  (match M
    [(abstracción (variable f) (abstracción (variable x) N))
     (let itera ([N N]
                 [n 0])
       (match N
         [(== (variable x))
          (variable (number->string n))]
         [(aplicación (== (variable f)) N)
          (itera N (+ n 1))]
         [_
          (variable "-1")]))]
    [_ (variable "-1")]))

@ %def decodifica-numeral
@


<<Instrucciones>>=
(define-instrucción (codifica-número M)
  (match M
    [(variable x)
     (let ([n (string->number x)])
       (if (and (number? n) (integer? n) (>= n 0))
           (abstracción
            (variable "f")
            (abstracción
             (variable "x")
             (let itera ([n n])
               (if (zero? n)
                   (variable "x")
                   (aplicación (variable "f")
                               (itera (- n 1)))))))
           M))]
    [_
     M]))

@ %def codifica-número
@


@ \section*{Ciclo de Lectura Evaluación y Escritura}

\paragraph{Pendiente}

@ \section*{Editor estructural}

\paragraph{Pendiente}

@ \section*{¿Cómo hackear la \( \bs{λ} \)?}


\end{document}